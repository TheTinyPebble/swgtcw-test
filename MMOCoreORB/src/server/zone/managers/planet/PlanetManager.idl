/*
Copyright (C) 2007 <SWGEmu>
 
This File is part of Core3.
 
This program is free software; you can redistribute 
it and/or modify it under the terms of the GNU Lesser 
General Public License as published by the Free Software
Foundation; either version 2 of the License, 
or (at your option) any later version.
 
This program is distributed in the hope that it will be useful, 
but WITHOUT ANY WARRANTY; without even the implied warranty of 
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
See the GNU Lesser General Public License for
more details.
 
You should have received a copy of the GNU Lesser General 
Public License along with this program; if not, write to
the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 
Linking Engine3 statically or dynamically with other modules 
is making a combined work based on Engine3. 
Thus, the terms and conditions of the GNU Lesser General Public License 
cover the whole combination.
 
In addition, as a special exception, the copyright holders of Engine3 
give you permission to combine Engine3 program with free software 
programs or libraries that are released under the GNU LGPL and with 
code included in the standard release of Core3 under the GNU LGPL 
license (or modified versions of such code, with unchanged license). 
You may copy and distribute such a system following the terms of the 
GNU LGPL for Engine3 and the licenses of the other code concerned, 
provided that you include the source code of that other code when 
and as the GNU LGPL requires distribution of source code.
 
Note that people who make modified versions of Engine3 are not obligated 
to grant this special exception for their modified versions; 
it is their choice whether to do so. The GNU Lesser General Public License 
gives permission to release a modified version without this exception; 
this exception also makes it possible to release a modified version 
which carries forward this exception.
*/

package server.zone.managers.planet;

import engine.core.ManagedService;
import server.zone.Zone;
import server.zone.ZoneProcessServer;
import engine.log.Logger;
import server.zone.objects.building.BuildingObject;
import system.thread.Thread;
import system.util.SortedVector;
import system.util.VectorMap;
import system.util.HashTable;
import system.util.Vector;
import server.zone.objects.region.CityRegion;
import server.zone.objects.scene.variables.StringId;
import server.zone.managers.weather.WeatherManager;
import server.zone.managers.objectcontroller.ObjectController;
import server.zone.objects.creature.CreatureObject;
import server.zone.objects.scene.SceneObject;
include server.zone.objects.region.CityRegion;
include server.zone.managers.planet.RegionMap;
include server.zone.managers.terrain.TerrainManager;
include server.zone.managers.planet.NoBuildAreaMap;
include server.zone.managers.planet.MissionTargetMap;
include server.zone.managers.planet.HuntingTargetMap;
include server.zone.managers.planet.HuntingTargetEntry;
include server.zone.templates.snapshot.WorldSnapshotNode;
include server.zone.templates.snapshot.WorldSnapshotIff;
include server.zone.managers.planet.PlanetTravelPointList;
include server.zone.managers.planet.PlanetTravelPoint;
include engine.lua.LuaObject;
include server.zone.objects.building.tasks.ShuttleDepartureTask;
include server.zone.objects.creature.CreaturePosture;

class PlanetManager extends ManagedService implements Logger {
	@weakReference
	protected Zone zone;
	
	protected RegionMap cityRegionMap;
	
	@dereferenced
	protected transient SortedVector<ShuttleDepartureTask> shuttleTasks;
	
	@dereferenced
	protected VectorMap<string, int> travelFares;
	
	protected PlanetTravelPointList planetTravelPointList;
	
	//In miliseconds.
	protected int shuttleLandingDelay;
	protected int shuttleTakeoffDelay;

	protected WeatherManager weatherManager;
	
	protected int numberOfCities;
		
	protected transient ZoneProcessServer server;

	protected transient TerrainManager terrainManager;
	
	protected transient NoBuildAreaMap noBuildAreaMap;
	
	protected transient MissionTargetMap missionNpcs;
	
	protected transient MissionTargetMap performanceLocations;
	
	protected transient HuntingTargetMap huntingTargets;
	
	protected transient MissionTargetMap reconLocs;
	
	protected transient MissionTargetMap informants;
	
	public PlanetManager(Zone planet, ZoneProcessServer srv) {
		zone = planet;
		server = srv;
				
		Logger.setLoggingName("PlanetManager " + zone.getZoneName());
		Logger.setLogging(false);
		Logger.setGlobalLogging(true);

		terrainManager = null;
		
		numberOfCities = 0;
		
		shuttleLandingDelay = 300000;
		shuttleTakeoffDelay = 90000;

		weatherManager = null;

		cityRegionMap = new RegionMap();
		
		travelFares.setNullValue(0);
		travelFares.setNoDuplicateInsertPlan();
		
		planetTravelPointList = new PlanetTravelPointList();
	}
	
	@local
	private native SceneObject loadSnapshotObject(WorldSnapshotNode node, WorldSnapshotIff wsiff, @dereferenced int totalObjects);
	private native void loadSnapshotObjects();
	private native void loadTravelFares();
	
	@local
	private native void loadPlanetObjects(LuaObject lua);
	
	private native void loadLuaConfig();
	
	public native void initializeTransientMembers();
	
	public native void finalize();
	
	public native void initialize();
	public native void loadClientRegions();
	public native void loadPlayerRegions();
	public native void loadNoBuildAreas();
	public native void loadBadgeAreas();
	public native void loadPerformanceLocations();
	public native void loadHuntingTargets();
	public native void loadReconLocations();
	protected native void loadStaticTangibleObjects();
	
	/**
	 * Returns the closest PlanetTravelPoint within the given range.
	 * @param object The object to use as reference.
	 * @param range The maximum range to search within.
	 * @return Returns a string of the name of the closest PlanetTravelPoint.
	 */
	@local
	public native PlanetTravelPoint getNearestPlanetTravelPoint(SceneObject object, float range = 16000.0);

	@local
	public native boolean isNoBuildArea(float x, float y, @dereferenced StringId fullAreaName);
	
	public native boolean isBuildingPermittedAt(float x, float y);
	
	/**
	 * Gets the cost to travel via shuttleport/starport to the destination planet.
	 * If the value is 0, then travel to the planet from this planet is disabled.
	 * @param destinationPlanet The planet that to which is being travelled. Can be the same planet.
	 * @return The cost to travel to the destination planet.
	 */
	public int getTravelFare(final string destinationPlanet) {
		return travelFares.get(destinationPlanet);
	}
	
	public native void sendPlanetTravelPointListResponse(CreatureObject player);
	
	/**
	 * Creates a travel ticket from the departure point on this planet to the arrival point on the arrival planet.
	 * @param departurePoint The point on this planet from which the ticket is set to depart.
	 * @param arrivalPlanet The planet to which the ticket is set to arrive.
	 * @param departurePoint The point on the arrival planet to which the ticket is set to arrive.
	 * @return Returns a travel ticket for the route specified, or NULL if it could not be created.
	 */
	public native SceneObject createTicket(final string departurePoint, final string arrivalPlanet, final string arrivalPoint);
	
	@local
	@dereferenced
	public Vector<CityRegion> getRegions(@dereferenced StringId regionName) {
		return cityRegionMap.getRegions(regionName);
	}

	public WeatherManager getWeatherManager() {
		return weatherManager;
	}
	
	@local
	public TerrainManager getTerrainManager() {
		return terrainManager;
	}
	
	public CityRegion getRegion(float x, float y) {
		return cityRegionMap.getRegion(x, y);
	}
	
	public int getRegionCount() {
		return cityRegionMap.getTotalRegions();
	}
	
	public int getNumberOfCities() {
		return numberOfCities;
	}
	
	public void increaseNumberOfCities() {
		numberOfCities = numberOfCities + 1;
	}
	
	public CityRegion getRegion(int index) {
		return cityRegionMap.getRegion(index);
	}
	
	public void addRegion(CityRegion region) {
		cityRegionMap.addRegion(region);
	}
	
	public void dropRegion(final string region) {
		cityRegionMap.dropRegion(region);
	}
	
	public boolean hasRegion(final string name) {
		return cityRegionMap.containsRegion(name);
	}
	
	public void addPerformanceLocation(SceneObject obj) {
		performanceLocations.add(obj);
	}
	
	@local
	public MissionTargetMap getPerformanceLocations() {
		return performanceLocations;
	}
	
	public void addMissionNpc(SceneObject npc) {
		missionNpcs.add(npc);
	}
	
	@local
	public MissionTargetMap getMissionNpcs() {
		return missionNpcs;
	}
	
	public void addHuntingTargetTemplate(final string temp1, final string temp2, int level) {
		huntingTargets.addTarget(temp1, temp2, level);
	}
	
	@local
	public HuntingTargetEntry getHuntingTargetTemplate(int level) {
		return huntingTargets.getRandomTarget(level);
	}
	
	public void addReconLoc(SceneObject obj) {
		reconLocs.add(obj);
	}
	
	@local
	public MissionTargetMap getReconLocs() {
		return reconLocs;
	}
	
	public void addInformant(SceneObject obj) {
		informants.add(obj);
	}
	
	@local
	public MissionTargetMap getInformants() {
		return informants;
	}
	
	/**
	 * Checks to see if the point is an existing planet travel point.
	 * @param pointName The name of the point to check for.
	 * @return Returns true if the point exists.
	 */
	public boolean isExistingPlanetTravelPoint(final string pointName) {
		return planetTravelPointList.contains(pointName);
	}
	
	/**
	 * Checks to see if interplanetary travel is allowed to the specified point.
	 * @param pointName The point name representing a travel point belonging to this planet.
	 * @return Returns true if interplanetary travel is allowed.
	 */
	public boolean isInterplanetaryTravelAllowed(final string pointName) {
		PlanetTravelPoint ptp = planetTravelPointList.get(pointName);
		
		if (ptp == null)
			return false;
		
		return ptp.isInterplanetary();
	}
	
	/**
	 * Gets the PlanetTravelPoint that corresponds to the point name. If the point doesn't exist
	 * then it will return NULL.
	 * @param pointName The planet travel point's name.
	 * @return PlanetTravelPoint for the given point name.
	 */
	@local
	public PlanetTravelPoint getPlanetTravelPoint(final string pointName) {
		return planetTravelPointList.get(pointName);
	}
	
	/**
	 * Checks to see the travel between the points is allowed based on their settings.
	 * @param destinationPoint The point from which is being traveled.
	 * @param arrivalPlanet The planet to which is being traveled.
	 * @param arrivalPoint The point to which is being traveled.
	 * @return Returns true if travel is permitted between the two points.
	 */
	public native boolean isTravelToLocationPermitted(final string destinationPoint, final string arrivalPlanet, final string arrivalPoint);
	
	public void scheduleShuttle(CreatureObject shuttle) {
		shuttle.setPosture(CreaturePosture.UPRIGHT);
		
		ShuttleDepartureTask task = new ShuttleDepartureTask(shuttle);
		task.schedule(ShuttleDepartureTask.LANDEDTIME);
		
		shuttleTasks.put(task);
	}
}
