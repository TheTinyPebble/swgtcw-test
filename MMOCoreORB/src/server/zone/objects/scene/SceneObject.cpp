/*
 *	server/zone/objects/scene/SceneObject.cpp generated by engine3 IDL compiler 0.60
 */

#include "SceneObject.h"

#include "server/zone/Zone.h"

#include "server/zone/ZoneClientSession.h"

#include "server/zone/ZoneProcessServerImplementation.h"

#include "server/zone/managers/player/ProfessionManager.h"

#include "server/zone/managers/planet/PlanetManager.h"

#include "server/zone/objects/scene/events/UndeploySceneObjectEvent.h"

#include "server/zone/objects/scene/variables/DamageDone.h"

#include "server/zone/objects/scene/variables/SceneObjectReference.h"

#include "server/zone/objects/scene/variables/ItemAttributes.h"

#include "server/zone/objects/scene/variables/CustomizationVariables.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/objects/player/Player.h"

#include "server/zone/objects/building/BuildingObject.h"

#include "server/zone/objects/group/GroupObject.h"

#include "server/zone/packets/object/ObjectMenuResponse.h"

#include "server/zone/packets/scene/AttributeListMessage.h"

/*
 *	SceneObjectStub
 */

SceneObject::SceneObject() : ManagedObject(DummyConstructorParameter::instance()) {
	_impl = new SceneObjectImplementation();
	_impl->_setStub(this);
}

SceneObject::SceneObject(unsigned long long oid, int type) : ManagedObject(DummyConstructorParameter::instance()) {
	_impl = new SceneObjectImplementation(oid, type);
	_impl->_setStub(this);
}

SceneObject::SceneObject(DummyConstructorParameter* param) : ManagedObject(param) {
}

SceneObject::~SceneObject() {
}

bool SceneObject::destroy() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 6);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->destroy();
}

void SceneObject::redeploy() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 7);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->redeploy();
}

void SceneObject::scheduleUndeploy() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 8);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->scheduleUndeploy();
}

void SceneObject::undeploy() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 9);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->undeploy();
}

void SceneObject::removeUndeploymentEvent() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 10);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->removeUndeploymentEvent();
}

void SceneObject::create(ZoneClientSession* client) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 11);
		method.addObjectParameter(client);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->create(client);
}

void SceneObject::destroy(ZoneClientSession* client) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 12);
		method.addObjectParameter(client);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->destroy(client);
}

void SceneObject::link(ZoneClientSession* client, SceneObject* obj) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 13);
		method.addObjectParameter(client);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->link(client, obj);
}

BaseMessage* SceneObject::link(SceneObject* obj, unsigned int type) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 14);
		method.addObjectParameter(obj);
		method.addUnsignedIntParameter(type);

		return (BaseMessage*) method.executeWithObjectReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->link(obj, type);
}

BaseMessage* SceneObject::link(SceneObject* obj) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 15);
		method.addObjectParameter(obj);

		return (BaseMessage*) method.executeWithObjectReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->link(obj);
}

BaseMessage* SceneObject::link(unsigned long long container, unsigned int type) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 16);
		method.addUnsignedLongParameter(container);
		method.addUnsignedIntParameter(type);

		return (BaseMessage*) method.executeWithObjectReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->link(container, type);
}

void SceneObject::close(ZoneClientSession* client) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 17);
		method.addObjectParameter(client);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->close(client);
}

void SceneObject::init() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 18);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->init();
}

void SceneObject::initScriptedValues() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 19);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->initScriptedValues();
}

void SceneObject::insertToZone(Zone* zone) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 20);
		method.addObjectParameter(zone);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->insertToZone(zone);
}

void SceneObject::insertToBuilding(BuildingObject* building) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 21);
		method.addObjectParameter(building);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->insertToBuilding(building);
}

void SceneObject::removeFromZone(bool doLock) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 22);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->removeFromZone(doLock);
}

void SceneObject::removeFromBuilding(BuildingObject* building) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 23);
		method.addObjectParameter(building);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->removeFromBuilding(building);
}

void SceneObject::addDamageDone(CreatureObject* creature, int damage, string& skillname) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 24);
		method.addObjectParameter(creature);
		method.addSignedIntParameter(damage);
		method.addAsciiParameter(skillname);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->addDamageDone(creature, damage, skillname);
}

void SceneObject::dropDamageDone(CreatureObject* creature) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 25);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->dropDamageDone(creature);
}

int SceneObject::getTotalDamage() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 26);

		return method.executeWithSignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getTotalDamage();
}

void SceneObject::disseminateXp(int levels) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 27);
		method.addSignedIntParameter(levels);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->disseminateXp(levels);
}

void SceneObject::cleanupDamageDone() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 28);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->cleanupDamageDone();
}

void SceneObject::broadcastMessage(BaseMessage* msg, int range, bool doLock, bool sendSelf) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 29);
		method.addObjectParameter(msg);
		method.addSignedIntParameter(range);
		method.addBooleanParameter(doLock);
		method.addBooleanParameter(sendSelf);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->broadcastMessage(msg, range, doLock, sendSelf);
}

void SceneObject::broadcastMessage(StandaloneBaseMessage* msg, int range, bool doLock) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 30);
		method.addObjectParameter(msg);
		method.addSignedIntParameter(range);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->broadcastMessage(msg, range, doLock);
}

void SceneObject::broadcastMessages(Vector<BaseMessage* >* msgs, int range, bool doLock) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 31);
		method.addObjectParameter(msgs);
		method.addSignedIntParameter(range);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->broadcastMessages(msgs, range, doLock);
}

void SceneObject::sendTo(Player* player, bool doClose) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 32);
		method.addObjectParameter(player);
		method.addBooleanParameter(doClose);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->sendTo(player, doClose);
}

void SceneObject::sendDestroyTo(Player* player) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 33);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->sendDestroyTo(player);
}

void SceneObject::notifyInsert(QuadTreeEntry* obj) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 34);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->notifyInsert(obj);
}

void SceneObject::notifyDissapear(QuadTreeEntry* obj) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 35);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->notifyDissapear(obj);
}

void SceneObject::sendConversationStartTo(SceneObject* obj) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 36);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->sendConversationStartTo(obj);
}

void SceneObject::selectConversationOption(int option, SceneObject* obj) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 37);
		method.addSignedIntParameter(option);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->selectConversationOption(option, obj);
}

void SceneObject::sendConversationStopTo(SceneObject* obj) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 38);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->sendConversationStopTo(obj);
}

void SceneObject::sendRadialResponseTo(Player* player, ObjectMenuResponse* omr) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 39);
		method.addObjectParameter(player);
		method.addObjectParameter(omr);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->sendRadialResponseTo(player, omr);
}

int SceneObject::useObject(Player* player) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 40);
		method.addObjectParameter(player);

		return method.executeWithSignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->useObject(player);
}

void SceneObject::generateAttributes(SceneObject* obj) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 41);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->generateAttributes(obj);
}

void SceneObject::addAttributes(AttributeListMessage* alm) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 42);
		method.addObjectParameter(alm);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->addAttributes(alm);
}

void SceneObject::parseItemAttributes() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 43);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->parseItemAttributes();
}

void SceneObject::synchronizedUIListen(Player* player, int value) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 44);
		method.addObjectParameter(player);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->synchronizedUIListen(player, value);
}

void SceneObject::synchronizedUIStopListen(Player* player, int value) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 45);
		method.addObjectParameter(player);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->synchronizedUIStopListen(player, value);
}

void SceneObject::randomizePosition(float radius) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 46);
		method.addFloatParameter(radius);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->randomizePosition(radius);
}

void SceneObject::lock(bool doLock) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 47);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->lock(doLock);
}

void SceneObject::lock(ManagedObject* obj) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 48);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->lock(obj);
}

void SceneObject::wlock(bool doLock) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 49);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->wlock(doLock);
}

void SceneObject::wlock(ManagedObject* obj) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 50);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->wlock(obj);
}

void SceneObject::unlock(bool doLock) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 51);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->unlock(doLock);
}

void SceneObject::setLockName(const string& name) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 52);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setLockName(name);
}

void SceneObject::setMovementCounter(unsigned int cnt) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 53);
		method.addUnsignedIntParameter(cnt);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setMovementCounter(cnt);
}

void SceneObject::switchMovingState() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 54);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->switchMovingState();
}

unsigned int SceneObject::returnMovementCounter() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 55);

		return method.executeWithUnsignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->returnMovementCounter();
}

void SceneObject::increaseMovementCounter() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 56);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->increaseMovementCounter();
}

void SceneObject::setCustomizationString(const string& cust) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 57);
		method.addAsciiParameter(cust);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setCustomizationString(cust);
}

void SceneObject::setCustomizationVariable(byte type, unsigned short value) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 58);
		method.addByteParameter(type);
		method.addVoidParameter(value);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setCustomizationVariable(type, value);
}

void SceneObject::setCustomizationVariable(const string& type, byte value) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 59);
		method.addAsciiParameter(type);
		method.addByteParameter(value);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setCustomizationVariable(type, value);
}

void SceneObject::setNorthDirection() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 60);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setNorthDirection();
}

void SceneObject::setSouthDirection() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 61);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setSouthDirection();
}

void SceneObject::setWestDirection() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 62);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setWestDirection();
}

void SceneObject::setEastDirection() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 63);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setEastDirection();
}

void SceneObject::setDirection(float angle) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 64);
		method.addFloatParameter(angle);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setDirection(angle);
}

void SceneObject::setRadialDirection(float radangle) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 65);
		method.addFloatParameter(radangle);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setRadialDirection(radangle);
}

void SceneObject::setDirection(float x, float z, float y, float w) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 66);
		method.addFloatParameter(x);
		method.addFloatParameter(z);
		method.addFloatParameter(y);
		method.addFloatParameter(w);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setDirection(x, z, y, w);
}

void SceneObject::setPersistent(bool pers) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 67);
		method.addBooleanParameter(pers);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setPersistent(pers);
}

void SceneObject::setUpdated(bool upd) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 68);
		method.addBooleanParameter(upd);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setUpdated(upd);
}

void SceneObject::setDeleted(bool del) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 69);
		method.addBooleanParameter(del);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setDeleted(del);
}

Coordinate* SceneObject::getCoordinate(float x, float y, float distance, float angle) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 70);
		method.addFloatParameter(x);
		method.addFloatParameter(y);
		method.addFloatParameter(distance);
		method.addFloatParameter(angle);

		return (Coordinate*) method.executeWithObjectReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getCoordinate(x, y, distance, angle);
}

Coordinate* SceneObject::getCoordinate(SceneObject* object, float distance, float angle) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 71);
		method.addObjectParameter(object);
		method.addFloatParameter(distance);
		method.addFloatParameter(angle);

		return (Coordinate*) method.executeWithObjectReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getCoordinate(object, distance, angle);
}

Coordinate* SceneObject::getCoordinate(SceneObject* object1, SceneObject* object2, float distanceFromObject1) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 72);
		method.addObjectParameter(object1);
		method.addObjectParameter(object2);
		method.addFloatParameter(distanceFromObject1);

		return (Coordinate*) method.executeWithObjectReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getCoordinate(object1, object2, distanceFromObject1);
}

bool SceneObject::isInRange(SceneObject* obj, float range) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 73);
		method.addObjectParameter(obj);
		method.addFloatParameter(range);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isInRange(obj, range);
}

bool SceneObject::isInRange(float x, float y, float range) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 74);
		method.addFloatParameter(x);
		method.addFloatParameter(y);
		method.addFloatParameter(range);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isInRange(x, y, range);
}

ZoneProcessServerImplementation* SceneObject::getZoneProcessServer() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 75);

		return (ZoneProcessServerImplementation*) method.executeWithObjectReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getZoneProcessServer();
}

bool SceneObject::isPlayer() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 76);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isPlayer();
}

bool SceneObject::isNonPlayerCreature() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 77);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isNonPlayerCreature();
}

bool SceneObject::isPlayerInventory() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 78);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isPlayerInventory();
}

bool SceneObject::isPlayerBankStorage() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 79);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isPlayerBankStorage();
}

bool SceneObject::isBuilding() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 80);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isBuilding();
}

bool SceneObject::isCell() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 81);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isCell();
}

bool SceneObject::isTangible() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 82);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isTangible();
}

bool SceneObject::isIntangible() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 83);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isIntangible();
}

bool SceneObject::isStatic() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 84);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isStatic();
}

bool SceneObject::isShip() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 85);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isShip();
}

bool SceneObject::isAttackable() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 86);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isAttackable();
}

bool SceneObject::isMission() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 87);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isMission();
}

bool SceneObject::isPlayerObject() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 88);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isPlayerObject();
}

bool SceneObject::isWaypoint() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 89);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isWaypoint();
}

bool SceneObject::isManufactureSchematic() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 90);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isManufactureSchematic();
}

int SceneObject::compareTo(SceneObject* obj) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 91);
		method.addObjectParameter(obj);

		return method.executeWithSignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->compareTo(obj);
}

void SceneObject::setParent(SceneObject* par, unsigned int linktype) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 92);
		method.addObjectParameter(par);
		method.addUnsignedIntParameter(linktype);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setParent(par, linktype);
}

void SceneObject::setZoneProcessServer(ZoneProcessServerImplementation* server) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 93);
		method.addObjectParameter(server);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setZoneProcessServer(server);
}

void SceneObject::setZone(Zone* zone) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 94);
		method.addObjectParameter(zone);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setZone(zone);
}

void SceneObject::setZoneIndex(int id) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 95);
		method.addSignedIntParameter(id);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setZoneIndex(id);
}

void SceneObject::setObjectID(unsigned long long oid) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 96);
		method.addUnsignedLongParameter(oid);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setObjectID(oid);
}

void SceneObject::setObjectCRC(unsigned int crc) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 97);
		method.addUnsignedIntParameter(crc);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setObjectCRC(crc);
}

void SceneObject::setObjectType(int tp) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 98);
		method.addSignedIntParameter(tp);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setObjectType(tp);
}

void SceneObject::setObjectKeeping(bool keeping) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 99);
		method.addBooleanParameter(keeping);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setObjectKeeping(keeping);
}

void SceneObject::clearUndeploymentEvent() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 100);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->clearUndeploymentEvent();
}

bool SceneObject::isUndeploymentScheduled() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 101);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isUndeploymentScheduled();
}

void SceneObject::setAssociatedArea(unsigned long long uid) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 102);
		method.addUnsignedLongParameter(uid);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setAssociatedArea(uid);
}

Zone* SceneObject::getZone() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 103);

		return (Zone*) method.executeWithObjectReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getZone();
}

int SceneObject::getZoneID() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 104);

		return method.executeWithSignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getZoneID();
}

unsigned long long SceneObject::getObjectID() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 105);

		return method.executeWithUnsignedLongReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getObjectID();
}

unsigned int SceneObject::getObjectCRC() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 106);

		return method.executeWithUnsignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getObjectCRC();
}

int SceneObject::getObjectType() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 107);

		return method.executeWithSignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getObjectType();
}

unsigned int SceneObject::getMovementCounter() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 108);

		return method.executeWithUnsignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getMovementCounter();
}

bool SceneObject::isMoving() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 109);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isMoving();
}

float SceneObject::getPositionX() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 110);

		return method.executeWithFloatReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getPositionX();
}

float SceneObject::getPositionZ() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 111);

		return method.executeWithFloatReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getPositionZ();
}

float SceneObject::getPositionY() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 112);

		return method.executeWithFloatReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getPositionY();
}

float SceneObject::getDirectionX() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 113);

		return method.executeWithFloatReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getDirectionX();
}

float SceneObject::getDirectionZ() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 114);

		return method.executeWithFloatReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getDirectionZ();
}

float SceneObject::getDirectionY() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 115);

		return method.executeWithFloatReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getDirectionY();
}

float SceneObject::getDirectionW() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 116);

		return method.executeWithFloatReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getDirectionW();
}

byte SceneObject::getDirectionAngle() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 117);

		return method.executeWithByteReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getDirectionAngle();
}

float SceneObject::getPrecisionDirectionAngle() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 118);

		return method.executeWithFloatReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getPrecisionDirectionAngle();
}

SceneObject* SceneObject::getParent() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 119);

		return (SceneObject*) method.executeWithObjectReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getParent();
}

QuadTreeEntry* SceneObject::getQuadTreeEntry() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 120);

		return (QuadTreeEntry*) method.executeWithObjectReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getQuadTreeEntry();
}

unsigned long long SceneObject::getParentID() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 121);

		return method.executeWithUnsignedLongReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getParentID();
}

unicode& SceneObject::getCustomName() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 122);

		method.executeWithUnicodeReturn(_return_getCustomName);
		return _return_getCustomName;
	} else
		return ((SceneObjectImplementation*) _impl)->getCustomName();
}

void SceneObject::setCustomName(const string& name) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 123);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setCustomName(name);
}

void SceneObject::setCustomName(const unicode& name) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 124);
		method.addUnicodeParameter(name);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setCustomName(name);
}

void SceneObject::setStfName(const string& name) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 125);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setStfName(name);
}

string& SceneObject::getStfName() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 126);

		method.executeWithAsciiReturn(_return_getStfName);
		return _return_getStfName;
	} else
		return ((SceneObjectImplementation*) _impl)->getStfName();
}

void SceneObject::setStfFile(const string& file) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 127);
		method.addAsciiParameter(file);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setStfFile(file);
}

string& SceneObject::getStfFile() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 128);

		method.executeWithAsciiReturn(_return_getStfFile);
		return _return_getStfFile;
	} else
		return ((SceneObjectImplementation*) _impl)->getStfFile();
}

void SceneObject::setStfDetail(const string& detail) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 129);
		method.addAsciiParameter(detail);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setStfDetail(detail);
}

string& SceneObject::getStfDetail() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 130);

		method.executeWithAsciiReturn(_return_getStfDetail);
		return _return_getStfDetail;
	} else
		return ((SceneObjectImplementation*) _impl)->getStfDetail();
}

float SceneObject::getPrecision(float num, int digits) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 131);
		method.addFloatParameter(num);
		method.addSignedIntParameter(digits);

		return method.executeWithFloatReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getPrecision(num, digits);
}

void SceneObject::getCustomizationString(string& appearance) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 132);
		method.addAsciiParameter(appearance);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->getCustomizationString(appearance);
}

bool SceneObject::isPersistent() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 133);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isPersistent();
}

bool SceneObject::isUpdated() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 134);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isUpdated();
}

bool SceneObject::isDeleted() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 135);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isDeleted();
}

void SceneObject::setAttributes(string& attributeString) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 136);
		method.addAsciiParameter(attributeString);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setAttributes(attributeString);
}

string& SceneObject::getAttributes() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 137);

		method.executeWithAsciiReturn(_return_getAttributes);
		return _return_getAttributes;
	} else
		return ((SceneObjectImplementation*) _impl)->getAttributes();
}

unsigned long long SceneObject::getAssociatedArea() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 138);

		return method.executeWithUnsignedLongReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getAssociatedArea();
}

bool SceneObject::doKeepObject() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 139);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->doKeepObject();
}

void SceneObject::setDefender(SceneObject* defender) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 140);
		method.addObjectParameter(defender);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setDefender(defender);
}

void SceneObject::addDefender(SceneObject* defender) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 141);
		method.addObjectParameter(defender);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->addDefender(defender);
}

void SceneObject::removeDefender(SceneObject* defender) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 142);
		method.addObjectParameter(defender);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->removeDefender(defender);
}

void SceneObject::removeDefenders() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 143);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->removeDefenders();
}

bool SceneObject::hasDefender(SceneObject* defender) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 144);
		method.addObjectParameter(defender);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->hasDefender(defender);
}

void SceneObject::setCombatState() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 145);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setCombatState();
}

void SceneObject::clearCombatState(bool removeDefenders) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 146);
		method.addBooleanParameter(removeDefenders);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->clearCombatState(removeDefenders);
}

SceneObject* SceneObject::getDefender(int idx) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 147);
		method.addSignedIntParameter(idx);

		return (SceneObject*) method.executeWithObjectReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getDefender(idx);
}

bool SceneObject::isPeaced() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 148);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isPeaced();
}

unsigned int SceneObject::getDefenderListSize() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 149);

		return method.executeWithUnsignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getDefenderListSize();
}

bool SceneObject::isAttackableBy(CreatureObject* creature) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 150);
		method.addObjectParameter(creature);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isAttackableBy(creature);
}

bool SceneObject::isInANoBuildArea() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 151);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isInANoBuildArea();
}

void SceneObject::onIncapacitateTarget(CreatureObject* victim) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 152);
		method.addObjectParameter(victim);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->onIncapacitateTarget(victim);
}

void SceneObject::onInflictDamage(CreatureObject* victim, byte attribute, unsigned int damage) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 153);
		method.addObjectParameter(victim);
		method.addByteParameter(attribute);
		method.addUnsignedIntParameter(damage);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->onInflictDamage(victim, attribute, damage);
}

void SceneObject::onKill(CreatureObject* victim) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 154);
		method.addObjectParameter(victim);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->onKill(victim);
}

void SceneObject::onDeathblow(Player* victim) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 155);
		method.addObjectParameter(victim);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->onDeathblow(victim);
}

void SceneObject::onResuscitateTarget(CreatureObject* patient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 156);
		method.addObjectParameter(patient);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->onResuscitateTarget(patient);
}

void SceneObject::onHealTargetDamage(CreatureObject* patient, byte attribute, unsigned int amount) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 157);
		method.addObjectParameter(patient);
		method.addByteParameter(attribute);
		method.addUnsignedIntParameter(amount);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->onHealTargetDamage(patient, attribute, amount);
}

void SceneObject::onHealTargetWound(CreatureObject* patient, byte attribute, unsigned int amount) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 158);
		method.addObjectParameter(patient);
		method.addByteParameter(attribute);
		method.addUnsignedIntParameter(amount);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->onHealTargetWound(patient, attribute, amount);
}

void SceneObject::onHealEnhanceTarget(CreatureObject* patient, byte attribute, unsigned int amount, float duration) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 159);
		method.addObjectParameter(patient);
		method.addByteParameter(attribute);
		method.addUnsignedIntParameter(amount);
		method.addFloatParameter(duration);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->onHealEnhanceTarget(patient, attribute, amount, duration);
}

void SceneObject::onReceivePaymentFrom(CreatureObject* sender, unsigned int amount) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 160);
		method.addObjectParameter(sender);
		method.addUnsignedIntParameter(amount);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->onReceivePaymentFrom(sender, amount);
}

void SceneObject::onTrade(Player* sender, Player* receiver) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 161);
		method.addObjectParameter(sender);
		method.addObjectParameter(receiver);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->onTrade(sender, receiver);
}

bool SceneObject::inflictDamage(CreatureObject* victim, byte attribute, unsigned int damage) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 162);
		method.addObjectParameter(victim);
		method.addByteParameter(attribute);
		method.addUnsignedIntParameter(damage);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->inflictDamage(victim, attribute, damage);
}

void SceneObject::incapacitate(CreatureObject* victim) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 163);
		method.addObjectParameter(victim);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->incapacitate(victim);
}

void SceneObject::kill(CreatureObject* victim) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 164);
		method.addObjectParameter(victim);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->kill(victim);
}

void SceneObject::deathblow(Player* victim) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 165);
		method.addObjectParameter(victim);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->deathblow(victim);
}

void SceneObject::resuscitate(CreatureObject* patient, bool forced) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 166);
		method.addObjectParameter(patient);
		method.addBooleanParameter(forced);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->resuscitate(patient, forced);
}

unsigned int SceneObject::healDamage(CreatureObject* patient, byte attribute, unsigned int amount) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 167);
		method.addObjectParameter(patient);
		method.addByteParameter(attribute);
		method.addUnsignedIntParameter(amount);

		return method.executeWithUnsignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->healDamage(patient, attribute, amount);
}

unsigned int SceneObject::healWound(CreatureObject* patient, byte attribute, unsigned int amount) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 168);
		method.addObjectParameter(patient);
		method.addByteParameter(attribute);
		method.addUnsignedIntParameter(amount);

		return method.executeWithUnsignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->healWound(patient, attribute, amount);
}

unsigned int SceneObject::healEnhance(CreatureObject* patient, byte attribute, unsigned int amount, float duration) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 169);
		method.addObjectParameter(patient);
		method.addByteParameter(attribute);
		method.addUnsignedIntParameter(amount);
		method.addFloatParameter(duration);

		return method.executeWithUnsignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->healEnhance(patient, attribute, amount, duration);
}

void SceneObject::receivePaymentFrom(CreatureObject* sender, unsigned int amount) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 170);
		method.addObjectParameter(sender);
		method.addUnsignedIntParameter(amount);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->receivePaymentFrom(sender, amount);
}

void SceneObject::warpTo(float x, float z, float y, unsigned long long parentID) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 171);
		method.addFloatParameter(x);
		method.addFloatParameter(z);
		method.addFloatParameter(y);
		method.addUnsignedLongParameter(parentID);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->warpTo(x, z, y, parentID);
}

float SceneObject::calculateDistance(SceneObject* scno) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 172);
		method.addObjectParameter(scno);

		return method.executeWithFloatReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->calculateDistance(scno);
}

bool SceneObject::getPickupFlag() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 173);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getPickupFlag();
}

void SceneObject::setPickupFlag(bool pickup) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 174);
		method.addBooleanParameter(pickup);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setPickupFlag(pickup);
}

void SceneObject::addSerializableVariables() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 175);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->addSerializableVariables();
}

/*
 *	SceneObjectImplementation
 */

SceneObjectImplementation::~SceneObjectImplementation() {
}

void SceneObjectImplementation::_setStub(DistributedObjectStub* stub) {
	_this = (SceneObject*) stub;
	ManagedObjectImplementation::_setStub(stub);
}

DistributedObjectStub* SceneObjectImplementation::_getStub() {
	return _this;
}

void SceneObjectImplementation::sendTo(Player* player, bool doClose) {
}

void SceneObjectImplementation::sendDestroyTo(Player* player) {
}

void SceneObjectImplementation::notifyInsert(QuadTreeEntry* obj) {
}

void SceneObjectImplementation::notifyDissapear(QuadTreeEntry* obj) {
}

void SceneObjectImplementation::sendConversationStartTo(SceneObject* obj) {
}

void SceneObjectImplementation::selectConversationOption(int option, SceneObject* obj) {
}

void SceneObjectImplementation::sendConversationStopTo(SceneObject* obj) {
}

int SceneObjectImplementation::useObject(Player* player) {
	// server/zone/objects/scene/SceneObject.idl(302):  return 0;
	return 0;
}

void SceneObjectImplementation::setMovementCounter(unsigned int cnt) {
	// server/zone/objects/scene/SceneObject.idl(328):  movementCounter = cnt;
	movementCounter = cnt;
}

void SceneObjectImplementation::switchMovingState() {
	// server/zone/objects/scene/SceneObject.idl(332):  
	if (moving)	// server/zone/objects/scene/SceneObject.idl(333):  moving = false;
	moving = false;

	else 	// server/zone/objects/scene/SceneObject.idl(335):  moving = true;
	moving = true;
}

unsigned int SceneObjectImplementation::returnMovementCounter() {
	// server/zone/objects/scene/SceneObject.idl(339):  return movementCounter;
	return movementCounter;
}

void SceneObjectImplementation::increaseMovementCounter() {
	// server/zone/objects/scene/SceneObject.idl(343):  movementCounter++;
	movementCounter ++;
}

void SceneObjectImplementation::setCustomizationString(const string& cust) {
	// server/zone/objects/scene/SceneObject.idl(347):  customizationVariables = cust;
	customizationVariables = cust;
}

void SceneObjectImplementation::setCustomizationVariable(byte type, unsigned short value) {
	// server/zone/objects/scene/SceneObject.idl(351):  customizationVariables.setVariable(type, value);
	customizationVariables->setVariable(type, value);
}

void SceneObjectImplementation::setCustomizationVariable(const string& type, byte value) {
	// server/zone/objects/scene/SceneObject.idl(355):  customizationVariables.setVariable(type, value);
	customizationVariables->setVariable(type, value);
}

void SceneObjectImplementation::setNorthDirection() {
	// server/zone/objects/scene/SceneObject.idl(359):  directionX = 0;
	directionX = 0;
	// server/zone/objects/scene/SceneObject.idl(360):  directionZ = 0;
	directionZ = 0;
	// server/zone/objects/scene/SceneObject.idl(361):  directionY = 1;
	directionY = 1;
}

void SceneObjectImplementation::setSouthDirection() {
	// server/zone/objects/scene/SceneObject.idl(365):  directionX = 0;
	directionX = 0;
	// server/zone/objects/scene/SceneObject.idl(366):  directionZ = 0;
	directionZ = 0;
	// server/zone/objects/scene/SceneObject.idl(367):  directionY = -1;
	directionY = -1;
}

void SceneObjectImplementation::setWestDirection() {
	// server/zone/objects/scene/SceneObject.idl(371):  directionX = -1;
	directionX = -1;
	// server/zone/objects/scene/SceneObject.idl(372):  directionZ = 0;
	directionZ = 0;
	// server/zone/objects/scene/SceneObject.idl(373):  directionY = 0;
	directionY = 0;
}

void SceneObjectImplementation::setEastDirection() {
	// server/zone/objects/scene/SceneObject.idl(377):  directionX = 1;
	directionX = 1;
	// server/zone/objects/scene/SceneObject.idl(378):  directionZ = 0;
	directionZ = 0;
	// server/zone/objects/scene/SceneObject.idl(379):  directionY = 0;
	directionY = 0;
}

void SceneObjectImplementation::setDirection(float angle) {
	// server/zone/objects/scene/SceneObject.idl(384):  float angleInRadial = (angle / 180) * Math.PI;
	float angleInRadial = (angle / 180) * Math::PI;
	// server/zone/objects/scene/SceneObject.idl(386):  directionAngle = (byte) ((angleInRadial / 6.283f) * 100);
	directionAngle = (byte) ((angleInRadial / 6.283f) * 100);
	// server/zone/objects/scene/SceneObject.idl(388):  directionX = Math.sin(angleInRadial);
	directionX = Math::sin(angleInRadial);
	// server/zone/objects/scene/SceneObject.idl(389):  directionY = Math.cos(angleInRadial);
	directionY = Math::cos(angleInRadial);
	// server/zone/objects/scene/SceneObject.idl(390):  directionZ = 0;
	directionZ = 0;
}

void SceneObjectImplementation::setRadialDirection(float radangle) {
	// server/zone/objects/scene/SceneObject.idl(394):  directionAngle = (byte) ((radangle / 6.283f) * 100);
	directionAngle = (byte) ((radangle / 6.283f) * 100);
	// server/zone/objects/scene/SceneObject.idl(396):  directionX = Math.sin(radangle);
	directionX = Math::sin(radangle);
	// server/zone/objects/scene/SceneObject.idl(397):  directionY = Math.cos(radangle);
	directionY = Math::cos(radangle);
	// server/zone/objects/scene/SceneObject.idl(398):  directionZ = 0;
	directionZ = 0;
}

void SceneObjectImplementation::setDirection(float x, float z, float y, float w) {
	float angle;
	// server/zone/objects/scene/SceneObject.idl(405):  directionX = x;
	directionX = x;
	// server/zone/objects/scene/SceneObject.idl(406):  directionZ = z;
	directionZ = z;
	// server/zone/objects/scene/SceneObject.idl(407):  directionY = y;
	directionY = y;
	// server/zone/objects/scene/SceneObject.idl(408):  directionW = w;
	directionW = w;
	// server/zone/objects/scene/SceneObject.idl(410):  
	if (w * w + y * y > 0.0f){
	// server/zone/objects/scene/SceneObject.idl(411):  angle 
	if (w > 0.0f && y < 0.0f)	// server/zone/objects/scene/SceneObject.idl(412):  w *= -1.0f;
	w *= -1.0f;
	// server/zone/objects/scene/SceneObject.idl(414):  = 2.0f * Math.acos(w);
	angle = 2.0f * Math::acos(w);
}

	else 	// server/zone/objects/scene/SceneObject.idl(416):  angle = 0.0f;
	angle = 0.0f;
	// server/zone/objects/scene/SceneObject.idl(418):  precisionDirectionAngle = angle;
	precisionDirectionAngle = angle;
	// server/zone/objects/scene/SceneObject.idl(419):  directionAngle = (byte) ((angle / 6.283f) * 100);
	directionAngle = (byte) ((angle / 6.283f) * 100);
}

void SceneObjectImplementation::setPersistent(bool pers) {
	// server/zone/objects/scene/SceneObject.idl(424):  persistent = pers;
	persistent = pers;
}

void SceneObjectImplementation::setUpdated(bool upd) {
	// server/zone/objects/scene/SceneObject.idl(428):  updated = upd;
	updated = upd;
}

void SceneObjectImplementation::setDeleted(bool del) {
	// server/zone/objects/scene/SceneObject.idl(432):  deleted = del;
	deleted = del;
}

bool SceneObjectImplementation::isInRange(SceneObject* obj, float range) {
	// server/zone/objects/scene/SceneObject.idl(470):  return QuadTreeEntry.isInRange(obj.getPositionX(), obj.getPositionY(), range);
	return QuadTreeEntry::isInRange(obj->getPositionX(), obj->getPositionY(), range);
}

bool SceneObjectImplementation::isInRange(float x, float y, float range) {
	// server/zone/objects/scene/SceneObject.idl(474):  return QuadTreeEntry.isInRange(x, y, range);
	return QuadTreeEntry::isInRange(x, y, range);
}

ZoneProcessServerImplementation* SceneObjectImplementation::getZoneProcessServer() {
	// server/zone/objects/scene/SceneObject.idl(478):  return server;
	return server;
}

bool SceneObjectImplementation::isPlayer() {
	// server/zone/objects/scene/SceneObject.idl(482):  return objectType == PLAYER;
	return objectType == PLAYER;
}

bool SceneObjectImplementation::isNonPlayerCreature() {
	// server/zone/objects/scene/SceneObject.idl(486):  return objectType == NONPLAYERCREATURE;
	return objectType == NONPLAYERCREATURE;
}

bool SceneObjectImplementation::isPlayerInventory() {
	// server/zone/objects/scene/SceneObject.idl(490):  return objectType == INVENTORYOBJECT;
	return objectType == INVENTORYOBJECT;
}

bool SceneObjectImplementation::isPlayerBankStorage() {
	// server/zone/objects/scene/SceneObject.idl(494):  return objectType == BANKINVENTORYSTORAGE;
	return objectType == BANKINVENTORYSTORAGE;
}

bool SceneObjectImplementation::isBuilding() {
	// server/zone/objects/scene/SceneObject.idl(498):  return objectType == BUILDING;
	return objectType == BUILDING;
}

bool SceneObjectImplementation::isCell() {
	// server/zone/objects/scene/SceneObject.idl(502):  return objectType == CELL;
	return objectType == CELL;
}

bool SceneObjectImplementation::isTangible() {
	// server/zone/objects/scene/SceneObject.idl(506):  return objectType == TANGIBLE;
	return objectType == TANGIBLE;
}

bool SceneObjectImplementation::isIntangible() {
	// server/zone/objects/scene/SceneObject.idl(510):  return objectType == INTANGIBLE;
	return objectType == INTANGIBLE;
}

bool SceneObjectImplementation::isStatic() {
	// server/zone/objects/scene/SceneObject.idl(514):  return objectType == STATIC;
	return objectType == STATIC;
}

bool SceneObjectImplementation::isShip() {
	// server/zone/objects/scene/SceneObject.idl(518):  return objectType == SHIP;
	return objectType == SHIP;
}

bool SceneObjectImplementation::isAttackable() {
	// server/zone/objects/scene/SceneObject.idl(522):  return attackable;
	return attackable;
}

bool SceneObjectImplementation::isMission() {
	// server/zone/objects/scene/SceneObject.idl(526):  return objectType == MISSION;
	return objectType == MISSION;
}

bool SceneObjectImplementation::isPlayerObject() {
	// server/zone/objects/scene/SceneObject.idl(530):  return objectType == PLAYEROBJECT;
	return objectType == PLAYEROBJECT;
}

bool SceneObjectImplementation::isWaypoint() {
	// server/zone/objects/scene/SceneObject.idl(534):  return objectType == WAYPOINT;
	return objectType == WAYPOINT;
}

bool SceneObjectImplementation::isManufactureSchematic() {
	// server/zone/objects/scene/SceneObject.idl(538):  return objectType == MANUFACTURESCHEMATIC;
	return objectType == MANUFACTURESCHEMATIC;
}

int SceneObjectImplementation::compareTo(SceneObject* obj) {
	// server/zone/objects/scene/SceneObject.idl(542):  unsigned long id = obj.getObjectID();
	unsigned long long id = obj->getObjectID();
	// server/zone/objects/scene/SceneObject.idl(544):  
	if (objectID < id)	// server/zone/objects/scene/SceneObject.idl(545):  return 1;
	return 1;

	else 	// server/zone/objects/scene/SceneObject.idl(546):  
	if (objectID > id)	// server/zone/objects/scene/SceneObject.idl(547):  return -1;
	return -1;

	else 	// server/zone/objects/scene/SceneObject.idl(549):  return 0;
	return 0;
}

void SceneObjectImplementation::setParent(SceneObject* par, unsigned int linktype) {
	// server/zone/objects/scene/SceneObject.idl(554):  }
	if (par != this){
	// server/zone/objects/scene/SceneObject.idl(555):  parent = par;
	parent = par;
	// server/zone/objects/scene/SceneObject.idl(556):  linkType = linktype;
	linkType = linktype;
}
}

void SceneObjectImplementation::setZoneProcessServer(ZoneProcessServerImplementation* server) {
	// server/zone/objects/scene/SceneObject.idl(561):  this.server = server;
	this->server = server;
}

void SceneObjectImplementation::setZone(Zone* zone) {
	// server/zone/objects/scene/SceneObject.idl(565):  this.zone = zone;
	this->zone = zone;
}

void SceneObjectImplementation::setZoneIndex(int id) {
	// server/zone/objects/scene/SceneObject.idl(569):  zoneID = id;
	zoneID = id;
}

void SceneObjectImplementation::setObjectID(unsigned long long oid) {
	// server/zone/objects/scene/SceneObject.idl(573):  objectID = oid;
	objectID = oid;
}

void SceneObjectImplementation::setObjectCRC(unsigned int crc) {
	// server/zone/objects/scene/SceneObject.idl(577):  objectCRC = crc;
	objectCRC = crc;
}

void SceneObjectImplementation::setObjectType(int tp) {
	// server/zone/objects/scene/SceneObject.idl(581):  objectType = tp;
	objectType = tp;
}

void SceneObjectImplementation::setObjectKeeping(bool keeping) {
	// server/zone/objects/scene/SceneObject.idl(585):  keepObject = true;
	keepObject = true;
}

void SceneObjectImplementation::clearUndeploymentEvent() {
	// server/zone/objects/scene/SceneObject.idl(590):  undeployEvent = null;
	undeployEvent = NULL;
}

bool SceneObjectImplementation::isUndeploymentScheduled() {
	// server/zone/objects/scene/SceneObject.idl(594):  return undeployEvent != null;
	return undeployEvent != NULL;
}

void SceneObjectImplementation::setAssociatedArea(unsigned long long uid) {
	// server/zone/objects/scene/SceneObject.idl(598):  associatedArea = uid;
	associatedArea = uid;
}

Zone* SceneObjectImplementation::getZone() {
	// server/zone/objects/scene/SceneObject.idl(603):  return zone;
	return zone;
}

int SceneObjectImplementation::getZoneID() {
	// server/zone/objects/scene/SceneObject.idl(607):  return zoneID;
	return zoneID;
}

unsigned long long SceneObjectImplementation::getObjectID() {
	// server/zone/objects/scene/SceneObject.idl(611):  return QuadTreeEntry.getObjectID();
	return QuadTreeEntry::getObjectID();
}

unsigned int SceneObjectImplementation::getObjectCRC() {
	// server/zone/objects/scene/SceneObject.idl(615):  return objectCRC;
	return objectCRC;
}

int SceneObjectImplementation::getObjectType() {
	// server/zone/objects/scene/SceneObject.idl(619):  return objectType;
	return objectType;
}

unsigned int SceneObjectImplementation::getMovementCounter() {
	// server/zone/objects/scene/SceneObject.idl(623):  return movementCounter;
	return movementCounter;
}

bool SceneObjectImplementation::isMoving() {
	// server/zone/objects/scene/SceneObject.idl(627):  return moving;
	return moving;
}

float SceneObjectImplementation::getPositionX() {
	// server/zone/objects/scene/SceneObject.idl(631):  return QuadTreeEntry.getPositionX();
	return QuadTreeEntry::getPositionX();
}

float SceneObjectImplementation::getPositionZ() {
	// server/zone/objects/scene/SceneObject.idl(635):  return QuadTreeEntry.getPositionZ();
	return QuadTreeEntry::getPositionZ();
}

float SceneObjectImplementation::getPositionY() {
	// server/zone/objects/scene/SceneObject.idl(639):  return QuadTreeEntry.getPositionY();
	return QuadTreeEntry::getPositionY();
}

float SceneObjectImplementation::getDirectionX() {
	// server/zone/objects/scene/SceneObject.idl(643):  return directionX;
	return directionX;
}

float SceneObjectImplementation::getDirectionZ() {
	// server/zone/objects/scene/SceneObject.idl(647):  return directionZ;
	return directionZ;
}

float SceneObjectImplementation::getDirectionY() {
	// server/zone/objects/scene/SceneObject.idl(651):  return directionY;
	return directionY;
}

float SceneObjectImplementation::getDirectionW() {
	// server/zone/objects/scene/SceneObject.idl(655):  return directionW;
	return directionW;
}

byte SceneObjectImplementation::getDirectionAngle() {
	// server/zone/objects/scene/SceneObject.idl(659):  return directionAngle;
	return directionAngle;
}

float SceneObjectImplementation::getPrecisionDirectionAngle() {
	// server/zone/objects/scene/SceneObject.idl(663):  return precisionDirectionAngle;
	return precisionDirectionAngle;
}

SceneObject* SceneObjectImplementation::getParent() {
	// server/zone/objects/scene/SceneObject.idl(667):  return parent;
	return parent;
}

QuadTreeEntry* SceneObjectImplementation::getQuadTreeEntry() {
	// server/zone/objects/scene/SceneObject.idl(671):  return (QuadTreeEntry) this;
	return (QuadTreeEntry*) this;
}

unsigned long long SceneObjectImplementation::getParentID() {
	// server/zone/objects/scene/SceneObject.idl(675):  
	if (parent == NULL)	// server/zone/objects/scene/SceneObject.idl(676):  return 0;
	return 0;

	else 	// server/zone/objects/scene/SceneObject.idl(678):  return parent.getObjectID();
	return parent->getObjectID();
}

unicode& SceneObjectImplementation::getCustomName() {
	// server/zone/objects/scene/SceneObject.idl(682):  return customName;
	return customName;
}

void SceneObjectImplementation::setCustomName(const string& name) {
	// server/zone/objects/scene/SceneObject.idl(686):  customName = name;
	customName = name;
}

void SceneObjectImplementation::setCustomName(const unicode& name) {
	// server/zone/objects/scene/SceneObject.idl(690):  customName = name;
	customName = name;
}

void SceneObjectImplementation::setStfName(const string& name) {
	// server/zone/objects/scene/SceneObject.idl(694):  stfName = name;
	stfName = name;
}

string& SceneObjectImplementation::getStfName() {
	// server/zone/objects/scene/SceneObject.idl(698):  return stfName;
	return stfName;
}

void SceneObjectImplementation::setStfFile(const string& file) {
	// server/zone/objects/scene/SceneObject.idl(702):  stfFile = file;
	stfFile = file;
}

string& SceneObjectImplementation::getStfFile() {
	// server/zone/objects/scene/SceneObject.idl(706):  return stfFile;
	return stfFile;
}

void SceneObjectImplementation::setStfDetail(const string& detail) {
	// server/zone/objects/scene/SceneObject.idl(710):  stfDetail = detail;
	stfDetail = detail;
}

string& SceneObjectImplementation::getStfDetail() {
	// server/zone/objects/scene/SceneObject.idl(714):  return stfDetail;
	return stfDetail;
}

float SceneObjectImplementation::getPrecision(float num, int digits) {
	// server/zone/objects/scene/SceneObject.idl(718):  float power = Math.pow(10, digits);
	float power = Math::pow(10, digits);
	// server/zone/objects/scene/SceneObject.idl(720):  return (float) (Math.floor(num * power + 0.05f) / power);
	return (float) (Math::floor(num * power + 0.05f) / power);
}

void SceneObjectImplementation::getCustomizationString(string& appearance) {
	// server/zone/objects/scene/SceneObject.idl(724):  return customizationVariables.getData(appearance);
	return customizationVariables->getData(appearance);
}

bool SceneObjectImplementation::isPersistent() {
	// server/zone/objects/scene/SceneObject.idl(728):  return persistent;
	return persistent;
}

bool SceneObjectImplementation::isUpdated() {
	// server/zone/objects/scene/SceneObject.idl(732):  return updated;
	return updated;
}

bool SceneObjectImplementation::isDeleted() {
	// server/zone/objects/scene/SceneObject.idl(736):  return deleted;
	return deleted;
}

void SceneObjectImplementation::setAttributes(string& attributeString) {
	// server/zone/objects/scene/SceneObject.idl(740):  itemAttributes.setAttributes(attributeString);
	itemAttributes->setAttributes(attributeString);
}

string& SceneObjectImplementation::getAttributes() {
	// server/zone/objects/scene/SceneObject.idl(744):  itemAttributes.getAttributeString(attributeString);
	itemAttributes->getAttributeString(attributeString);
	// server/zone/objects/scene/SceneObject.idl(746):  return attributeString;
	return attributeString;
}

unsigned long long SceneObjectImplementation::getAssociatedArea() {
	// server/zone/objects/scene/SceneObject.idl(750):  return associatedArea;
	return associatedArea;
}

bool SceneObjectImplementation::doKeepObject() {
	// server/zone/objects/scene/SceneObject.idl(754):  return keepObject;
	return keepObject;
}

void SceneObjectImplementation::setDefender(SceneObject* defender) {
}

void SceneObjectImplementation::addDefender(SceneObject* defender) {
}

void SceneObjectImplementation::removeDefender(SceneObject* defender) {
}

void SceneObjectImplementation::removeDefenders() {
}

bool SceneObjectImplementation::hasDefender(SceneObject* defender) {
	// server/zone/objects/scene/SceneObject.idl(771):  return false;
	return false;
}

void SceneObjectImplementation::setCombatState() {
}

void SceneObjectImplementation::clearCombatState(bool removeDefenders) {
}

SceneObject* SceneObjectImplementation::getDefender(int idx) {
	// server/zone/objects/scene/SceneObject.idl(781):  return null;
	return NULL;
}

bool SceneObjectImplementation::isPeaced() {
	// server/zone/objects/scene/SceneObject.idl(785):  return true;
	return true;
}

unsigned int SceneObjectImplementation::getDefenderListSize() {
	// server/zone/objects/scene/SceneObject.idl(789):  return 0;
	return 0;
}

bool SceneObjectImplementation::isAttackableBy(CreatureObject* creature) {
	// server/zone/objects/scene/SceneObject.idl(793):  return false;
	return false;
}

bool SceneObjectImplementation::isInANoBuildArea() {
	// server/zone/objects/scene/SceneObject.idl(797):  PlanetManager planetManager = this.getZone().getPlanetManager();
	PlanetManager* planetManager = this->getZone()->getPlanetManager();
	// server/zone/objects/scene/SceneObject.idl(799):  return planetManager.isNoBuildArea(positionX, positionY);
	return planetManager->isNoBuildArea(positionX, positionY);
}

bool SceneObjectImplementation::getPickupFlag() {
	// server/zone/objects/scene/SceneObject.idl(829):  return canPickup;
	return canPickup;
}

void SceneObjectImplementation::setPickupFlag(bool pickup) {
	// server/zone/objects/scene/SceneObject.idl(833):  canPickup = pickup;
	canPickup = pickup;
}

/*
 *	SceneObjectAdapter
 */

SceneObjectAdapter::SceneObjectAdapter(SceneObjectImplementation* obj) : ManagedObjectAdapter(obj) {
}

Packet* SceneObjectAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	Packet* resp = new MethodReturnMessage(0);

	switch (methid) {
	case 6:
		finalize();
		break;
	case 7:
		resp->insertBoolean(destroy());
		break;
	case 8:
		redeploy();
		break;
	case 9:
		scheduleUndeploy();
		break;
	case 10:
		undeploy();
		break;
	case 11:
		removeUndeploymentEvent();
		break;
	case 12:
		create((ZoneClientSession*) inv->getObjectParameter());
		break;
	case 13:
		destroy((ZoneClientSession*) inv->getObjectParameter());
		break;
	case 14:
		link((ZoneClientSession*) inv->getObjectParameter(), (SceneObject*) inv->getObjectParameter());
		break;
	case 15:
		resp->insertLong(link((SceneObject*) inv->getObjectParameter(), inv->getUnsignedIntParameter())->_getObjectID());
		break;
	case 16:
		resp->insertLong(link((SceneObject*) inv->getObjectParameter())->_getObjectID());
		break;
	case 17:
		resp->insertLong(link(inv->getUnsignedLongParameter(), inv->getUnsignedIntParameter())->_getObjectID());
		break;
	case 18:
		close((ZoneClientSession*) inv->getObjectParameter());
		break;
	case 19:
		init();
		break;
	case 20:
		initScriptedValues();
		break;
	case 21:
		insertToZone((Zone*) inv->getObjectParameter());
		break;
	case 22:
		insertToBuilding((BuildingObject*) inv->getObjectParameter());
		break;
	case 23:
		removeFromZone(inv->getBooleanParameter());
		break;
	case 24:
		removeFromBuilding((BuildingObject*) inv->getObjectParameter());
		break;
	case 25:
		addDamageDone((CreatureObject*) inv->getObjectParameter(), inv->getSignedIntParameter(), inv->getAsciiParameter(_param2_addDamageDone__CreatureObject_int_string_));
		break;
	case 26:
		dropDamageDone((CreatureObject*) inv->getObjectParameter());
		break;
	case 27:
		resp->insertSignedInt(getTotalDamage());
		break;
	case 28:
		disseminateXp(inv->getSignedIntParameter());
		break;
	case 29:
		cleanupDamageDone();
		break;
	case 30:
		broadcastMessage((BaseMessage*) inv->getObjectParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter(), inv->getBooleanParameter());
		break;
	case 31:
		broadcastMessage((StandaloneBaseMessage*) inv->getObjectParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case 32:
		broadcastMessages((Vector*) inv->getObjectParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case 33:
		sendTo((Player*) inv->getObjectParameter(), inv->getBooleanParameter());
		break;
	case 34:
		sendDestroyTo((Player*) inv->getObjectParameter());
		break;
	case 35:
		notifyInsert((QuadTreeEntry*) inv->getObjectParameter());
		break;
	case 36:
		notifyDissapear((QuadTreeEntry*) inv->getObjectParameter());
		break;
	case 37:
		sendConversationStartTo((SceneObject*) inv->getObjectParameter());
		break;
	case 38:
		selectConversationOption(inv->getSignedIntParameter(), (SceneObject*) inv->getObjectParameter());
		break;
	case 39:
		sendConversationStopTo((SceneObject*) inv->getObjectParameter());
		break;
	case 40:
		sendRadialResponseTo((Player*) inv->getObjectParameter(), (ObjectMenuResponse*) inv->getObjectParameter());
		break;
	case 41:
		resp->insertSignedInt(useObject((Player*) inv->getObjectParameter()));
		break;
	case 42:
		generateAttributes((SceneObject*) inv->getObjectParameter());
		break;
	case 43:
		addAttributes((AttributeListMessage*) inv->getObjectParameter());
		break;
	case 44:
		parseItemAttributes();
		break;
	case 45:
		synchronizedUIListen((Player*) inv->getObjectParameter(), inv->getSignedIntParameter());
		break;
	case 46:
		synchronizedUIStopListen((Player*) inv->getObjectParameter(), inv->getSignedIntParameter());
		break;
	case 47:
		randomizePosition(inv->getFloatParameter());
		break;
	case 48:
		lock(inv->getBooleanParameter());
		break;
	case 49:
		lock((ManagedObject*) inv->getObjectParameter());
		break;
	case 50:
		wlock(inv->getBooleanParameter());
		break;
	case 51:
		wlock((ManagedObject*) inv->getObjectParameter());
		break;
	case 52:
		unlock(inv->getBooleanParameter());
		break;
	case 53:
		setLockName(inv->getAsciiParameter(_param0_setLockName__string_));
		break;
	case 54:
		setMovementCounter(inv->getUnsignedIntParameter());
		break;
	case 55:
		switchMovingState();
		break;
	case 56:
		resp->insertInt(returnMovementCounter());
		break;
	case 57:
		increaseMovementCounter();
		break;
	case 58:
		setCustomizationString(inv->getAsciiParameter(_param0_setCustomizationString__string_));
		break;
	case 59:
		setCustomizationVariable(inv->getByteParameter(), inv->getVoidParameter());
		break;
	case 60:
		setCustomizationVariable(inv->getAsciiParameter(_param0_setCustomizationVariable__string_byte_), inv->getByteParameter());
		break;
	case 61:
		setNorthDirection();
		break;
	case 62:
		setSouthDirection();
		break;
	case 63:
		setWestDirection();
		break;
	case 64:
		setEastDirection();
		break;
	case 65:
		setDirection(inv->getFloatParameter());
		break;
	case 66:
		setRadialDirection(inv->getFloatParameter());
		break;
	case 67:
		setDirection(inv->getFloatParameter(), inv->getFloatParameter(), inv->getFloatParameter(), inv->getFloatParameter());
		break;
	case 68:
		setPersistent(inv->getBooleanParameter());
		break;
	case 69:
		setUpdated(inv->getBooleanParameter());
		break;
	case 70:
		setDeleted(inv->getBooleanParameter());
		break;
	case 71:
		resp->insertLong(getCoordinate(inv->getFloatParameter(), inv->getFloatParameter(), inv->getFloatParameter(), inv->getFloatParameter())->_getObjectID());
		break;
	case 72:
		resp->insertLong(getCoordinate((SceneObject*) inv->getObjectParameter(), inv->getFloatParameter(), inv->getFloatParameter())->_getObjectID());
		break;
	case 73:
		resp->insertLong(getCoordinate((SceneObject*) inv->getObjectParameter(), (SceneObject*) inv->getObjectParameter(), inv->getFloatParameter())->_getObjectID());
		break;
	case 74:
		resp->insertBoolean(isInRange((SceneObject*) inv->getObjectParameter(), inv->getFloatParameter()));
		break;
	case 75:
		resp->insertBoolean(isInRange(inv->getFloatParameter(), inv->getFloatParameter(), inv->getFloatParameter()));
		break;
	case 76:
		resp->insertLong(getZoneProcessServer()->_getObjectID());
		break;
	case 77:
		resp->insertBoolean(isPlayer());
		break;
	case 78:
		resp->insertBoolean(isNonPlayerCreature());
		break;
	case 79:
		resp->insertBoolean(isPlayerInventory());
		break;
	case 80:
		resp->insertBoolean(isPlayerBankStorage());
		break;
	case 81:
		resp->insertBoolean(isBuilding());
		break;
	case 82:
		resp->insertBoolean(isCell());
		break;
	case 83:
		resp->insertBoolean(isTangible());
		break;
	case 84:
		resp->insertBoolean(isIntangible());
		break;
	case 85:
		resp->insertBoolean(isStatic());
		break;
	case 86:
		resp->insertBoolean(isShip());
		break;
	case 87:
		resp->insertBoolean(isAttackable());
		break;
	case 88:
		resp->insertBoolean(isMission());
		break;
	case 89:
		resp->insertBoolean(isPlayerObject());
		break;
	case 90:
		resp->insertBoolean(isWaypoint());
		break;
	case 91:
		resp->insertBoolean(isManufactureSchematic());
		break;
	case 92:
		resp->insertSignedInt(compareTo((SceneObject*) inv->getObjectParameter()));
		break;
	case 93:
		setParent((SceneObject*) inv->getObjectParameter(), inv->getUnsignedIntParameter());
		break;
	case 94:
		setZoneProcessServer((ZoneProcessServerImplementation*) inv->getObjectParameter());
		break;
	case 95:
		setZone((Zone*) inv->getObjectParameter());
		break;
	case 96:
		setZoneIndex(inv->getSignedIntParameter());
		break;
	case 97:
		setObjectID(inv->getUnsignedLongParameter());
		break;
	case 98:
		setObjectCRC(inv->getUnsignedIntParameter());
		break;
	case 99:
		setObjectType(inv->getSignedIntParameter());
		break;
	case 100:
		setObjectKeeping(inv->getBooleanParameter());
		break;
	case 101:
		clearUndeploymentEvent();
		break;
	case 102:
		resp->insertBoolean(isUndeploymentScheduled());
		break;
	case 103:
		setAssociatedArea(inv->getUnsignedLongParameter());
		break;
	case 104:
		resp->insertLong(getZone()->_getObjectID());
		break;
	case 105:
		resp->insertSignedInt(getZoneID());
		break;
	case 106:
		resp->insertLong(getObjectID());
		break;
	case 107:
		resp->insertInt(getObjectCRC());
		break;
	case 108:
		resp->insertSignedInt(getObjectType());
		break;
	case 109:
		resp->insertInt(getMovementCounter());
		break;
	case 110:
		resp->insertBoolean(isMoving());
		break;
	case 111:
		resp->insertFloat(getPositionX());
		break;
	case 112:
		resp->insertFloat(getPositionZ());
		break;
	case 113:
		resp->insertFloat(getPositionY());
		break;
	case 114:
		resp->insertFloat(getDirectionX());
		break;
	case 115:
		resp->insertFloat(getDirectionZ());
		break;
	case 116:
		resp->insertFloat(getDirectionY());
		break;
	case 117:
		resp->insertFloat(getDirectionW());
		break;
	case 118:
		resp->insertByte(getDirectionAngle());
		break;
	case 119:
		resp->insertFloat(getPrecisionDirectionAngle());
		break;
	case 120:
		resp->insertLong(getParent()->_getObjectID());
		break;
	case 121:
		resp->insertLong(getQuadTreeEntry()->_getObjectID());
		break;
	case 122:
		resp->insertLong(getParentID());
		break;
	case 123:
		resp->insertUnicode(getCustomName());
		break;
	case 124:
		setCustomName(inv->getAsciiParameter(_param0_setCustomName__string_));
		break;
	case 125:
		setCustomName(inv->getUnicodeParameter(_param0_setCustomName__unicode_));
		break;
	case 126:
		setStfName(inv->getAsciiParameter(_param0_setStfName__string_));
		break;
	case 127:
		resp->insertAscii(getStfName());
		break;
	case 128:
		setStfFile(inv->getAsciiParameter(_param0_setStfFile__string_));
		break;
	case 129:
		resp->insertAscii(getStfFile());
		break;
	case 130:
		setStfDetail(inv->getAsciiParameter(_param0_setStfDetail__string_));
		break;
	case 131:
		resp->insertAscii(getStfDetail());
		break;
	case 132:
		resp->insertFloat(getPrecision(inv->getFloatParameter(), inv->getSignedIntParameter()));
		break;
	case 133:
		getCustomizationString(inv->getAsciiParameter(_param0_getCustomizationString__string_));
		break;
	case 134:
		resp->insertBoolean(isPersistent());
		break;
	case 135:
		resp->insertBoolean(isUpdated());
		break;
	case 136:
		resp->insertBoolean(isDeleted());
		break;
	case 137:
		setAttributes(inv->getAsciiParameter(_param0_setAttributes__string_));
		break;
	case 138:
		resp->insertAscii(getAttributes());
		break;
	case 139:
		resp->insertLong(getAssociatedArea());
		break;
	case 140:
		resp->insertBoolean(doKeepObject());
		break;
	case 141:
		setDefender((SceneObject*) inv->getObjectParameter());
		break;
	case 142:
		addDefender((SceneObject*) inv->getObjectParameter());
		break;
	case 143:
		removeDefender((SceneObject*) inv->getObjectParameter());
		break;
	case 144:
		removeDefenders();
		break;
	case 145:
		resp->insertBoolean(hasDefender((SceneObject*) inv->getObjectParameter()));
		break;
	case 146:
		setCombatState();
		break;
	case 147:
		clearCombatState(inv->getBooleanParameter());
		break;
	case 148:
		resp->insertLong(getDefender(inv->getSignedIntParameter())->_getObjectID());
		break;
	case 149:
		resp->insertBoolean(isPeaced());
		break;
	case 150:
		resp->insertInt(getDefenderListSize());
		break;
	case 151:
		resp->insertBoolean(isAttackableBy((CreatureObject*) inv->getObjectParameter()));
		break;
	case 152:
		resp->insertBoolean(isInANoBuildArea());
		break;
	case 153:
		onIncapacitateTarget((CreatureObject*) inv->getObjectParameter());
		break;
	case 154:
		onInflictDamage((CreatureObject*) inv->getObjectParameter(), inv->getByteParameter(), inv->getUnsignedIntParameter());
		break;
	case 155:
		onKill((CreatureObject*) inv->getObjectParameter());
		break;
	case 156:
		onDeathblow((Player*) inv->getObjectParameter());
		break;
	case 157:
		onResuscitateTarget((CreatureObject*) inv->getObjectParameter());
		break;
	case 158:
		onHealTargetDamage((CreatureObject*) inv->getObjectParameter(), inv->getByteParameter(), inv->getUnsignedIntParameter());
		break;
	case 159:
		onHealTargetWound((CreatureObject*) inv->getObjectParameter(), inv->getByteParameter(), inv->getUnsignedIntParameter());
		break;
	case 160:
		onHealEnhanceTarget((CreatureObject*) inv->getObjectParameter(), inv->getByteParameter(), inv->getUnsignedIntParameter(), inv->getFloatParameter());
		break;
	case 161:
		onReceivePaymentFrom((CreatureObject*) inv->getObjectParameter(), inv->getUnsignedIntParameter());
		break;
	case 162:
		onTrade((Player*) inv->getObjectParameter(), (Player*) inv->getObjectParameter());
		break;
	case 163:
		resp->insertBoolean(inflictDamage((CreatureObject*) inv->getObjectParameter(), inv->getByteParameter(), inv->getUnsignedIntParameter()));
		break;
	case 164:
		incapacitate((CreatureObject*) inv->getObjectParameter());
		break;
	case 165:
		kill((CreatureObject*) inv->getObjectParameter());
		break;
	case 166:
		deathblow((Player*) inv->getObjectParameter());
		break;
	case 167:
		resuscitate((CreatureObject*) inv->getObjectParameter(), inv->getBooleanParameter());
		break;
	case 168:
		resp->insertInt(healDamage((CreatureObject*) inv->getObjectParameter(), inv->getByteParameter(), inv->getUnsignedIntParameter()));
		break;
	case 169:
		resp->insertInt(healWound((CreatureObject*) inv->getObjectParameter(), inv->getByteParameter(), inv->getUnsignedIntParameter()));
		break;
	case 170:
		resp->insertInt(healEnhance((CreatureObject*) inv->getObjectParameter(), inv->getByteParameter(), inv->getUnsignedIntParameter(), inv->getFloatParameter()));
		break;
	case 171:
		receivePaymentFrom((CreatureObject*) inv->getObjectParameter(), inv->getUnsignedIntParameter());
		break;
	case 172:
		warpTo(inv->getFloatParameter(), inv->getFloatParameter(), inv->getFloatParameter(), inv->getUnsignedLongParameter());
		break;
	case 173:
		resp->insertFloat(calculateDistance((SceneObject*) inv->getObjectParameter()));
		break;
	case 174:
		resp->insertBoolean(getPickupFlag());
		break;
	case 175:
		setPickupFlag(inv->getBooleanParameter());
		break;
	case 176:
		addSerializableVariables();
		break;
	default:
		return NULL;
	}

	return resp;
}

void SceneObjectAdapter::finalize() {
	return ((SceneObjectImplementation*) impl)->finalize();
}

bool SceneObjectAdapter::destroy() {
	return ((SceneObjectImplementation*) impl)->destroy();
}

void SceneObjectAdapter::redeploy() {
	return ((SceneObjectImplementation*) impl)->redeploy();
}

void SceneObjectAdapter::scheduleUndeploy() {
	return ((SceneObjectImplementation*) impl)->scheduleUndeploy();
}

void SceneObjectAdapter::undeploy() {
	return ((SceneObjectImplementation*) impl)->undeploy();
}

void SceneObjectAdapter::removeUndeploymentEvent() {
	return ((SceneObjectImplementation*) impl)->removeUndeploymentEvent();
}

void SceneObjectAdapter::create(ZoneClientSession* client) {
	return ((SceneObjectImplementation*) impl)->create(client);
}

void SceneObjectAdapter::destroy(ZoneClientSession* client) {
	return ((SceneObjectImplementation*) impl)->destroy(client);
}

void SceneObjectAdapter::link(ZoneClientSession* client, SceneObject* obj) {
	return ((SceneObjectImplementation*) impl)->link(client, obj);
}

BaseMessage* SceneObjectAdapter::link(SceneObject* obj, unsigned int type) {
	return ((SceneObjectImplementation*) impl)->link(obj, type);
}

BaseMessage* SceneObjectAdapter::link(SceneObject* obj) {
	return ((SceneObjectImplementation*) impl)->link(obj);
}

BaseMessage* SceneObjectAdapter::link(unsigned long long container, unsigned int type) {
	return ((SceneObjectImplementation*) impl)->link(container, type);
}

void SceneObjectAdapter::close(ZoneClientSession* client) {
	return ((SceneObjectImplementation*) impl)->close(client);
}

void SceneObjectAdapter::init() {
	return ((SceneObjectImplementation*) impl)->init();
}

void SceneObjectAdapter::initScriptedValues() {
	return ((SceneObjectImplementation*) impl)->initScriptedValues();
}

void SceneObjectAdapter::insertToZone(Zone* zone) {
	return ((SceneObjectImplementation*) impl)->insertToZone(zone);
}

void SceneObjectAdapter::insertToBuilding(BuildingObject* building) {
	return ((SceneObjectImplementation*) impl)->insertToBuilding(building);
}

void SceneObjectAdapter::removeFromZone(bool doLock) {
	return ((SceneObjectImplementation*) impl)->removeFromZone(doLock);
}

void SceneObjectAdapter::removeFromBuilding(BuildingObject* building) {
	return ((SceneObjectImplementation*) impl)->removeFromBuilding(building);
}

void SceneObjectAdapter::addDamageDone(CreatureObject* creature, int damage, string& skillname) {
	return ((SceneObjectImplementation*) impl)->addDamageDone(creature, damage, skillname);
}

void SceneObjectAdapter::dropDamageDone(CreatureObject* creature) {
	return ((SceneObjectImplementation*) impl)->dropDamageDone(creature);
}

int SceneObjectAdapter::getTotalDamage() {
	return ((SceneObjectImplementation*) impl)->getTotalDamage();
}

void SceneObjectAdapter::disseminateXp(int levels) {
	return ((SceneObjectImplementation*) impl)->disseminateXp(levels);
}

void SceneObjectAdapter::cleanupDamageDone() {
	return ((SceneObjectImplementation*) impl)->cleanupDamageDone();
}

void SceneObjectAdapter::broadcastMessage(BaseMessage* msg, int range, bool doLock, bool sendSelf) {
	return ((SceneObjectImplementation*) impl)->broadcastMessage(msg, range, doLock, sendSelf);
}

void SceneObjectAdapter::broadcastMessage(StandaloneBaseMessage* msg, int range, bool doLock) {
	return ((SceneObjectImplementation*) impl)->broadcastMessage(msg, range, doLock);
}

void SceneObjectAdapter::broadcastMessages(Vector<BaseMessage* >* msgs, int range, bool doLock) {
	return ((SceneObjectImplementation*) impl)->broadcastMessages(msgs, range, doLock);
}

void SceneObjectAdapter::sendTo(Player* player, bool doClose) {
	return ((SceneObjectImplementation*) impl)->sendTo(player, doClose);
}

void SceneObjectAdapter::sendDestroyTo(Player* player) {
	return ((SceneObjectImplementation*) impl)->sendDestroyTo(player);
}

void SceneObjectAdapter::notifyInsert(QuadTreeEntry* obj) {
	return ((SceneObjectImplementation*) impl)->notifyInsert(obj);
}

void SceneObjectAdapter::notifyDissapear(QuadTreeEntry* obj) {
	return ((SceneObjectImplementation*) impl)->notifyDissapear(obj);
}

void SceneObjectAdapter::sendConversationStartTo(SceneObject* obj) {
	return ((SceneObjectImplementation*) impl)->sendConversationStartTo(obj);
}

void SceneObjectAdapter::selectConversationOption(int option, SceneObject* obj) {
	return ((SceneObjectImplementation*) impl)->selectConversationOption(option, obj);
}

void SceneObjectAdapter::sendConversationStopTo(SceneObject* obj) {
	return ((SceneObjectImplementation*) impl)->sendConversationStopTo(obj);
}

void SceneObjectAdapter::sendRadialResponseTo(Player* player, ObjectMenuResponse* omr) {
	return ((SceneObjectImplementation*) impl)->sendRadialResponseTo(player, omr);
}

int SceneObjectAdapter::useObject(Player* player) {
	return ((SceneObjectImplementation*) impl)->useObject(player);
}

void SceneObjectAdapter::generateAttributes(SceneObject* obj) {
	return ((SceneObjectImplementation*) impl)->generateAttributes(obj);
}

void SceneObjectAdapter::addAttributes(AttributeListMessage* alm) {
	return ((SceneObjectImplementation*) impl)->addAttributes(alm);
}

void SceneObjectAdapter::parseItemAttributes() {
	return ((SceneObjectImplementation*) impl)->parseItemAttributes();
}

void SceneObjectAdapter::synchronizedUIListen(Player* player, int value) {
	return ((SceneObjectImplementation*) impl)->synchronizedUIListen(player, value);
}

void SceneObjectAdapter::synchronizedUIStopListen(Player* player, int value) {
	return ((SceneObjectImplementation*) impl)->synchronizedUIStopListen(player, value);
}

void SceneObjectAdapter::randomizePosition(float radius) {
	return ((SceneObjectImplementation*) impl)->randomizePosition(radius);
}

void SceneObjectAdapter::lock(bool doLock) {
	return ((SceneObjectImplementation*) impl)->lock(doLock);
}

void SceneObjectAdapter::lock(ManagedObject* obj) {
	return ((SceneObjectImplementation*) impl)->lock(obj);
}

void SceneObjectAdapter::wlock(bool doLock) {
	return ((SceneObjectImplementation*) impl)->wlock(doLock);
}

void SceneObjectAdapter::wlock(ManagedObject* obj) {
	return ((SceneObjectImplementation*) impl)->wlock(obj);
}

void SceneObjectAdapter::unlock(bool doLock) {
	return ((SceneObjectImplementation*) impl)->unlock(doLock);
}

void SceneObjectAdapter::setLockName(const string& name) {
	return ((SceneObjectImplementation*) impl)->setLockName(name);
}

void SceneObjectAdapter::setMovementCounter(unsigned int cnt) {
	return ((SceneObjectImplementation*) impl)->setMovementCounter(cnt);
}

void SceneObjectAdapter::switchMovingState() {
	return ((SceneObjectImplementation*) impl)->switchMovingState();
}

unsigned int SceneObjectAdapter::returnMovementCounter() {
	return ((SceneObjectImplementation*) impl)->returnMovementCounter();
}

void SceneObjectAdapter::increaseMovementCounter() {
	return ((SceneObjectImplementation*) impl)->increaseMovementCounter();
}

void SceneObjectAdapter::setCustomizationString(const string& cust) {
	return ((SceneObjectImplementation*) impl)->setCustomizationString(cust);
}

void SceneObjectAdapter::setCustomizationVariable(byte type, unsigned short value) {
	return ((SceneObjectImplementation*) impl)->setCustomizationVariable(type, value);
}

void SceneObjectAdapter::setCustomizationVariable(const string& type, byte value) {
	return ((SceneObjectImplementation*) impl)->setCustomizationVariable(type, value);
}

void SceneObjectAdapter::setNorthDirection() {
	return ((SceneObjectImplementation*) impl)->setNorthDirection();
}

void SceneObjectAdapter::setSouthDirection() {
	return ((SceneObjectImplementation*) impl)->setSouthDirection();
}

void SceneObjectAdapter::setWestDirection() {
	return ((SceneObjectImplementation*) impl)->setWestDirection();
}

void SceneObjectAdapter::setEastDirection() {
	return ((SceneObjectImplementation*) impl)->setEastDirection();
}

void SceneObjectAdapter::setDirection(float angle) {
	return ((SceneObjectImplementation*) impl)->setDirection(angle);
}

void SceneObjectAdapter::setRadialDirection(float radangle) {
	return ((SceneObjectImplementation*) impl)->setRadialDirection(radangle);
}

void SceneObjectAdapter::setDirection(float x, float z, float y, float w) {
	return ((SceneObjectImplementation*) impl)->setDirection(x, z, y, w);
}

void SceneObjectAdapter::setPersistent(bool pers) {
	return ((SceneObjectImplementation*) impl)->setPersistent(pers);
}

void SceneObjectAdapter::setUpdated(bool upd) {
	return ((SceneObjectImplementation*) impl)->setUpdated(upd);
}

void SceneObjectAdapter::setDeleted(bool del) {
	return ((SceneObjectImplementation*) impl)->setDeleted(del);
}

Coordinate* SceneObjectAdapter::getCoordinate(float x, float y, float distance, float angle) {
	return ((SceneObjectImplementation*) impl)->getCoordinate(x, y, distance, angle);
}

Coordinate* SceneObjectAdapter::getCoordinate(SceneObject* object, float distance, float angle) {
	return ((SceneObjectImplementation*) impl)->getCoordinate(object, distance, angle);
}

Coordinate* SceneObjectAdapter::getCoordinate(SceneObject* object1, SceneObject* object2, float distanceFromObject1) {
	return ((SceneObjectImplementation*) impl)->getCoordinate(object1, object2, distanceFromObject1);
}

bool SceneObjectAdapter::isInRange(SceneObject* obj, float range) {
	return ((SceneObjectImplementation*) impl)->isInRange(obj, range);
}

bool SceneObjectAdapter::isInRange(float x, float y, float range) {
	return ((SceneObjectImplementation*) impl)->isInRange(x, y, range);
}

ZoneProcessServerImplementation* SceneObjectAdapter::getZoneProcessServer() {
	return ((SceneObjectImplementation*) impl)->getZoneProcessServer();
}

bool SceneObjectAdapter::isPlayer() {
	return ((SceneObjectImplementation*) impl)->isPlayer();
}

bool SceneObjectAdapter::isNonPlayerCreature() {
	return ((SceneObjectImplementation*) impl)->isNonPlayerCreature();
}

bool SceneObjectAdapter::isPlayerInventory() {
	return ((SceneObjectImplementation*) impl)->isPlayerInventory();
}

bool SceneObjectAdapter::isPlayerBankStorage() {
	return ((SceneObjectImplementation*) impl)->isPlayerBankStorage();
}

bool SceneObjectAdapter::isBuilding() {
	return ((SceneObjectImplementation*) impl)->isBuilding();
}

bool SceneObjectAdapter::isCell() {
	return ((SceneObjectImplementation*) impl)->isCell();
}

bool SceneObjectAdapter::isTangible() {
	return ((SceneObjectImplementation*) impl)->isTangible();
}

bool SceneObjectAdapter::isIntangible() {
	return ((SceneObjectImplementation*) impl)->isIntangible();
}

bool SceneObjectAdapter::isStatic() {
	return ((SceneObjectImplementation*) impl)->isStatic();
}

bool SceneObjectAdapter::isShip() {
	return ((SceneObjectImplementation*) impl)->isShip();
}

bool SceneObjectAdapter::isAttackable() {
	return ((SceneObjectImplementation*) impl)->isAttackable();
}

bool SceneObjectAdapter::isMission() {
	return ((SceneObjectImplementation*) impl)->isMission();
}

bool SceneObjectAdapter::isPlayerObject() {
	return ((SceneObjectImplementation*) impl)->isPlayerObject();
}

bool SceneObjectAdapter::isWaypoint() {
	return ((SceneObjectImplementation*) impl)->isWaypoint();
}

bool SceneObjectAdapter::isManufactureSchematic() {
	return ((SceneObjectImplementation*) impl)->isManufactureSchematic();
}

int SceneObjectAdapter::compareTo(SceneObject* obj) {
	return ((SceneObjectImplementation*) impl)->compareTo(obj);
}

void SceneObjectAdapter::setParent(SceneObject* par, unsigned int linktype) {
	return ((SceneObjectImplementation*) impl)->setParent(par, linktype);
}

void SceneObjectAdapter::setZoneProcessServer(ZoneProcessServerImplementation* server) {
	return ((SceneObjectImplementation*) impl)->setZoneProcessServer(server);
}

void SceneObjectAdapter::setZone(Zone* zone) {
	return ((SceneObjectImplementation*) impl)->setZone(zone);
}

void SceneObjectAdapter::setZoneIndex(int id) {
	return ((SceneObjectImplementation*) impl)->setZoneIndex(id);
}

void SceneObjectAdapter::setObjectID(unsigned long long oid) {
	return ((SceneObjectImplementation*) impl)->setObjectID(oid);
}

void SceneObjectAdapter::setObjectCRC(unsigned int crc) {
	return ((SceneObjectImplementation*) impl)->setObjectCRC(crc);
}

void SceneObjectAdapter::setObjectType(int tp) {
	return ((SceneObjectImplementation*) impl)->setObjectType(tp);
}

void SceneObjectAdapter::setObjectKeeping(bool keeping) {
	return ((SceneObjectImplementation*) impl)->setObjectKeeping(keeping);
}

void SceneObjectAdapter::clearUndeploymentEvent() {
	return ((SceneObjectImplementation*) impl)->clearUndeploymentEvent();
}

bool SceneObjectAdapter::isUndeploymentScheduled() {
	return ((SceneObjectImplementation*) impl)->isUndeploymentScheduled();
}

void SceneObjectAdapter::setAssociatedArea(unsigned long long uid) {
	return ((SceneObjectImplementation*) impl)->setAssociatedArea(uid);
}

Zone* SceneObjectAdapter::getZone() {
	return ((SceneObjectImplementation*) impl)->getZone();
}

int SceneObjectAdapter::getZoneID() {
	return ((SceneObjectImplementation*) impl)->getZoneID();
}

unsigned long long SceneObjectAdapter::getObjectID() {
	return ((SceneObjectImplementation*) impl)->getObjectID();
}

unsigned int SceneObjectAdapter::getObjectCRC() {
	return ((SceneObjectImplementation*) impl)->getObjectCRC();
}

int SceneObjectAdapter::getObjectType() {
	return ((SceneObjectImplementation*) impl)->getObjectType();
}

unsigned int SceneObjectAdapter::getMovementCounter() {
	return ((SceneObjectImplementation*) impl)->getMovementCounter();
}

bool SceneObjectAdapter::isMoving() {
	return ((SceneObjectImplementation*) impl)->isMoving();
}

float SceneObjectAdapter::getPositionX() {
	return ((SceneObjectImplementation*) impl)->getPositionX();
}

float SceneObjectAdapter::getPositionZ() {
	return ((SceneObjectImplementation*) impl)->getPositionZ();
}

float SceneObjectAdapter::getPositionY() {
	return ((SceneObjectImplementation*) impl)->getPositionY();
}

float SceneObjectAdapter::getDirectionX() {
	return ((SceneObjectImplementation*) impl)->getDirectionX();
}

float SceneObjectAdapter::getDirectionZ() {
	return ((SceneObjectImplementation*) impl)->getDirectionZ();
}

float SceneObjectAdapter::getDirectionY() {
	return ((SceneObjectImplementation*) impl)->getDirectionY();
}

float SceneObjectAdapter::getDirectionW() {
	return ((SceneObjectImplementation*) impl)->getDirectionW();
}

byte SceneObjectAdapter::getDirectionAngle() {
	return ((SceneObjectImplementation*) impl)->getDirectionAngle();
}

float SceneObjectAdapter::getPrecisionDirectionAngle() {
	return ((SceneObjectImplementation*) impl)->getPrecisionDirectionAngle();
}

SceneObject* SceneObjectAdapter::getParent() {
	return ((SceneObjectImplementation*) impl)->getParent();
}

QuadTreeEntry* SceneObjectAdapter::getQuadTreeEntry() {
	return ((SceneObjectImplementation*) impl)->getQuadTreeEntry();
}

unsigned long long SceneObjectAdapter::getParentID() {
	return ((SceneObjectImplementation*) impl)->getParentID();
}

unicode& SceneObjectAdapter::getCustomName() {
	return ((SceneObjectImplementation*) impl)->getCustomName();
}

void SceneObjectAdapter::setCustomName(const string& name) {
	return ((SceneObjectImplementation*) impl)->setCustomName(name);
}

void SceneObjectAdapter::setCustomName(const unicode& name) {
	return ((SceneObjectImplementation*) impl)->setCustomName(name);
}

void SceneObjectAdapter::setStfName(const string& name) {
	return ((SceneObjectImplementation*) impl)->setStfName(name);
}

string& SceneObjectAdapter::getStfName() {
	return ((SceneObjectImplementation*) impl)->getStfName();
}

void SceneObjectAdapter::setStfFile(const string& file) {
	return ((SceneObjectImplementation*) impl)->setStfFile(file);
}

string& SceneObjectAdapter::getStfFile() {
	return ((SceneObjectImplementation*) impl)->getStfFile();
}

void SceneObjectAdapter::setStfDetail(const string& detail) {
	return ((SceneObjectImplementation*) impl)->setStfDetail(detail);
}

string& SceneObjectAdapter::getStfDetail() {
	return ((SceneObjectImplementation*) impl)->getStfDetail();
}

float SceneObjectAdapter::getPrecision(float num, int digits) {
	return ((SceneObjectImplementation*) impl)->getPrecision(num, digits);
}

void SceneObjectAdapter::getCustomizationString(string& appearance) {
	return ((SceneObjectImplementation*) impl)->getCustomizationString(appearance);
}

bool SceneObjectAdapter::isPersistent() {
	return ((SceneObjectImplementation*) impl)->isPersistent();
}

bool SceneObjectAdapter::isUpdated() {
	return ((SceneObjectImplementation*) impl)->isUpdated();
}

bool SceneObjectAdapter::isDeleted() {
	return ((SceneObjectImplementation*) impl)->isDeleted();
}

void SceneObjectAdapter::setAttributes(string& attributeString) {
	return ((SceneObjectImplementation*) impl)->setAttributes(attributeString);
}

string& SceneObjectAdapter::getAttributes() {
	return ((SceneObjectImplementation*) impl)->getAttributes();
}

unsigned long long SceneObjectAdapter::getAssociatedArea() {
	return ((SceneObjectImplementation*) impl)->getAssociatedArea();
}

bool SceneObjectAdapter::doKeepObject() {
	return ((SceneObjectImplementation*) impl)->doKeepObject();
}

void SceneObjectAdapter::setDefender(SceneObject* defender) {
	return ((SceneObjectImplementation*) impl)->setDefender(defender);
}

void SceneObjectAdapter::addDefender(SceneObject* defender) {
	return ((SceneObjectImplementation*) impl)->addDefender(defender);
}

void SceneObjectAdapter::removeDefender(SceneObject* defender) {
	return ((SceneObjectImplementation*) impl)->removeDefender(defender);
}

void SceneObjectAdapter::removeDefenders() {
	return ((SceneObjectImplementation*) impl)->removeDefenders();
}

bool SceneObjectAdapter::hasDefender(SceneObject* defender) {
	return ((SceneObjectImplementation*) impl)->hasDefender(defender);
}

void SceneObjectAdapter::setCombatState() {
	return ((SceneObjectImplementation*) impl)->setCombatState();
}

void SceneObjectAdapter::clearCombatState(bool removeDefenders) {
	return ((SceneObjectImplementation*) impl)->clearCombatState(removeDefenders);
}

SceneObject* SceneObjectAdapter::getDefender(int idx) {
	return ((SceneObjectImplementation*) impl)->getDefender(idx);
}

bool SceneObjectAdapter::isPeaced() {
	return ((SceneObjectImplementation*) impl)->isPeaced();
}

unsigned int SceneObjectAdapter::getDefenderListSize() {
	return ((SceneObjectImplementation*) impl)->getDefenderListSize();
}

bool SceneObjectAdapter::isAttackableBy(CreatureObject* creature) {
	return ((SceneObjectImplementation*) impl)->isAttackableBy(creature);
}

bool SceneObjectAdapter::isInANoBuildArea() {
	return ((SceneObjectImplementation*) impl)->isInANoBuildArea();
}

void SceneObjectAdapter::onIncapacitateTarget(CreatureObject* victim) {
	return ((SceneObjectImplementation*) impl)->onIncapacitateTarget(victim);
}

void SceneObjectAdapter::onInflictDamage(CreatureObject* victim, byte attribute, unsigned int damage) {
	return ((SceneObjectImplementation*) impl)->onInflictDamage(victim, attribute, damage);
}

void SceneObjectAdapter::onKill(CreatureObject* victim) {
	return ((SceneObjectImplementation*) impl)->onKill(victim);
}

void SceneObjectAdapter::onDeathblow(Player* victim) {
	return ((SceneObjectImplementation*) impl)->onDeathblow(victim);
}

void SceneObjectAdapter::onResuscitateTarget(CreatureObject* patient) {
	return ((SceneObjectImplementation*) impl)->onResuscitateTarget(patient);
}

void SceneObjectAdapter::onHealTargetDamage(CreatureObject* patient, byte attribute, unsigned int amount) {
	return ((SceneObjectImplementation*) impl)->onHealTargetDamage(patient, attribute, amount);
}

void SceneObjectAdapter::onHealTargetWound(CreatureObject* patient, byte attribute, unsigned int amount) {
	return ((SceneObjectImplementation*) impl)->onHealTargetWound(patient, attribute, amount);
}

void SceneObjectAdapter::onHealEnhanceTarget(CreatureObject* patient, byte attribute, unsigned int amount, float duration) {
	return ((SceneObjectImplementation*) impl)->onHealEnhanceTarget(patient, attribute, amount, duration);
}

void SceneObjectAdapter::onReceivePaymentFrom(CreatureObject* sender, unsigned int amount) {
	return ((SceneObjectImplementation*) impl)->onReceivePaymentFrom(sender, amount);
}

void SceneObjectAdapter::onTrade(Player* sender, Player* receiver) {
	return ((SceneObjectImplementation*) impl)->onTrade(sender, receiver);
}

bool SceneObjectAdapter::inflictDamage(CreatureObject* victim, byte attribute, unsigned int damage) {
	return ((SceneObjectImplementation*) impl)->inflictDamage(victim, attribute, damage);
}

void SceneObjectAdapter::incapacitate(CreatureObject* victim) {
	return ((SceneObjectImplementation*) impl)->incapacitate(victim);
}

void SceneObjectAdapter::kill(CreatureObject* victim) {
	return ((SceneObjectImplementation*) impl)->kill(victim);
}

void SceneObjectAdapter::deathblow(Player* victim) {
	return ((SceneObjectImplementation*) impl)->deathblow(victim);
}

void SceneObjectAdapter::resuscitate(CreatureObject* patient, bool forced) {
	return ((SceneObjectImplementation*) impl)->resuscitate(patient, forced);
}

unsigned int SceneObjectAdapter::healDamage(CreatureObject* patient, byte attribute, unsigned int amount) {
	return ((SceneObjectImplementation*) impl)->healDamage(patient, attribute, amount);
}

unsigned int SceneObjectAdapter::healWound(CreatureObject* patient, byte attribute, unsigned int amount) {
	return ((SceneObjectImplementation*) impl)->healWound(patient, attribute, amount);
}

unsigned int SceneObjectAdapter::healEnhance(CreatureObject* patient, byte attribute, unsigned int amount, float duration) {
	return ((SceneObjectImplementation*) impl)->healEnhance(patient, attribute, amount, duration);
}

void SceneObjectAdapter::receivePaymentFrom(CreatureObject* sender, unsigned int amount) {
	return ((SceneObjectImplementation*) impl)->receivePaymentFrom(sender, amount);
}

void SceneObjectAdapter::warpTo(float x, float z, float y, unsigned long long parentID) {
	return ((SceneObjectImplementation*) impl)->warpTo(x, z, y, parentID);
}

float SceneObjectAdapter::calculateDistance(SceneObject* scno) {
	return ((SceneObjectImplementation*) impl)->calculateDistance(scno);
}

bool SceneObjectAdapter::getPickupFlag() {
	return ((SceneObjectImplementation*) impl)->getPickupFlag();
}

void SceneObjectAdapter::setPickupFlag(bool pickup) {
	return ((SceneObjectImplementation*) impl)->setPickupFlag(pickup);
}

void SceneObjectAdapter::addSerializableVariables() {
	return ((SceneObjectImplementation*) impl)->addSerializableVariables();
}

/*
 *	SceneObjectHelper
 */

SceneObjectHelper* SceneObjectHelper::staticInitializer = SceneObjectHelper::instance();

SceneObjectHelper::SceneObjectHelper() {
	className = "SceneObject";

	DistributedObjectBroker::instance()->registerClass(className, this);
}

void SceneObjectHelper::finalizeHelper() {
	SceneObjectHelper::finalize();
}

DistributedObject* SceneObjectHelper::instantiateObject() {
	return new SceneObject(DummyConstructorParameter::instance());
}

DistributedObjectAdapter* SceneObjectHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new SceneObjectAdapter((SceneObjectImplementation*) obj->_getImplementation());

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

