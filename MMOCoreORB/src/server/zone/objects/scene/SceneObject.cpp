/*
 *	server/zone/objects/scene/SceneObject.cpp generated by engine3 IDL compiler 0.55
 */

#include "SceneObject.h"

#include "SceneObjectImplementation.h"

#include "../../packets/object/ObjectMenuResponse.h"

#include "../../Zone.h"

#include "../../ZoneClientSession.h"

#include "../player/Player.h"

#include "../tangible/weapons/Weapon.h"

#include "../creature/CreatureObject.h"

#include "../attackable/AttackableObject.h"

#include "../building/BuildingObject.h"

#include "../creature/skills/target/AttackTargetSkill.h"

/*
 *	SceneObjectStub
 */

SceneObject::SceneObject(DummyConstructorParameter* param) : ManagedObject(param) {
}

SceneObject::~SceneObject() {
}

bool SceneObject::_destroy() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 6);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->destroy();
}

void SceneObject::redeploy() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 7);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->redeploy();
}

void SceneObject::scheduleUndeploy() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 8);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->scheduleUndeploy();
}

void SceneObject::removeUndeploymentEvent() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 9);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->removeUndeploymentEvent();
}

void SceneObject::sendTo(Player* player, bool doClose) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 10);
		method.addObjectParameter(player);
		method.addBooleanParameter(doClose);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->sendTo(player, doClose);
}

void SceneObject::sendDestroyTo(Player* player) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 11);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->sendDestroyTo(player);
}

void SceneObject::sendRadialResponseTo(Player* player, ObjectMenuResponse* omr) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 12);
		method.addObjectParameter(player);
		method.addObjectParameter(omr);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->sendRadialResponseTo(player, omr);
}

void SceneObject::create(ZoneClientSession* client) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 13);
		method.addObjectParameter(client);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->create(client);
}

void SceneObject::destroy(ZoneClientSession* client) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 14);
		method.addObjectParameter(client);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->destroy(client);
}

void SceneObject::sendConversationStartTo(SceneObject* obj) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 15);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->sendConversationStartTo(obj);
}

void SceneObject::selectConversationOption(int option, SceneObject* obj) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 16);
		method.addSignedIntParameter(option);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->selectConversationOption(option, obj);
}

void SceneObject::close(ZoneClientSession* client) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 17);
		method.addObjectParameter(client);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->close(client);
}

void SceneObject::openTo(Player* player) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 18);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->openTo(player);
}

bool SceneObject::addObject(SceneObject* obj) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 19);
		method.addObjectParameter(obj);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->addObject(obj);
}

SceneObject* SceneObject::getObject(int index) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 20);
		method.addSignedIntParameter(index);

		return (SceneObject*) method.executeWithObjectReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getObject(index);
}

SceneObject* SceneObject::getObject(unsigned long long oid) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 21);
		method.addUnsignedLongParameter(oid);

		return (SceneObject*) method.executeWithObjectReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getObject(oid);
}

void SceneObject::removeObject(int index) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 22);
		method.addSignedIntParameter(index);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->removeObject(index);
}

void SceneObject::removeObject(unsigned long long oid) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 23);
		method.addUnsignedLongParameter(oid);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->removeObject(oid);
}

void SceneObject::sendItemsTo(Player* player) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 24);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->sendItemsTo(player);
}

int SceneObject::getContainerObjectsSize() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 25);

		return method.executeWithSignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getContainerObjectsSize();
}

bool SceneObject::isContainerEmpty() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 26);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isContainerEmpty();
}

bool SceneObject::isAttackable() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 27);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isAttackable();
}

int SceneObject::getSlots() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 28);

		return method.executeWithSignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getSlots();
}

int SceneObject::getContainerType() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 29);

		return method.executeWithSignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getContainerType();
}

int SceneObject::getContainerVolumeLimit() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 30);

		return method.executeWithSignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getContainerVolumeLimit();
}

void SceneObject::setSlots(int attributeSlots) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 31);
		method.addSignedIntParameter(attributeSlots);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setSlots(attributeSlots);
}

void SceneObject::setContainerVolumeLimit(unsigned int limit) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 32);
		method.addUnsignedIntParameter(limit);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setContainerVolumeLimit(limit);
}

void SceneObject::setContainerType(unsigned int type) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 33);
		method.addUnsignedIntParameter(type);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setContainerType(type);
}

bool SceneObject::isInRange(SceneObject* obj, float range) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 34);
		method.addObjectParameter(obj);
		method.addFloatParameter(range);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isInRange(obj, range);
}

bool SceneObject::isInRange(float x, float y, float range) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 35);
		method.addFloatParameter(x);
		method.addFloatParameter(y);
		method.addFloatParameter(range);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isInRange(x, y, range);
}

int SceneObject::inRangeObjectCount() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 36);

		return method.executeWithSignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->inRangeObjectCount();
}

QuadTreeEntry* SceneObject::getInRangeObject(int idx) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 37);
		method.addSignedIntParameter(idx);

		return (QuadTreeEntry*) method.executeWithObjectReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getInRangeObject(idx);
}

void SceneObject::addInRangeObject(QuadTreeEntry* obj, bool notifyUpdate) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 38);
		method.addObjectParameter(obj);
		method.addBooleanParameter(notifyUpdate);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->addInRangeObject(obj, notifyUpdate);
}

void SceneObject::removeInRangeObject(QuadTreeEntry* obj) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 39);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->removeInRangeObject(obj);
}

bool SceneObject::isInQuadTree() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 40);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isInQuadTree();
}

QuadTreeEntry* SceneObject::getQuadTreeEntry() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 41);

		return (QuadTreeEntry*) method.executeWithObjectReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getQuadTreeEntry();
}

int SceneObject::compareTo(SceneObject* obj) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 42);
		method.addObjectParameter(obj);

		return method.executeWithSignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->compareTo(obj);
}

BaseMessage* SceneObject::link(SceneObject* obj) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 43);
		method.addObjectParameter(obj);

		return (BaseMessage*) method.executeWithObjectReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->link(obj);
}

void SceneObject::link(ZoneClientSession* client, SceneObject* obj) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 44);
		method.addObjectParameter(client);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->link(client, obj);
}

void SceneObject::randomizePosition(float radius) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 45);
		method.addFloatParameter(radius);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->randomizePosition(radius);
}

int SceneObject::useObject(Player* player) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 46);
		method.addObjectParameter(player);

		return method.executeWithSignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->useObject(player);
}

void SceneObject::initializePosition(float x, float z, float y) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 47);
		method.addFloatParameter(x);
		method.addFloatParameter(z);
		method.addFloatParameter(y);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->initializePosition(x, z, y);
}

void SceneObject::setPosition(float x, float z, float y) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 48);
		method.addFloatParameter(x);
		method.addFloatParameter(z);
		method.addFloatParameter(y);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setPosition(x, z, y);
}

void SceneObject::setPositionX(float x) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 49);
		method.addFloatParameter(x);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setPositionX(x);
}

void SceneObject::setPositionZ(float z) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 50);
		method.addFloatParameter(z);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setPositionZ(z);
}

void SceneObject::setPositionY(float y) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 51);
		method.addFloatParameter(y);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setPositionY(y);
}

void SceneObject::setDirection(float x, float z, float y, float w) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 52);
		method.addFloatParameter(x);
		method.addFloatParameter(z);
		method.addFloatParameter(y);
		method.addFloatParameter(w);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setDirection(x, z, y, w);
}

void SceneObject::generateAttributes(Player* player) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 53);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->generateAttributes(player);
}

void SceneObject::info(const String& message, bool forcedLog) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 54);
		method.addAsciiParameter(message);
		method.addBooleanParameter(forcedLog);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->info(message, forcedLog);
}

void SceneObject::error(const String& message) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 55);
		method.addAsciiParameter(message);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->error(message);
}

void SceneObject::setZoneProcessServer(ZoneProcessServerImplementation* processor) {
	if (_impl == NULL) {
		throw ObjectNotLocalException(this);

	} else
		((SceneObjectImplementation*) _impl)->setZoneProcessServer(processor);
}

void SceneObject::setCustomName(const String& n) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 56);
		method.addAsciiParameter(n);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setCustomName(n);
}

void SceneObject::setCustomName(const UnicodeString& n) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 57);
		method.addUnicodeParameter(n);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setCustomName(n);
}

void SceneObject::setObjectID(unsigned long long oid) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 58);
		method.addUnsignedLongParameter(oid);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setObjectID(oid);
}

void SceneObject::setObjectCRC(unsigned int crc) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 59);
		method.addUnsignedIntParameter(crc);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setObjectCRC(crc);
}

void SceneObject::setObjectType(int tp) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 60);
		method.addSignedIntParameter(tp);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setObjectType(tp);
}

void SceneObject::setMovementCounter(unsigned int cntr) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 61);
		method.addUnsignedIntParameter(cntr);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setMovementCounter(cntr);
}

void SceneObject::setZoneIndex(int id) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 62);
		method.addSignedIntParameter(id);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setZoneIndex(id);
}

void SceneObject::setAssociatedArea(unsigned long long uid) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 63);
		method.addUnsignedLongParameter(uid);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setAssociatedArea(uid);
}

void SceneObject::setParent(SceneObject* par, unsigned int linktype) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 64);
		method.addObjectParameter(par);
		method.addUnsignedIntParameter(linktype);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setParent(par, linktype);
}

void SceneObject::setZone(Zone* zne) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 65);
		method.addObjectParameter(zne);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setZone(zne);
}

void SceneObject::clearUndeploymentEvent() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 66);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->clearUndeploymentEvent();
}

void SceneObject::insertToZone(Zone* zone) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 67);
		method.addObjectParameter(zone);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->insertToZone(zone);
}

void SceneObject::insertToBuilding(BuildingObject* building) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 68);
		method.addObjectParameter(building);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->insertToBuilding(building);
}

void SceneObject::removeFromZone(bool doLock) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 69);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->removeFromZone(doLock);
}

void SceneObject::removeFromBuilding(BuildingObject* building) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 70);
		method.addObjectParameter(building);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->removeFromBuilding(building);
}

void SceneObject::broadcastMessage(BaseMessage* msg, int range, bool doLock, bool sendSelf) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 71);
		method.addObjectParameter(msg);
		method.addSignedIntParameter(range);
		method.addBooleanParameter(doLock);
		method.addBooleanParameter(sendSelf);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->broadcastMessage(msg, range, doLock, sendSelf);
}

void SceneObject::broadcastMessage(StandaloneBaseMessage* msg, int range, bool doLock) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 72);
		method.addObjectParameter(msg);
		method.addSignedIntParameter(range);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->broadcastMessage(msg, range, doLock);
}

bool SceneObject::isUndeploymentScheduled() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 73);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isUndeploymentScheduled();
}

int SceneObject::getObjectType() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 74);

		return method.executeWithSignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getObjectType();
}

unsigned long long SceneObject::getObjectID() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 75);

		return method.executeWithUnsignedLongReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getObjectID();
}

unsigned int SceneObject::getObjectCRC() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 76);

		return method.executeWithUnsignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getObjectCRC();
}

unsigned int SceneObject::getMovementCounter() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 77);

		return method.executeWithUnsignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getMovementCounter();
}

float SceneObject::getPositionX() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 78);

		return method.executeWithFloatReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getPositionX();
}

float SceneObject::getPositionZ() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 79);

		return method.executeWithFloatReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getPositionZ();
}

float SceneObject::getPositionY() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 80);

		return method.executeWithFloatReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getPositionY();
}

int SceneObject::getDirectionAngle() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 81);

		return method.executeWithSignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getDirectionAngle();
}

float SceneObject::getPrecisionDirectionAngle() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 82);

		return method.executeWithFloatReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getPrecisionDirectionAngle();
}

float SceneObject::getDirectionX() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 83);

		return method.executeWithFloatReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getDirectionX();
}

float SceneObject::getDirectionZ() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 84);

		return method.executeWithFloatReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getDirectionZ();
}

float SceneObject::getDirectionY() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 85);

		return method.executeWithFloatReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getDirectionY();
}

float SceneObject::getDirectionW() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 86);

		return method.executeWithFloatReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getDirectionW();
}

String& SceneObject::getLoggingName() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 87);

		method.executeWithAsciiReturn(_return_getLoggingName);
		return _return_getLoggingName;
	} else
		return ((SceneObjectImplementation*) _impl)->getLoggingName();
}

UnicodeString& SceneObject::getCustomName() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 88);

		method.executeWithUnicodeReturn(_return_getCustomName);
		return _return_getCustomName;
	} else
		return ((SceneObjectImplementation*) _impl)->getCustomName();
}

String& SceneObject::getTemplateName() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 89);

		method.executeWithAsciiReturn(_return_getTemplateName);
		return _return_getTemplateName;
	} else
		return ((SceneObjectImplementation*) _impl)->getTemplateName();
}

String& SceneObject::getTemplateTypeName() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 90);

		method.executeWithAsciiReturn(_return_getTemplateTypeName);
		return _return_getTemplateTypeName;
	} else
		return ((SceneObjectImplementation*) _impl)->getTemplateTypeName();
}

unsigned long long SceneObject::getAssociatedArea() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 91);

		return method.executeWithUnsignedLongReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getAssociatedArea();
}

bool SceneObject::isPlayer() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 92);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isPlayer();
}

bool SceneObject::isNonPlayerCreature() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 93);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isNonPlayerCreature();
}

bool SceneObject::isBuilding() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 94);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isBuilding();
}

bool SceneObject::isCell() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 95);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isCell();
}

bool SceneObject::isTangible() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 96);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isTangible();
}

bool SceneObject::isIntangible() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 97);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isIntangible();
}

bool SceneObject::isStatic() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 98);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isStatic();
}

bool SceneObject::isShip() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 99);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isShip();
}

bool SceneObject::isAttackableObject() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 100);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isAttackableObject();
}

bool SceneObject::isMission() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 101);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isMission();
}

bool SceneObject::isPlayerObject() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 102);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isPlayerObject();
}

bool SceneObject::isWaypoint() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 103);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isWaypoint();
}

bool SceneObject::isManufactureSchematic() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 104);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isManufactureSchematic();
}

Zone* SceneObject::getZone() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 105);

		return (Zone*) method.executeWithObjectReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getZone();
}

int SceneObject::getZoneID() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 106);

		return method.executeWithSignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getZoneID();
}

SceneObject* SceneObject::getParent() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 107);

		return (SceneObject*) method.executeWithObjectReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getParent();
}

unsigned long long SceneObject::getParentID() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 108);

		return method.executeWithUnsignedLongReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getParentID();
}

bool SceneObject::isMoving() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 109);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isMoving();
}

void SceneObject::switchMovingState() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 110);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->switchMovingState();
}

bool SceneObject::doKeepObject() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 111);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->doKeepObject();
}

ZoneProcessServerImplementation* SceneObject::getZoneProcessServer() {
	if (_impl == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return ((SceneObjectImplementation*) _impl)->getZoneProcessServer();
}

void SceneObject::setTemplateName(const String& tempName) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 112);
		method.addAsciiParameter(tempName);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setTemplateName(tempName);
}

void SceneObject::setTemplateTypeName(const String& tempTypeName) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 113);
		method.addAsciiParameter(tempTypeName);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setTemplateTypeName(tempTypeName);
}

void SceneObject::setCombatState() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 114);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setCombatState();
}

void SceneObject::clearCombatState(bool removedefenders) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 115);
		method.addBooleanParameter(removedefenders);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->clearCombatState(removedefenders);
}

void SceneObject::setDefender(SceneObject* defender) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 116);
		method.addObjectParameter(defender);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->setDefender(defender);
}

void SceneObject::addDefender(SceneObject* defender) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 117);
		method.addObjectParameter(defender);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->addDefender(defender);
}

void SceneObject::removeDefenders() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 118);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->removeDefenders();
}

void SceneObject::removeDefender(SceneObject* defender) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 119);
		method.addObjectParameter(defender);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->removeDefender(defender);
}

bool SceneObject::hasDefender(SceneObject* defender) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 120);
		method.addObjectParameter(defender);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->hasDefender(defender);
}

SceneObject* SceneObject::getDefender(int idx) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 121);
		method.addSignedIntParameter(idx);

		return (SceneObject*) method.executeWithObjectReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getDefender(idx);
}

unsigned int SceneObject::getDefenderListSize() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 122);

		return method.executeWithUnsignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getDefenderListSize();
}

bool SceneObject::isPeaced() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 123);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isPeaced();
}

bool SceneObject::isAttackableBy(CreatureObject* creature) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 124);
		method.addObjectParameter(creature);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isAttackableBy(creature);
}

bool SceneObject::isInANoBuildArea() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 125);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->isInANoBuildArea();
}

void SceneObject::addDamageDone(CreatureObject* creature, int damage, String& skillname) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 126);
		method.addObjectParameter(creature);
		method.addSignedIntParameter(damage);
		method.addAsciiParameter(skillname);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->addDamageDone(creature, damage, skillname);
}

void SceneObject::dropDamageDone(CreatureObject* creature) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 127);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->dropDamageDone(creature);
}

int SceneObject::getTotalDamage() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 128);

		return method.executeWithSignedIntReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->getTotalDamage();
}

void SceneObject::disseminateXp(int levels) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 129);
		method.addSignedIntParameter(levels);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->disseminateXp(levels);
}

void SceneObject::cleanupDamageDone() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 130);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->cleanupDamageDone();
}

void SceneObject::onIncapacitateTarget(CreatureObject* victim) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 131);
		method.addObjectParameter(victim);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->onIncapacitateTarget(victim);
}

void SceneObject::onInflictDamage(AttackableObject* victim, unsigned int damage) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 132);
		method.addObjectParameter(victim);
		method.addUnsignedIntParameter(damage);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->onInflictDamage(victim, damage);
}

void SceneObject::onInflictDamage(CreatureObject* victim, unsigned char attribute, unsigned int damage) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 133);
		method.addObjectParameter(victim);
		method.addUnsignedCharParameter(attribute);
		method.addUnsignedIntParameter(damage);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->onInflictDamage(victim, attribute, damage);
}

void SceneObject::onKill(CreatureObject* victim) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 134);
		method.addObjectParameter(victim);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->onKill(victim);
}

void SceneObject::onDeathblow(Player* victim) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 135);
		method.addObjectParameter(victim);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->onDeathblow(victim);
}

void SceneObject::onReceivePaymentFrom(CreatureObject* sender, unsigned int amount) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 136);
		method.addObjectParameter(sender);
		method.addUnsignedIntParameter(amount);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->onReceivePaymentFrom(sender, amount);
}

bool SceneObject::inflictDamage(AttackableObject* victim, unsigned int damage) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 137);
		method.addObjectParameter(victim);
		method.addUnsignedIntParameter(damage);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->inflictDamage(victim, damage);
}

bool SceneObject::inflictDamage(CreatureObject* victim, unsigned char attribute, unsigned int damage) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 138);
		method.addObjectParameter(victim);
		method.addUnsignedCharParameter(attribute);
		method.addUnsignedIntParameter(damage);

		return method.executeWithBooleanReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->inflictDamage(victim, attribute, damage);
}

void SceneObject::incapacitate(CreatureObject* victim) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 139);
		method.addObjectParameter(victim);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->incapacitate(victim);
}

void SceneObject::kill(CreatureObject* victim) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 140);
		method.addObjectParameter(victim);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->kill(victim);
}

void SceneObject::deathblow(Player* victim) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 141);
		method.addObjectParameter(victim);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->deathblow(victim);
}

void SceneObject::receivePaymentFrom(CreatureObject* sender, unsigned int amount) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 142);
		method.addObjectParameter(sender);
		method.addUnsignedIntParameter(amount);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->receivePaymentFrom(sender, amount);
}

void SceneObject::warpTo(float x, float z, float y, unsigned long long parentID) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 143);
		method.addFloatParameter(x);
		method.addFloatParameter(z);
		method.addFloatParameter(y);
		method.addUnsignedLongParameter(parentID);

		method.executeWithVoidReturn();
	} else
		((SceneObjectImplementation*) _impl)->warpTo(x, z, y, parentID);
}

float SceneObject::calculateDistance(SceneObject* scno) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 144);
		method.addObjectParameter(scno);

		return method.executeWithFloatReturn();
	} else
		return ((SceneObjectImplementation*) _impl)->calculateDistance(scno);
}

/*
 *	SceneObjectAdapter
 */

SceneObjectAdapter::SceneObjectAdapter(SceneObjectImplementation* obj) : ManagedObjectAdapter(obj) {
}

Packet* SceneObjectAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	Packet* resp = new MethodReturnMessage(0);

	switch (methid) {
	case 6:
		resp->insertBoolean(destroy());
		break;
	case 7:
		redeploy();
		break;
	case 8:
		scheduleUndeploy();
		break;
	case 9:
		removeUndeploymentEvent();
		break;
	case 10:
		sendTo((Player*) inv->getObjectParameter(), inv->getBooleanParameter());
		break;
	case 11:
		sendDestroyTo((Player*) inv->getObjectParameter());
		break;
	case 12:
		sendRadialResponseTo((Player*) inv->getObjectParameter(), (ObjectMenuResponse*) inv->getObjectParameter());
		break;
	case 13:
		create((ZoneClientSession*) inv->getObjectParameter());
		break;
	case 14:
		destroy((ZoneClientSession*) inv->getObjectParameter());
		break;
	case 15:
		sendConversationStartTo((SceneObject*) inv->getObjectParameter());
		break;
	case 16:
		selectConversationOption(inv->getSignedIntParameter(), (SceneObject*) inv->getObjectParameter());
		break;
	case 17:
		close((ZoneClientSession*) inv->getObjectParameter());
		break;
	case 18:
		openTo((Player*) inv->getObjectParameter());
		break;
	case 19:
		resp->insertBoolean(addObject((SceneObject*) inv->getObjectParameter()));
		break;
	case 20:
		resp->insertLong(getObject(inv->getSignedIntParameter())->_getObjectID());
		break;
	case 21:
		resp->insertLong(getObject(inv->getUnsignedLongParameter())->_getObjectID());
		break;
	case 22:
		removeObject(inv->getSignedIntParameter());
		break;
	case 23:
		removeObject(inv->getUnsignedLongParameter());
		break;
	case 24:
		sendItemsTo((Player*) inv->getObjectParameter());
		break;
	case 25:
		resp->insertSignedInt(getContainerObjectsSize());
		break;
	case 26:
		resp->insertBoolean(isContainerEmpty());
		break;
	case 27:
		resp->insertBoolean(isAttackable());
		break;
	case 28:
		resp->insertSignedInt(getSlots());
		break;
	case 29:
		resp->insertSignedInt(getContainerType());
		break;
	case 30:
		resp->insertSignedInt(getContainerVolumeLimit());
		break;
	case 31:
		setSlots(inv->getSignedIntParameter());
		break;
	case 32:
		setContainerVolumeLimit(inv->getUnsignedIntParameter());
		break;
	case 33:
		setContainerType(inv->getUnsignedIntParameter());
		break;
	case 34:
		resp->insertBoolean(isInRange((SceneObject*) inv->getObjectParameter(), inv->getFloatParameter()));
		break;
	case 35:
		resp->insertBoolean(isInRange(inv->getFloatParameter(), inv->getFloatParameter(), inv->getFloatParameter()));
		break;
	case 36:
		resp->insertSignedInt(inRangeObjectCount());
		break;
	case 37:
		resp->insertLong(getInRangeObject(inv->getSignedIntParameter())->_getObjectID());
		break;
	case 38:
		addInRangeObject((QuadTreeEntry*) inv->getObjectParameter(), inv->getBooleanParameter());
		break;
	case 39:
		removeInRangeObject((QuadTreeEntry*) inv->getObjectParameter());
		break;
	case 40:
		resp->insertBoolean(isInQuadTree());
		break;
	case 41:
		resp->insertLong(getQuadTreeEntry()->_getObjectID());
		break;
	case 42:
		resp->insertSignedInt(compareTo((SceneObject*) inv->getObjectParameter()));
		break;
	case 43:
		resp->insertLong(link((SceneObject*) inv->getObjectParameter())->_getObjectID());
		break;
	case 44:
		link((ZoneClientSession*) inv->getObjectParameter(), (SceneObject*) inv->getObjectParameter());
		break;
	case 45:
		randomizePosition(inv->getFloatParameter());
		break;
	case 46:
		resp->insertSignedInt(useObject((Player*) inv->getObjectParameter()));
		break;
	case 47:
		initializePosition(inv->getFloatParameter(), inv->getFloatParameter(), inv->getFloatParameter());
		break;
	case 48:
		setPosition(inv->getFloatParameter(), inv->getFloatParameter(), inv->getFloatParameter());
		break;
	case 49:
		setPositionX(inv->getFloatParameter());
		break;
	case 50:
		setPositionZ(inv->getFloatParameter());
		break;
	case 51:
		setPositionY(inv->getFloatParameter());
		break;
	case 52:
		setDirection(inv->getFloatParameter(), inv->getFloatParameter(), inv->getFloatParameter(), inv->getFloatParameter());
		break;
	case 53:
		generateAttributes((Player*) inv->getObjectParameter());
		break;
	case 54:
		info(inv->getAsciiParameter(_param0_info__String_bool_), inv->getBooleanParameter());
		break;
	case 55:
		error(inv->getAsciiParameter(_param0_error__String_));
		break;
	case 56:
		setCustomName(inv->getAsciiParameter(_param0_setCustomName__String_));
		break;
	case 57:
		setCustomName(inv->getUnicodeParameter(_param0_setCustomName__UnicodeString_));
		break;
	case 58:
		setObjectID(inv->getUnsignedLongParameter());
		break;
	case 59:
		setObjectCRC(inv->getUnsignedIntParameter());
		break;
	case 60:
		setObjectType(inv->getSignedIntParameter());
		break;
	case 61:
		setMovementCounter(inv->getUnsignedIntParameter());
		break;
	case 62:
		setZoneIndex(inv->getSignedIntParameter());
		break;
	case 63:
		setAssociatedArea(inv->getUnsignedLongParameter());
		break;
	case 64:
		setParent((SceneObject*) inv->getObjectParameter(), inv->getUnsignedIntParameter());
		break;
	case 65:
		setZone((Zone*) inv->getObjectParameter());
		break;
	case 66:
		clearUndeploymentEvent();
		break;
	case 67:
		insertToZone((Zone*) inv->getObjectParameter());
		break;
	case 68:
		insertToBuilding((BuildingObject*) inv->getObjectParameter());
		break;
	case 69:
		removeFromZone(inv->getBooleanParameter());
		break;
	case 70:
		removeFromBuilding((BuildingObject*) inv->getObjectParameter());
		break;
	case 71:
		broadcastMessage((BaseMessage*) inv->getObjectParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter(), inv->getBooleanParameter());
		break;
	case 72:
		broadcastMessage((StandaloneBaseMessage*) inv->getObjectParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case 73:
		resp->insertBoolean(isUndeploymentScheduled());
		break;
	case 74:
		resp->insertSignedInt(getObjectType());
		break;
	case 75:
		resp->insertLong(getObjectID());
		break;
	case 76:
		resp->insertInt(getObjectCRC());
		break;
	case 77:
		resp->insertInt(getMovementCounter());
		break;
	case 78:
		resp->insertFloat(getPositionX());
		break;
	case 79:
		resp->insertFloat(getPositionZ());
		break;
	case 80:
		resp->insertFloat(getPositionY());
		break;
	case 81:
		resp->insertSignedInt(getDirectionAngle());
		break;
	case 82:
		resp->insertFloat(getPrecisionDirectionAngle());
		break;
	case 83:
		resp->insertFloat(getDirectionX());
		break;
	case 84:
		resp->insertFloat(getDirectionZ());
		break;
	case 85:
		resp->insertFloat(getDirectionY());
		break;
	case 86:
		resp->insertFloat(getDirectionW());
		break;
	case 87:
		resp->insertAscii(getLoggingName());
		break;
	case 88:
		resp->insertUnicode(getCustomName());
		break;
	case 89:
		resp->insertAscii(getTemplateName());
		break;
	case 90:
		resp->insertAscii(getTemplateTypeName());
		break;
	case 91:
		resp->insertLong(getAssociatedArea());
		break;
	case 92:
		resp->insertBoolean(isPlayer());
		break;
	case 93:
		resp->insertBoolean(isNonPlayerCreature());
		break;
	case 94:
		resp->insertBoolean(isBuilding());
		break;
	case 95:
		resp->insertBoolean(isCell());
		break;
	case 96:
		resp->insertBoolean(isTangible());
		break;
	case 97:
		resp->insertBoolean(isIntangible());
		break;
	case 98:
		resp->insertBoolean(isStatic());
		break;
	case 99:
		resp->insertBoolean(isShip());
		break;
	case 100:
		resp->insertBoolean(isAttackableObject());
		break;
	case 101:
		resp->insertBoolean(isMission());
		break;
	case 102:
		resp->insertBoolean(isPlayerObject());
		break;
	case 103:
		resp->insertBoolean(isWaypoint());
		break;
	case 104:
		resp->insertBoolean(isManufactureSchematic());
		break;
	case 105:
		resp->insertLong(getZone()->_getObjectID());
		break;
	case 106:
		resp->insertSignedInt(getZoneID());
		break;
	case 107:
		resp->insertLong(getParent()->_getObjectID());
		break;
	case 108:
		resp->insertLong(getParentID());
		break;
	case 109:
		resp->insertBoolean(isMoving());
		break;
	case 110:
		switchMovingState();
		break;
	case 111:
		resp->insertBoolean(doKeepObject());
		break;
	case 112:
		setTemplateName(inv->getAsciiParameter(_param0_setTemplateName__String_));
		break;
	case 113:
		setTemplateTypeName(inv->getAsciiParameter(_param0_setTemplateTypeName__String_));
		break;
	case 114:
		setCombatState();
		break;
	case 115:
		clearCombatState(inv->getBooleanParameter());
		break;
	case 116:
		setDefender((SceneObject*) inv->getObjectParameter());
		break;
	case 117:
		addDefender((SceneObject*) inv->getObjectParameter());
		break;
	case 118:
		removeDefenders();
		break;
	case 119:
		removeDefender((SceneObject*) inv->getObjectParameter());
		break;
	case 120:
		resp->insertBoolean(hasDefender((SceneObject*) inv->getObjectParameter()));
		break;
	case 121:
		resp->insertLong(getDefender(inv->getSignedIntParameter())->_getObjectID());
		break;
	case 122:
		resp->insertInt(getDefenderListSize());
		break;
	case 123:
		resp->insertBoolean(isPeaced());
		break;
	case 124:
		resp->insertBoolean(isAttackableBy((CreatureObject*) inv->getObjectParameter()));
		break;
	case 125:
		resp->insertBoolean(isInANoBuildArea());
		break;
	case 126:
		addDamageDone((CreatureObject*) inv->getObjectParameter(), inv->getSignedIntParameter(), inv->getAsciiParameter(_param2_addDamageDone__CreatureObject_int_String_));
		break;
	case 127:
		dropDamageDone((CreatureObject*) inv->getObjectParameter());
		break;
	case 128:
		resp->insertSignedInt(getTotalDamage());
		break;
	case 129:
		disseminateXp(inv->getSignedIntParameter());
		break;
	case 130:
		cleanupDamageDone();
		break;
	case 131:
		onIncapacitateTarget((CreatureObject*) inv->getObjectParameter());
		break;
	case 132:
		onInflictDamage((AttackableObject*) inv->getObjectParameter(), inv->getUnsignedIntParameter());
		break;
	case 133:
		onInflictDamage((CreatureObject*) inv->getObjectParameter(), inv->getUnsignedCharParameter(), inv->getUnsignedIntParameter());
		break;
	case 134:
		onKill((CreatureObject*) inv->getObjectParameter());
		break;
	case 135:
		onDeathblow((Player*) inv->getObjectParameter());
		break;
	case 136:
		onReceivePaymentFrom((CreatureObject*) inv->getObjectParameter(), inv->getUnsignedIntParameter());
		break;
	case 137:
		resp->insertBoolean(inflictDamage((AttackableObject*) inv->getObjectParameter(), inv->getUnsignedIntParameter()));
		break;
	case 138:
		resp->insertBoolean(inflictDamage((CreatureObject*) inv->getObjectParameter(), inv->getUnsignedCharParameter(), inv->getUnsignedIntParameter()));
		break;
	case 139:
		incapacitate((CreatureObject*) inv->getObjectParameter());
		break;
	case 140:
		kill((CreatureObject*) inv->getObjectParameter());
		break;
	case 141:
		deathblow((Player*) inv->getObjectParameter());
		break;
	case 142:
		receivePaymentFrom((CreatureObject*) inv->getObjectParameter(), inv->getUnsignedIntParameter());
		break;
	case 143:
		warpTo(inv->getFloatParameter(), inv->getFloatParameter(), inv->getFloatParameter(), inv->getUnsignedLongParameter());
		break;
	case 144:
		resp->insertFloat(calculateDistance((SceneObject*) inv->getObjectParameter()));
		break;
	default:
		return NULL;
	}

	return resp;
}

bool SceneObjectAdapter::destroy() {
	return ((SceneObjectImplementation*) impl)->destroy();
}

void SceneObjectAdapter::redeploy() {
	return ((SceneObjectImplementation*) impl)->redeploy();
}

void SceneObjectAdapter::scheduleUndeploy() {
	return ((SceneObjectImplementation*) impl)->scheduleUndeploy();
}

void SceneObjectAdapter::removeUndeploymentEvent() {
	return ((SceneObjectImplementation*) impl)->removeUndeploymentEvent();
}

void SceneObjectAdapter::sendTo(Player* player, bool doClose) {
	return ((SceneObjectImplementation*) impl)->sendTo(player, doClose);
}

void SceneObjectAdapter::sendDestroyTo(Player* player) {
	return ((SceneObjectImplementation*) impl)->sendDestroyTo(player);
}

void SceneObjectAdapter::sendRadialResponseTo(Player* player, ObjectMenuResponse* omr) {
	return ((SceneObjectImplementation*) impl)->sendRadialResponseTo(player, omr);
}

void SceneObjectAdapter::create(ZoneClientSession* client) {
	return ((SceneObjectImplementation*) impl)->create(client);
}

void SceneObjectAdapter::destroy(ZoneClientSession* client) {
	return ((SceneObjectImplementation*) impl)->destroy(client);
}

void SceneObjectAdapter::sendConversationStartTo(SceneObject* obj) {
	return ((SceneObjectImplementation*) impl)->sendConversationStartTo(obj);
}

void SceneObjectAdapter::selectConversationOption(int option, SceneObject* obj) {
	return ((SceneObjectImplementation*) impl)->selectConversationOption(option, obj);
}

void SceneObjectAdapter::close(ZoneClientSession* client) {
	return ((SceneObjectImplementation*) impl)->close(client);
}

void SceneObjectAdapter::openTo(Player* player) {
	return ((SceneObjectImplementation*) impl)->openTo(player);
}

bool SceneObjectAdapter::addObject(SceneObject* obj) {
	return ((SceneObjectImplementation*) impl)->addObject(obj);
}

SceneObject* SceneObjectAdapter::getObject(int index) {
	return ((SceneObjectImplementation*) impl)->getObject(index);
}

SceneObject* SceneObjectAdapter::getObject(unsigned long long oid) {
	return ((SceneObjectImplementation*) impl)->getObject(oid);
}

void SceneObjectAdapter::removeObject(int index) {
	return ((SceneObjectImplementation*) impl)->removeObject(index);
}

void SceneObjectAdapter::removeObject(unsigned long long oid) {
	return ((SceneObjectImplementation*) impl)->removeObject(oid);
}

void SceneObjectAdapter::sendItemsTo(Player* player) {
	return ((SceneObjectImplementation*) impl)->sendItemsTo(player);
}

int SceneObjectAdapter::getContainerObjectsSize() {
	return ((SceneObjectImplementation*) impl)->getContainerObjectsSize();
}

bool SceneObjectAdapter::isContainerEmpty() {
	return ((SceneObjectImplementation*) impl)->isContainerEmpty();
}

bool SceneObjectAdapter::isAttackable() {
	return ((SceneObjectImplementation*) impl)->isAttackable();
}

int SceneObjectAdapter::getSlots() {
	return ((SceneObjectImplementation*) impl)->getSlots();
}

int SceneObjectAdapter::getContainerType() {
	return ((SceneObjectImplementation*) impl)->getContainerType();
}

int SceneObjectAdapter::getContainerVolumeLimit() {
	return ((SceneObjectImplementation*) impl)->getContainerVolumeLimit();
}

void SceneObjectAdapter::setSlots(int attributeSlots) {
	return ((SceneObjectImplementation*) impl)->setSlots(attributeSlots);
}

void SceneObjectAdapter::setContainerVolumeLimit(unsigned int limit) {
	return ((SceneObjectImplementation*) impl)->setContainerVolumeLimit(limit);
}

void SceneObjectAdapter::setContainerType(unsigned int type) {
	return ((SceneObjectImplementation*) impl)->setContainerType(type);
}

bool SceneObjectAdapter::isInRange(SceneObject* obj, float range) {
	return ((SceneObjectImplementation*) impl)->isInRange(obj, range);
}

bool SceneObjectAdapter::isInRange(float x, float y, float range) {
	return ((SceneObjectImplementation*) impl)->isInRange(x, y, range);
}

int SceneObjectAdapter::inRangeObjectCount() {
	return ((SceneObjectImplementation*) impl)->inRangeObjectCount();
}

QuadTreeEntry* SceneObjectAdapter::getInRangeObject(int idx) {
	return ((SceneObjectImplementation*) impl)->getInRangeObject(idx);
}

void SceneObjectAdapter::addInRangeObject(QuadTreeEntry* obj, bool notifyUpdate) {
	return ((SceneObjectImplementation*) impl)->addInRangeObject(obj, notifyUpdate);
}

void SceneObjectAdapter::removeInRangeObject(QuadTreeEntry* obj) {
	return ((SceneObjectImplementation*) impl)->removeInRangeObject(obj);
}

bool SceneObjectAdapter::isInQuadTree() {
	return ((SceneObjectImplementation*) impl)->isInQuadTree();
}

QuadTreeEntry* SceneObjectAdapter::getQuadTreeEntry() {
	return ((SceneObjectImplementation*) impl)->getQuadTreeEntry();
}

int SceneObjectAdapter::compareTo(SceneObject* obj) {
	return ((SceneObjectImplementation*) impl)->compareTo(obj);
}

BaseMessage* SceneObjectAdapter::link(SceneObject* obj) {
	return ((SceneObjectImplementation*) impl)->link(obj);
}

void SceneObjectAdapter::link(ZoneClientSession* client, SceneObject* obj) {
	return ((SceneObjectImplementation*) impl)->link(client, obj);
}

void SceneObjectAdapter::randomizePosition(float radius) {
	return ((SceneObjectImplementation*) impl)->randomizePosition(radius);
}

int SceneObjectAdapter::useObject(Player* player) {
	return ((SceneObjectImplementation*) impl)->useObject(player);
}

void SceneObjectAdapter::initializePosition(float x, float z, float y) {
	return ((SceneObjectImplementation*) impl)->initializePosition(x, z, y);
}

void SceneObjectAdapter::setPosition(float x, float z, float y) {
	return ((SceneObjectImplementation*) impl)->setPosition(x, z, y);
}

void SceneObjectAdapter::setPositionX(float x) {
	return ((SceneObjectImplementation*) impl)->setPositionX(x);
}

void SceneObjectAdapter::setPositionZ(float z) {
	return ((SceneObjectImplementation*) impl)->setPositionZ(z);
}

void SceneObjectAdapter::setPositionY(float y) {
	return ((SceneObjectImplementation*) impl)->setPositionY(y);
}

void SceneObjectAdapter::setDirection(float x, float z, float y, float w) {
	return ((SceneObjectImplementation*) impl)->setDirection(x, z, y, w);
}

void SceneObjectAdapter::generateAttributes(Player* player) {
	return ((SceneObjectImplementation*) impl)->generateAttributes(player);
}

void SceneObjectAdapter::info(const String& message, bool forcedLog) {
	return ((SceneObjectImplementation*) impl)->info(message, forcedLog);
}

void SceneObjectAdapter::error(const String& message) {
	return ((SceneObjectImplementation*) impl)->error(message);
}

void SceneObjectAdapter::setCustomName(const String& n) {
	return ((SceneObjectImplementation*) impl)->setCustomName(n);
}

void SceneObjectAdapter::setCustomName(const UnicodeString& n) {
	return ((SceneObjectImplementation*) impl)->setCustomName(n);
}

void SceneObjectAdapter::setObjectID(unsigned long long oid) {
	return ((SceneObjectImplementation*) impl)->setObjectID(oid);
}

void SceneObjectAdapter::setObjectCRC(unsigned int crc) {
	return ((SceneObjectImplementation*) impl)->setObjectCRC(crc);
}

void SceneObjectAdapter::setObjectType(int tp) {
	return ((SceneObjectImplementation*) impl)->setObjectType(tp);
}

void SceneObjectAdapter::setMovementCounter(unsigned int cntr) {
	return ((SceneObjectImplementation*) impl)->setMovementCounter(cntr);
}

void SceneObjectAdapter::setZoneIndex(int id) {
	return ((SceneObjectImplementation*) impl)->setZoneIndex(id);
}

void SceneObjectAdapter::setAssociatedArea(unsigned long long uid) {
	return ((SceneObjectImplementation*) impl)->setAssociatedArea(uid);
}

void SceneObjectAdapter::setParent(SceneObject* par, unsigned int linktype) {
	return ((SceneObjectImplementation*) impl)->setParent(par, linktype);
}

void SceneObjectAdapter::setZone(Zone* zne) {
	return ((SceneObjectImplementation*) impl)->setZone(zne);
}

void SceneObjectAdapter::clearUndeploymentEvent() {
	return ((SceneObjectImplementation*) impl)->clearUndeploymentEvent();
}

void SceneObjectAdapter::insertToZone(Zone* zone) {
	return ((SceneObjectImplementation*) impl)->insertToZone(zone);
}

void SceneObjectAdapter::insertToBuilding(BuildingObject* building) {
	return ((SceneObjectImplementation*) impl)->insertToBuilding(building);
}

void SceneObjectAdapter::removeFromZone(bool doLock) {
	return ((SceneObjectImplementation*) impl)->removeFromZone(doLock);
}

void SceneObjectAdapter::removeFromBuilding(BuildingObject* building) {
	return ((SceneObjectImplementation*) impl)->removeFromBuilding(building);
}

void SceneObjectAdapter::broadcastMessage(BaseMessage* msg, int range, bool doLock, bool sendSelf) {
	return ((SceneObjectImplementation*) impl)->broadcastMessage(msg, range, doLock, sendSelf);
}

void SceneObjectAdapter::broadcastMessage(StandaloneBaseMessage* msg, int range, bool doLock) {
	return ((SceneObjectImplementation*) impl)->broadcastMessage(msg, range, doLock);
}

bool SceneObjectAdapter::isUndeploymentScheduled() {
	return ((SceneObjectImplementation*) impl)->isUndeploymentScheduled();
}

int SceneObjectAdapter::getObjectType() {
	return ((SceneObjectImplementation*) impl)->getObjectType();
}

unsigned long long SceneObjectAdapter::getObjectID() {
	return ((SceneObjectImplementation*) impl)->getObjectID();
}

unsigned int SceneObjectAdapter::getObjectCRC() {
	return ((SceneObjectImplementation*) impl)->getObjectCRC();
}

unsigned int SceneObjectAdapter::getMovementCounter() {
	return ((SceneObjectImplementation*) impl)->getMovementCounter();
}

float SceneObjectAdapter::getPositionX() {
	return ((SceneObjectImplementation*) impl)->getPositionX();
}

float SceneObjectAdapter::getPositionZ() {
	return ((SceneObjectImplementation*) impl)->getPositionZ();
}

float SceneObjectAdapter::getPositionY() {
	return ((SceneObjectImplementation*) impl)->getPositionY();
}

int SceneObjectAdapter::getDirectionAngle() {
	return ((SceneObjectImplementation*) impl)->getDirectionAngle();
}

float SceneObjectAdapter::getPrecisionDirectionAngle() {
	return ((SceneObjectImplementation*) impl)->getPrecisionDirectionAngle();
}

float SceneObjectAdapter::getDirectionX() {
	return ((SceneObjectImplementation*) impl)->getDirectionX();
}

float SceneObjectAdapter::getDirectionZ() {
	return ((SceneObjectImplementation*) impl)->getDirectionZ();
}

float SceneObjectAdapter::getDirectionY() {
	return ((SceneObjectImplementation*) impl)->getDirectionY();
}

float SceneObjectAdapter::getDirectionW() {
	return ((SceneObjectImplementation*) impl)->getDirectionW();
}

String& SceneObjectAdapter::getLoggingName() {
	return ((SceneObjectImplementation*) impl)->getLoggingName();
}

UnicodeString& SceneObjectAdapter::getCustomName() {
	return ((SceneObjectImplementation*) impl)->getCustomName();
}

String& SceneObjectAdapter::getTemplateName() {
	return ((SceneObjectImplementation*) impl)->getTemplateName();
}

String& SceneObjectAdapter::getTemplateTypeName() {
	return ((SceneObjectImplementation*) impl)->getTemplateTypeName();
}

unsigned long long SceneObjectAdapter::getAssociatedArea() {
	return ((SceneObjectImplementation*) impl)->getAssociatedArea();
}

bool SceneObjectAdapter::isPlayer() {
	return ((SceneObjectImplementation*) impl)->isPlayer();
}

bool SceneObjectAdapter::isNonPlayerCreature() {
	return ((SceneObjectImplementation*) impl)->isNonPlayerCreature();
}

bool SceneObjectAdapter::isBuilding() {
	return ((SceneObjectImplementation*) impl)->isBuilding();
}

bool SceneObjectAdapter::isCell() {
	return ((SceneObjectImplementation*) impl)->isCell();
}

bool SceneObjectAdapter::isTangible() {
	return ((SceneObjectImplementation*) impl)->isTangible();
}

bool SceneObjectAdapter::isIntangible() {
	return ((SceneObjectImplementation*) impl)->isIntangible();
}

bool SceneObjectAdapter::isStatic() {
	return ((SceneObjectImplementation*) impl)->isStatic();
}

bool SceneObjectAdapter::isShip() {
	return ((SceneObjectImplementation*) impl)->isShip();
}

bool SceneObjectAdapter::isAttackableObject() {
	return ((SceneObjectImplementation*) impl)->isAttackableObject();
}

bool SceneObjectAdapter::isMission() {
	return ((SceneObjectImplementation*) impl)->isMission();
}

bool SceneObjectAdapter::isPlayerObject() {
	return ((SceneObjectImplementation*) impl)->isPlayerObject();
}

bool SceneObjectAdapter::isWaypoint() {
	return ((SceneObjectImplementation*) impl)->isWaypoint();
}

bool SceneObjectAdapter::isManufactureSchematic() {
	return ((SceneObjectImplementation*) impl)->isManufactureSchematic();
}

Zone* SceneObjectAdapter::getZone() {
	return ((SceneObjectImplementation*) impl)->getZone();
}

int SceneObjectAdapter::getZoneID() {
	return ((SceneObjectImplementation*) impl)->getZoneID();
}

SceneObject* SceneObjectAdapter::getParent() {
	return ((SceneObjectImplementation*) impl)->getParent();
}

unsigned long long SceneObjectAdapter::getParentID() {
	return ((SceneObjectImplementation*) impl)->getParentID();
}

bool SceneObjectAdapter::isMoving() {
	return ((SceneObjectImplementation*) impl)->isMoving();
}

void SceneObjectAdapter::switchMovingState() {
	return ((SceneObjectImplementation*) impl)->switchMovingState();
}

bool SceneObjectAdapter::doKeepObject() {
	return ((SceneObjectImplementation*) impl)->doKeepObject();
}

void SceneObjectAdapter::setTemplateName(const String& tempName) {
	return ((SceneObjectImplementation*) impl)->setTemplateName(tempName);
}

void SceneObjectAdapter::setTemplateTypeName(const String& tempTypeName) {
	return ((SceneObjectImplementation*) impl)->setTemplateTypeName(tempTypeName);
}

void SceneObjectAdapter::setCombatState() {
	return ((SceneObjectImplementation*) impl)->setCombatState();
}

void SceneObjectAdapter::clearCombatState(bool removedefenders) {
	return ((SceneObjectImplementation*) impl)->clearCombatState(removedefenders);
}

void SceneObjectAdapter::setDefender(SceneObject* defender) {
	return ((SceneObjectImplementation*) impl)->setDefender(defender);
}

void SceneObjectAdapter::addDefender(SceneObject* defender) {
	return ((SceneObjectImplementation*) impl)->addDefender(defender);
}

void SceneObjectAdapter::removeDefenders() {
	return ((SceneObjectImplementation*) impl)->removeDefenders();
}

void SceneObjectAdapter::removeDefender(SceneObject* defender) {
	return ((SceneObjectImplementation*) impl)->removeDefender(defender);
}

bool SceneObjectAdapter::hasDefender(SceneObject* defender) {
	return ((SceneObjectImplementation*) impl)->hasDefender(defender);
}

SceneObject* SceneObjectAdapter::getDefender(int idx) {
	return ((SceneObjectImplementation*) impl)->getDefender(idx);
}

unsigned int SceneObjectAdapter::getDefenderListSize() {
	return ((SceneObjectImplementation*) impl)->getDefenderListSize();
}

bool SceneObjectAdapter::isPeaced() {
	return ((SceneObjectImplementation*) impl)->isPeaced();
}

bool SceneObjectAdapter::isAttackableBy(CreatureObject* creature) {
	return ((SceneObjectImplementation*) impl)->isAttackableBy(creature);
}

bool SceneObjectAdapter::isInANoBuildArea() {
	return ((SceneObjectImplementation*) impl)->isInANoBuildArea();
}

void SceneObjectAdapter::addDamageDone(CreatureObject* creature, int damage, String& skillname) {
	return ((SceneObjectImplementation*) impl)->addDamageDone(creature, damage, skillname);
}

void SceneObjectAdapter::dropDamageDone(CreatureObject* creature) {
	return ((SceneObjectImplementation*) impl)->dropDamageDone(creature);
}

int SceneObjectAdapter::getTotalDamage() {
	return ((SceneObjectImplementation*) impl)->getTotalDamage();
}

void SceneObjectAdapter::disseminateXp(int levels) {
	return ((SceneObjectImplementation*) impl)->disseminateXp(levels);
}

void SceneObjectAdapter::cleanupDamageDone() {
	return ((SceneObjectImplementation*) impl)->cleanupDamageDone();
}

void SceneObjectAdapter::onIncapacitateTarget(CreatureObject* victim) {
	return ((SceneObjectImplementation*) impl)->onIncapacitateTarget(victim);
}

void SceneObjectAdapter::onInflictDamage(AttackableObject* victim, unsigned int damage) {
	return ((SceneObjectImplementation*) impl)->onInflictDamage(victim, damage);
}

void SceneObjectAdapter::onInflictDamage(CreatureObject* victim, unsigned char attribute, unsigned int damage) {
	return ((SceneObjectImplementation*) impl)->onInflictDamage(victim, attribute, damage);
}

void SceneObjectAdapter::onKill(CreatureObject* victim) {
	return ((SceneObjectImplementation*) impl)->onKill(victim);
}

void SceneObjectAdapter::onDeathblow(Player* victim) {
	return ((SceneObjectImplementation*) impl)->onDeathblow(victim);
}

void SceneObjectAdapter::onReceivePaymentFrom(CreatureObject* sender, unsigned int amount) {
	return ((SceneObjectImplementation*) impl)->onReceivePaymentFrom(sender, amount);
}

bool SceneObjectAdapter::inflictDamage(AttackableObject* victim, unsigned int damage) {
	return ((SceneObjectImplementation*) impl)->inflictDamage(victim, damage);
}

bool SceneObjectAdapter::inflictDamage(CreatureObject* victim, unsigned char attribute, unsigned int damage) {
	return ((SceneObjectImplementation*) impl)->inflictDamage(victim, attribute, damage);
}

void SceneObjectAdapter::incapacitate(CreatureObject* victim) {
	return ((SceneObjectImplementation*) impl)->incapacitate(victim);
}

void SceneObjectAdapter::kill(CreatureObject* victim) {
	return ((SceneObjectImplementation*) impl)->kill(victim);
}

void SceneObjectAdapter::deathblow(Player* victim) {
	return ((SceneObjectImplementation*) impl)->deathblow(victim);
}

void SceneObjectAdapter::receivePaymentFrom(CreatureObject* sender, unsigned int amount) {
	return ((SceneObjectImplementation*) impl)->receivePaymentFrom(sender, amount);
}

void SceneObjectAdapter::warpTo(float x, float z, float y, unsigned long long parentID) {
	return ((SceneObjectImplementation*) impl)->warpTo(x, z, y, parentID);
}

float SceneObjectAdapter::calculateDistance(SceneObject* scno) {
	return ((SceneObjectImplementation*) impl)->calculateDistance(scno);
}

/*
 *	SceneObjectHelper
 */

SceneObjectHelper* SceneObjectHelper::staticInitializer = SceneObjectHelper::instance();

SceneObjectHelper::SceneObjectHelper() {
	className = "SceneObject";

	DistributedObjectBroker::instance()->registerClass(className, this);
}

void SceneObjectHelper::finalizeHelper() {
	SceneObjectHelper::finalize();
}

DistributedObject* SceneObjectHelper::instantiateObject() {
	return new SceneObject(DummyConstructorParameter::instance());
}

DistributedObjectAdapter* SceneObjectHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new SceneObjectAdapter((SceneObjectImplementation*) obj->_getImplementation());

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	SceneObjectServant
 */

SceneObjectServant::SceneObjectServant() : ManagedObjectImplementation() {
	_classHelper = SceneObjectHelper::instance();
}

SceneObjectServant::~SceneObjectServant() {
}

void SceneObjectServant::_setStub(DistributedObjectStub* stub) {
	_this = (SceneObject*) stub;
	ManagedObjectServant::_setStub(stub);
}

DistributedObjectStub* SceneObjectServant::_getStub() {
	return _this;
}

