/*
 *	server/zone/objects/scene/components/ContainerComponent.cpp generated by engine3 IDL compiler 0.60
 */

#include "ContainerComponent.h"

#include "server/zone/objects/scene/SceneObject.h"

/*
 *	ContainerComponentStub
 */

enum {RPC_INITIALIZE__SCENEOBJECT_ = 6,RPC_INITIALIZETRANSIENTMEMBERS__,RPC_NOTIFYLOADFROMDATABASE__,RPC_ADDOBJECT__SCENEOBJECT_INT_BOOL_,RPC_REMOVEOBJECT__SCENEOBJECT_BOOL_,RPC_CANADDOBJECT__SCENEOBJECT_INT_STRING_,RPC_GETSLOTTEDOBJECT__STRING_,RPC_GETSLOTTEDOBJECT__INT_,RPC_DROPSLOTTEDOBJECT__STRING_,RPC_REMOVESLOTTEDOBJECT__INT_,RPC_GETCONTAINEROBJECTSSIZE__,RPC_GETSLOTTEDOBJECTSSIZE__,RPC_HASFULLCONTAINEROBJECTS__,RPC_GETCONTAINERVOLUMELIMIT__,RPC_GETCONTAINEROBJECT__INT_,RPC_HASOBJECTINCONTAINER__LONG_,RPC_HASOBJECTINSLOTTEDCONTAINER__SCENEOBJECT_,RPC_GETCONTAINEROBJECT__LONG_,RPC_REMOVEALLCONTAINEROBJECTS__,RPC_PUTINCONTAINER__SCENEOBJECT_LONG_,RPC_REMOVEFROMCONTAINEROBJECTS__INT_,RPC_SETCONTAINERVOLUMELIMIT__INT_,RPC_SETCONTAINERTYPE__INT_,RPC_GETCONTAINERTYPE__};

ContainerComponent::ContainerComponent() : SceneObjectComponent(DummyConstructorParameter::instance()) {
	ContainerComponentImplementation* _implementation = new ContainerComponentImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
}

ContainerComponent::ContainerComponent(DummyConstructorParameter* param) : SceneObjectComponent(param) {
}

ContainerComponent::~ContainerComponent() {
}


void ContainerComponent::initialize(SceneObject* obj) {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZE__SCENEOBJECT_);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else
		_implementation->initialize(obj);
}

void ContainerComponent::initializeTransientMembers() {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else
		_implementation->initializeTransientMembers();
}

void ContainerComponent::notifyLoadFromDatabase() {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYLOADFROMDATABASE__);

		method.executeWithVoidReturn();
	} else
		_implementation->notifyLoadFromDatabase();
}

bool ContainerComponent::addObject(SceneObject* object, int containmentType, bool notifyClient) {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDOBJECT__SCENEOBJECT_INT_BOOL_);
		method.addObjectParameter(object);
		method.addSignedIntParameter(containmentType);
		method.addBooleanParameter(notifyClient);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->addObject(object, containmentType, notifyClient);
}

bool ContainerComponent::removeObject(SceneObject* object, bool notifyClient) {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEOBJECT__SCENEOBJECT_BOOL_);
		method.addObjectParameter(object);
		method.addBooleanParameter(notifyClient);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->removeObject(object, notifyClient);
}

int ContainerComponent::canAddObject(SceneObject* object, int containmentType, String& errorDescription) {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANADDOBJECT__SCENEOBJECT_INT_STRING_);
		method.addObjectParameter(object);
		method.addSignedIntParameter(containmentType);
		method.addAsciiParameter(errorDescription);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->canAddObject(object, containmentType, errorDescription);
}

void ContainerComponent::getContainmentObjects(VectorMap<String, ManagedReference<SceneObject* > >& objects) {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->getContainmentObjects(objects);
}

SceneObject* ContainerComponent::getSlottedObject(const String& slot) {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSLOTTEDOBJECT__STRING_);
		method.addAsciiParameter(slot);

		return (SceneObject*) method.executeWithObjectReturn();
	} else
		return _implementation->getSlottedObject(slot);
}

SceneObject* ContainerComponent::getSlottedObject(int idx) {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSLOTTEDOBJECT__INT_);
		method.addSignedIntParameter(idx);

		return (SceneObject*) method.executeWithObjectReturn();
	} else
		return _implementation->getSlottedObject(idx);
}

void ContainerComponent::dropSlottedObject(const String& arrengementDescriptor) {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DROPSLOTTEDOBJECT__STRING_);
		method.addAsciiParameter(arrengementDescriptor);

		method.executeWithVoidReturn();
	} else
		_implementation->dropSlottedObject(arrengementDescriptor);
}

void ContainerComponent::removeSlottedObject(int index) {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVESLOTTEDOBJECT__INT_);
		method.addSignedIntParameter(index);

		method.executeWithVoidReturn();
	} else
		_implementation->removeSlottedObject(index);
}

int ContainerComponent::getContainerObjectsSize() {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCONTAINEROBJECTSSIZE__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getContainerObjectsSize();
}

int ContainerComponent::getSlottedObjectsSize() {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSLOTTEDOBJECTSSIZE__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getSlottedObjectsSize();
}

bool ContainerComponent::hasFullContainerObjects() {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASFULLCONTAINEROBJECTS__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasFullContainerObjects();
}

int ContainerComponent::getContainerVolumeLimit() {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCONTAINERVOLUMELIMIT__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getContainerVolumeLimit();
}

SceneObject* ContainerComponent::getContainerObject(int idx) {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCONTAINEROBJECT__INT_);
		method.addSignedIntParameter(idx);

		return (SceneObject*) method.executeWithObjectReturn();
	} else
		return _implementation->getContainerObject(idx);
}

VectorMap<unsigned long long, ManagedReference<SceneObject* > >* ContainerComponent::getContainerObjects() {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getContainerObjects();
}

bool ContainerComponent::hasObjectInContainer(unsigned long long objectID) {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASOBJECTINCONTAINER__LONG_);
		method.addUnsignedLongParameter(objectID);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasObjectInContainer(objectID);
}

bool ContainerComponent::hasObjectInSlottedContainer(SceneObject* object) {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASOBJECTINSLOTTEDCONTAINER__SCENEOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasObjectInSlottedContainer(object);
}

SceneObject* ContainerComponent::getContainerObject(unsigned long long objectID) {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCONTAINEROBJECT__LONG_);
		method.addUnsignedLongParameter(objectID);

		return (SceneObject*) method.executeWithObjectReturn();
	} else
		return _implementation->getContainerObject(objectID);
}

void ContainerComponent::removeAllContainerObjects() {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEALLCONTAINEROBJECTS__);

		method.executeWithVoidReturn();
	} else
		_implementation->removeAllContainerObjects();
}

void ContainerComponent::putInContainer(SceneObject* obj, unsigned long long key) {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_PUTINCONTAINER__SCENEOBJECT_LONG_);
		method.addObjectParameter(obj);
		method.addUnsignedLongParameter(key);

		method.executeWithVoidReturn();
	} else
		_implementation->putInContainer(obj, key);
}

void ContainerComponent::removeFromContainerObjects(int index) {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEFROMCONTAINEROBJECTS__INT_);
		method.addSignedIntParameter(index);

		method.executeWithVoidReturn();
	} else
		_implementation->removeFromContainerObjects(index);
}

void ContainerComponent::setContainerVolumeLimit(int lim) {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCONTAINERVOLUMELIMIT__INT_);
		method.addSignedIntParameter(lim);

		method.executeWithVoidReturn();
	} else
		_implementation->setContainerVolumeLimit(lim);
}

void ContainerComponent::setContainerType(int type) {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCONTAINERTYPE__INT_);
		method.addSignedIntParameter(type);

		method.executeWithVoidReturn();
	} else
		_implementation->setContainerType(type);
}

unsigned int ContainerComponent::getContainerType() {
	ContainerComponentImplementation* _implementation = (ContainerComponentImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCONTAINERTYPE__);

		return method.executeWithUnsignedIntReturn();
	} else
		return _implementation->getContainerType();
}

DistributedObjectServant* ContainerComponent::_getImplementation() {

	_updated = true;
	return _impl;
}

void ContainerComponent::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	ContainerComponentImplementation
 */

ContainerComponentImplementation::ContainerComponentImplementation(DummyConstructorParameter* param) : SceneObjectComponentImplementation(param) {
	_initializeImplementation();
}


ContainerComponentImplementation::~ContainerComponentImplementation() {
}


void ContainerComponentImplementation::finalize() {
}

void ContainerComponentImplementation::_initializeImplementation() {
	_setClassHelper(ContainerComponentHelper::instance());

	_serializationHelperMethod();
	_serializationHelperMethod();
}

void ContainerComponentImplementation::_setStub(DistributedObjectStub* stub) {
	_this = (ContainerComponent*) stub;
	SceneObjectComponentImplementation::_setStub(stub);
}

DistributedObjectStub* ContainerComponentImplementation::_getStub() {
	return _this;
}

ContainerComponentImplementation::operator const ContainerComponent*() {
	return _this;
}

void ContainerComponentImplementation::lock(bool doLock) {
	_this->lock(doLock);
}

void ContainerComponentImplementation::lock(ManagedObject* obj) {
	_this->lock(obj);
}

void ContainerComponentImplementation::rlock(bool doLock) {
	_this->rlock(doLock);
}

void ContainerComponentImplementation::wlock(bool doLock) {
	_this->wlock(doLock);
}

void ContainerComponentImplementation::wlock(ManagedObject* obj) {
	_this->wlock(obj);
}

void ContainerComponentImplementation::unlock(bool doLock) {
	_this->unlock(doLock);
}

void ContainerComponentImplementation::runlock(bool doLock) {
	_this->runlock(doLock);
}

void ContainerComponentImplementation::_serializationHelperMethod() {
	SceneObjectComponentImplementation::_serializationHelperMethod();

	_setClassName("ContainerComponent");

}

void ContainerComponentImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		String _name;
		_name.parseFromBinaryStream(stream);

		uint16 _varSize = stream->readShort();

		int _currentOffset = stream->getOffset();

		if(ContainerComponentImplementation::readObjectMember(stream, _name)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool ContainerComponentImplementation::readObjectMember(ObjectInputStream* stream, const String& _name) {
	if (SceneObjectComponentImplementation::readObjectMember(stream, _name))
		return true;

	if (_name == "slottedObjects") {
		TypeInfo<VectorMap<String, ManagedReference<SceneObject* > > >::parseFromBinaryStream(&slottedObjects, stream);
		return true;
	}

	if (_name == "containerObjects") {
		TypeInfo<VectorMap<unsigned long long, ManagedReference<SceneObject* > > >::parseFromBinaryStream(&containerObjects, stream);
		return true;
	}

	if (_name == "containerType") {
		TypeInfo<unsigned int >::parseFromBinaryStream(&containerType, stream);
		return true;
	}

	if (_name == "containerVolumeLimit") {
		TypeInfo<unsigned int >::parseFromBinaryStream(&containerVolumeLimit, stream);
		return true;
	}


	return false;
}

void ContainerComponentImplementation::writeObject(ObjectOutputStream* stream) {
	if (sceneObject->getObjectID() == 2716060) {
		sceneObject->info("WRITING MOTHER FUCKING BITCH", true);
	}

	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = ContainerComponentImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int ContainerComponentImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	String _name;
	int _offset;
	uint16 _totalSize;
	_name = "slottedObjects";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<VectorMap<String, ManagedReference<SceneObject* > > >::toBinaryStream(&slottedObjects, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "containerObjects";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<VectorMap<unsigned long long, ManagedReference<SceneObject* > > >::toBinaryStream(&containerObjects, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "containerType";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<unsigned int >::toBinaryStream(&containerType, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "containerVolumeLimit";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<unsigned int >::toBinaryStream(&containerVolumeLimit, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);


	return 4 + SceneObjectComponentImplementation::writeObjectMembers(stream);
}

ContainerComponentImplementation::ContainerComponentImplementation() : SceneObjectComponentImplementation() {
	_initializeImplementation();
	// server/zone/objects/scene/components/ContainerComponent.idl():  		containerType = 0;
	containerType = 0;
	// server/zone/objects/scene/components/ContainerComponent.idl():  		containerVolumeLimit = 0;
	containerVolumeLimit = 0;
}

void ContainerComponentImplementation::initialize(SceneObject* obj) {
	// server/zone/objects/scene/components/ContainerComponent.idl():  		super.initialize(obj);
	SceneObjectComponentImplementation::initialize(obj);
	// server/zone/objects/scene/components/ContainerComponent.idl():  		initializeTransientMembers();
	initializeTransientMembers();
}

void ContainerComponentImplementation::initializeTransientMembers() {
	// server/zone/objects/scene/components/ContainerComponent.idl():  		super.initializeTransientMembers();
	SceneObjectComponentImplementation::initializeTransientMembers();
	// server/zone/objects/scene/components/ContainerComponent.idl():  		slottedObjects.setNullValue(null);
	(&slottedObjects)->setNullValue(NULL);
	// server/zone/objects/scene/components/ContainerComponent.idl():  		slottedObjects.setNoDuplicateInsertPlan();
	(&slottedObjects)->setNoDuplicateInsertPlan();
	// server/zone/objects/scene/components/ContainerComponent.idl():  		containerObjects.setNullValue(null);
	(&containerObjects)->setNullValue(NULL);
	// server/zone/objects/scene/components/ContainerComponent.idl():  		containerObjects.setNoDuplicateInsertPlan();
	(&containerObjects)->setNoDuplicateInsertPlan();
}

SceneObject* ContainerComponentImplementation::getSlottedObject(const String& slot) {
	// server/zone/objects/scene/components/ContainerComponent.idl():  		return slottedObjects.get(slot);
	return (&slottedObjects)->get(slot);
}

SceneObject* ContainerComponentImplementation::getSlottedObject(int idx) {
	// server/zone/objects/scene/components/ContainerComponent.idl():  		return slottedObjects.get(idx);
	return (&slottedObjects)->get(idx);
}

void ContainerComponentImplementation::dropSlottedObject(const String& arrengementDescriptor) {
	// server/zone/objects/scene/components/ContainerComponent.idl():  		slottedObjects.drop(arrengementDescriptor);
	(&slottedObjects)->drop(arrengementDescriptor);
}

void ContainerComponentImplementation::removeSlottedObject(int index) {
	// server/zone/objects/scene/components/ContainerComponent.idl():  		slottedObjects.remove(index);
	(&slottedObjects)->remove(index);
}

int ContainerComponentImplementation::getContainerObjectsSize() {
	// server/zone/objects/scene/components/ContainerComponent.idl():  		return containerObjects.size();
	return (&containerObjects)->size();
}

int ContainerComponentImplementation::getSlottedObjectsSize() {
	// server/zone/objects/scene/components/ContainerComponent.idl():  		return slottedObjects.size();
	return (&slottedObjects)->size();
}

bool ContainerComponentImplementation::hasFullContainerObjects() {
	// server/zone/objects/scene/components/ContainerComponent.idl():  		return containerObjects.size() > containerVolumeLimit || containerObjects.size() == containerVolumeLimit;
	return (&containerObjects)->size() > containerVolumeLimit || (&containerObjects)->size() == containerVolumeLimit;
}

int ContainerComponentImplementation::getContainerVolumeLimit() {
	// server/zone/objects/scene/components/ContainerComponent.idl():  		return containerVolumeLimit;
	return containerVolumeLimit;
}

SceneObject* ContainerComponentImplementation::getContainerObject(int idx) {
	// server/zone/objects/scene/components/ContainerComponent.idl():  		return containerObjects.get(idx);
	return (&containerObjects)->get(idx);
}

VectorMap<unsigned long long, ManagedReference<SceneObject* > >* ContainerComponentImplementation::getContainerObjects() {
	// server/zone/objects/scene/components/ContainerComponent.idl():  		return containerObjects;
	return (&containerObjects);
}

bool ContainerComponentImplementation::hasObjectInContainer(unsigned long long objectID) {
	// server/zone/objects/scene/components/ContainerComponent.idl():  		return containerObjects.contains(objectID);
	return (&containerObjects)->contains(objectID);
}

bool ContainerComponentImplementation::hasObjectInSlottedContainer(SceneObject* object) {
	// server/zone/objects/scene/components/ContainerComponent.idl():  		int arrangementSize = object.getArrangementDescriptorSize();
	int arrangementSize = object->getArrangementDescriptorSize();
	// server/zone/objects/scene/components/ContainerComponent.idl():  		SceneObject 
	if (arrangementSize == 0){
	// server/zone/objects/scene/components/ContainerComponent.idl():  			return false;
	return false;
}
	// server/zone/objects/scene/components/ContainerComponent.idl():  		SceneObject obj = slottedObjects.get(object.getArrangementDescriptor(0));
	SceneObject* obj = (&slottedObjects)->get(object->getArrangementDescriptor(0));
	// server/zone/objects/scene/components/ContainerComponent.idl():  		}
	if (object == obj){
	// server/zone/objects/scene/components/ContainerComponent.idl():  			return true;
	return true;
}

	else {
	// server/zone/objects/scene/components/ContainerComponent.idl():  			return false;
	return false;
}
}

SceneObject* ContainerComponentImplementation::getContainerObject(unsigned long long objectID) {
	// server/zone/objects/scene/components/ContainerComponent.idl():  		return containerObjects.get(objectID);
	return (&containerObjects)->get(objectID);
}

void ContainerComponentImplementation::removeAllContainerObjects() {
	// server/zone/objects/scene/components/ContainerComponent.idl():  		containerObjects.removeAll();
	(&containerObjects)->removeAll();
}

void ContainerComponentImplementation::putInContainer(SceneObject* obj, unsigned long long key) {
	// server/zone/objects/scene/components/ContainerComponent.idl():  		containerObjects.put(key, obj);
	(&containerObjects)->put(key, obj);
}

void ContainerComponentImplementation::removeFromContainerObjects(int index) {
	// server/zone/objects/scene/components/ContainerComponent.idl():  		containerObjects.removeElementAt(index);
	(&containerObjects)->removeElementAt(index);
}

void ContainerComponentImplementation::setContainerVolumeLimit(int lim) {
	// server/zone/objects/scene/components/ContainerComponent.idl():  		containerVolumeLimit = lim;
	containerVolumeLimit = lim;
}

void ContainerComponentImplementation::setContainerType(int type) {
	// server/zone/objects/scene/components/ContainerComponent.idl():  		containerType = type;
	containerType = type;
}

unsigned int ContainerComponentImplementation::getContainerType() {
	// server/zone/objects/scene/components/ContainerComponent.idl():  		return containerType;
	return containerType;
}

/*
 *	ContainerComponentAdapter
 */

ContainerComponentAdapter::ContainerComponentAdapter(ContainerComponentImplementation* obj) : SceneObjectComponentAdapter(obj) {
}

Packet* ContainerComponentAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	Packet* resp = new MethodReturnMessage(0);

	switch (methid) {
	case RPC_INITIALIZE__SCENEOBJECT_:
		initialize((SceneObject*) inv->getObjectParameter());
		break;
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		initializeTransientMembers();
		break;
	case RPC_NOTIFYLOADFROMDATABASE__:
		notifyLoadFromDatabase();
		break;
	case RPC_ADDOBJECT__SCENEOBJECT_INT_BOOL_:
		resp->insertBoolean(addObject((SceneObject*) inv->getObjectParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter()));
		break;
	case RPC_REMOVEOBJECT__SCENEOBJECT_BOOL_:
		resp->insertBoolean(removeObject((SceneObject*) inv->getObjectParameter(), inv->getBooleanParameter()));
		break;
	case RPC_CANADDOBJECT__SCENEOBJECT_INT_STRING_:
		resp->insertSignedInt(canAddObject((SceneObject*) inv->getObjectParameter(), inv->getSignedIntParameter(), inv->getAsciiParameter(_param2_canAddObject__SceneObject_int_String_)));
		break;
	case RPC_GETSLOTTEDOBJECT__STRING_:
		resp->insertLong(getSlottedObject(inv->getAsciiParameter(_param0_getSlottedObject__String_))->_getObjectID());
		break;
	case RPC_GETSLOTTEDOBJECT__INT_:
		resp->insertLong(getSlottedObject(inv->getSignedIntParameter())->_getObjectID());
		break;
	case RPC_DROPSLOTTEDOBJECT__STRING_:
		dropSlottedObject(inv->getAsciiParameter(_param0_dropSlottedObject__String_));
		break;
	case RPC_REMOVESLOTTEDOBJECT__INT_:
		removeSlottedObject(inv->getSignedIntParameter());
		break;
	case RPC_GETCONTAINEROBJECTSSIZE__:
		resp->insertSignedInt(getContainerObjectsSize());
		break;
	case RPC_GETSLOTTEDOBJECTSSIZE__:
		resp->insertSignedInt(getSlottedObjectsSize());
		break;
	case RPC_HASFULLCONTAINEROBJECTS__:
		resp->insertBoolean(hasFullContainerObjects());
		break;
	case RPC_GETCONTAINERVOLUMELIMIT__:
		resp->insertSignedInt(getContainerVolumeLimit());
		break;
	case RPC_GETCONTAINEROBJECT__INT_:
		resp->insertLong(getContainerObject(inv->getSignedIntParameter())->_getObjectID());
		break;
	case RPC_HASOBJECTINCONTAINER__LONG_:
		resp->insertBoolean(hasObjectInContainer(inv->getUnsignedLongParameter()));
		break;
	case RPC_HASOBJECTINSLOTTEDCONTAINER__SCENEOBJECT_:
		resp->insertBoolean(hasObjectInSlottedContainer((SceneObject*) inv->getObjectParameter()));
		break;
	case RPC_GETCONTAINEROBJECT__LONG_:
		resp->insertLong(getContainerObject(inv->getUnsignedLongParameter())->_getObjectID());
		break;
	case RPC_REMOVEALLCONTAINEROBJECTS__:
		removeAllContainerObjects();
		break;
	case RPC_PUTINCONTAINER__SCENEOBJECT_LONG_:
		putInContainer((SceneObject*) inv->getObjectParameter(), inv->getUnsignedLongParameter());
		break;
	case RPC_REMOVEFROMCONTAINEROBJECTS__INT_:
		removeFromContainerObjects(inv->getSignedIntParameter());
		break;
	case RPC_SETCONTAINERVOLUMELIMIT__INT_:
		setContainerVolumeLimit(inv->getSignedIntParameter());
		break;
	case RPC_SETCONTAINERTYPE__INT_:
		setContainerType(inv->getSignedIntParameter());
		break;
	case RPC_GETCONTAINERTYPE__:
		resp->insertInt(getContainerType());
		break;
	default:
		return NULL;
	}

	return resp;
}

void ContainerComponentAdapter::initialize(SceneObject* obj) {
	((ContainerComponentImplementation*) impl)->initialize(obj);
}

void ContainerComponentAdapter::initializeTransientMembers() {
	((ContainerComponentImplementation*) impl)->initializeTransientMembers();
}

void ContainerComponentAdapter::notifyLoadFromDatabase() {
	((ContainerComponentImplementation*) impl)->notifyLoadFromDatabase();
}

bool ContainerComponentAdapter::addObject(SceneObject* object, int containmentType, bool notifyClient) {
	return ((ContainerComponentImplementation*) impl)->addObject(object, containmentType, notifyClient);
}

bool ContainerComponentAdapter::removeObject(SceneObject* object, bool notifyClient) {
	return ((ContainerComponentImplementation*) impl)->removeObject(object, notifyClient);
}

int ContainerComponentAdapter::canAddObject(SceneObject* object, int containmentType, String& errorDescription) {
	return ((ContainerComponentImplementation*) impl)->canAddObject(object, containmentType, errorDescription);
}

SceneObject* ContainerComponentAdapter::getSlottedObject(const String& slot) {
	return ((ContainerComponentImplementation*) impl)->getSlottedObject(slot);
}

SceneObject* ContainerComponentAdapter::getSlottedObject(int idx) {
	return ((ContainerComponentImplementation*) impl)->getSlottedObject(idx);
}

void ContainerComponentAdapter::dropSlottedObject(const String& arrengementDescriptor) {
	((ContainerComponentImplementation*) impl)->dropSlottedObject(arrengementDescriptor);
}

void ContainerComponentAdapter::removeSlottedObject(int index) {
	((ContainerComponentImplementation*) impl)->removeSlottedObject(index);
}

int ContainerComponentAdapter::getContainerObjectsSize() {
	return ((ContainerComponentImplementation*) impl)->getContainerObjectsSize();
}

int ContainerComponentAdapter::getSlottedObjectsSize() {
	return ((ContainerComponentImplementation*) impl)->getSlottedObjectsSize();
}

bool ContainerComponentAdapter::hasFullContainerObjects() {
	return ((ContainerComponentImplementation*) impl)->hasFullContainerObjects();
}

int ContainerComponentAdapter::getContainerVolumeLimit() {
	return ((ContainerComponentImplementation*) impl)->getContainerVolumeLimit();
}

SceneObject* ContainerComponentAdapter::getContainerObject(int idx) {
	return ((ContainerComponentImplementation*) impl)->getContainerObject(idx);
}

bool ContainerComponentAdapter::hasObjectInContainer(unsigned long long objectID) {
	return ((ContainerComponentImplementation*) impl)->hasObjectInContainer(objectID);
}

bool ContainerComponentAdapter::hasObjectInSlottedContainer(SceneObject* object) {
	return ((ContainerComponentImplementation*) impl)->hasObjectInSlottedContainer(object);
}

SceneObject* ContainerComponentAdapter::getContainerObject(unsigned long long objectID) {
	return ((ContainerComponentImplementation*) impl)->getContainerObject(objectID);
}

void ContainerComponentAdapter::removeAllContainerObjects() {
	((ContainerComponentImplementation*) impl)->removeAllContainerObjects();
}

void ContainerComponentAdapter::putInContainer(SceneObject* obj, unsigned long long key) {
	((ContainerComponentImplementation*) impl)->putInContainer(obj, key);
}

void ContainerComponentAdapter::removeFromContainerObjects(int index) {
	((ContainerComponentImplementation*) impl)->removeFromContainerObjects(index);
}

void ContainerComponentAdapter::setContainerVolumeLimit(int lim) {
	((ContainerComponentImplementation*) impl)->setContainerVolumeLimit(lim);
}

void ContainerComponentAdapter::setContainerType(int type) {
	((ContainerComponentImplementation*) impl)->setContainerType(type);
}

unsigned int ContainerComponentAdapter::getContainerType() {
	return ((ContainerComponentImplementation*) impl)->getContainerType();
}

/*
 *	ContainerComponentHelper
 */

ContainerComponentHelper* ContainerComponentHelper::staticInitializer = ContainerComponentHelper::instance();

ContainerComponentHelper::ContainerComponentHelper() {
	className = "ContainerComponent";

	Core::getObjectBroker()->registerClass(className, this);
}

void ContainerComponentHelper::finalizeHelper() {
	ContainerComponentHelper::finalize();
}

DistributedObject* ContainerComponentHelper::instantiateObject() {
	return new ContainerComponent(DummyConstructorParameter::instance());
}

DistributedObjectServant* ContainerComponentHelper::instantiateServant() {
	return new ContainerComponentImplementation(DummyConstructorParameter::instance());
}

DistributedObjectAdapter* ContainerComponentHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new ContainerComponentAdapter((ContainerComponentImplementation*) obj->_getImplementation());

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

