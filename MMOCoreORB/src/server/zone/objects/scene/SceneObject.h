/*
 *	server/zone/objects/scene/SceneObject.h generated by engine3 IDL compiler 0.60
 */

#ifndef SCENEOBJECT_H_
#define SCENEOBJECT_H_

#include "engine/orb/DistributedObjectBroker.h"

class Zone;

class ZoneClientSession;

class ZoneProcessServerImplementation;

class ProfessionManager;

class PlanetManager;

class UndeploySceneObjectEvent;

class DamageDone;

class SceneObjectReference;

class ItemAttributes;

class CustomizationVariables;

class CreatureObject;

class Player;

class BuildingObject;

class GroupObject;

class ObjectMenuResponse;

class AttributeListMessage;

#include "system/lang/System.h"

#include "system/lang/Math.h"

#include "system/io/Serializable.h"

#include "system/util/Vector.h"

#include "system/util/VectorMap.h"

#include "engine/log/Logger.h"

#include "engine/core/ManagedReference.h"

#include "engine/util/Coordinate.h"

#include "engine/util/QuadTreeEntry.h"

#include "engine/service/proto/BaseMessage.h"

#include "engine/service/proto/StandaloneBaseMessage.h"

#include "engine/core/ManagedObject.h"

#include "server/zone/objects/scene/ContainerObject.h"

namespace server {
namespace zone {
namespace objects {
namespace scene {

class SceneObject : public ManagedObject {
public:
	SceneObject();

	SceneObject(unsigned long long oid, int type);

	bool destroy();

	void redeploy();

	void scheduleUndeploy();

	void undeploy();

	void removeUndeploymentEvent();

	void create(ZoneClientSession* client);

	void destroy(ZoneClientSession* client);

	void link(ZoneClientSession* client, SceneObject* obj);

	BaseMessage* link(SceneObject* obj, unsigned int type);

	BaseMessage* link(SceneObject* obj);

	BaseMessage* link(unsigned long long container, unsigned int type);

	void close(ZoneClientSession* client);

	void init();

	void initScriptedValues();

	void insertToZone(Zone* zone);

	void insertToBuilding(BuildingObject* building);

	void removeFromZone(bool doLock = true);

	void removeFromBuilding(BuildingObject* building);

	void addDamageDone(CreatureObject* creature, int damage, string& skillname);

	void dropDamageDone(CreatureObject* creature);

	int getTotalDamage();

	void disseminateXp(int levels);

	void cleanupDamageDone();

	void broadcastMessage(BaseMessage* msg, int range = 128, bool doLock = true, bool sendSelf = true);

	void broadcastMessage(StandaloneBaseMessage* msg, int range = 128, bool doLock = true);

	void broadcastMessages(Vector<BaseMessage* >* msgs, int range = 128, bool doLock = true);

	void sendTo(Player* player, bool doClose = true);

	void sendDestroyTo(Player* player);

	void notifyInsert(QuadTreeEntry* obj);

	void notifyDissapear(QuadTreeEntry* obj);

	void sendConversationStartTo(SceneObject* obj);

	void selectConversationOption(int option, SceneObject* obj);

	void sendConversationStopTo(SceneObject* obj);

	void sendRadialResponseTo(Player* player, ObjectMenuResponse* omr);

	int useObject(Player* player);

	void generateAttributes(SceneObject* obj);

	void addAttributes(AttributeListMessage* alm);

	void parseItemAttributes();

	void synchronizedUIListen(Player* player, int value);

	void synchronizedUIStopListen(Player* player, int value);

	void randomizePosition(float radius);

	void lock(bool doLock = true);

	void lock(ManagedObject* obj);

	void wlock(bool doLock = true);

	void wlock(ManagedObject* obj);

	void unlock(bool doLock = true);

	void setLockName(const string& name);

	void setMovementCounter(unsigned int cnt);

	void switchMovingState();

	unsigned int returnMovementCounter();

	void increaseMovementCounter();

	void setCustomizationString(const string& cust);

	void setCustomizationVariable(byte type, unsigned short value);

	void setCustomizationVariable(const string& type, byte value);

	void setNorthDirection();

	void setSouthDirection();

	void setWestDirection();

	void setEastDirection();

	void setDirection(float angle);

	void setRadialDirection(float radangle);

	void setDirection(float x, float z, float y, float w);

	void setPersistent(bool pers);

	void setUpdated(bool upd);

	void setDeleted(bool del);

	Coordinate* getCoordinate(float x, float y, float distance, float angle);

	Coordinate* getCoordinate(SceneObject* object, float distance, float angle);

	Coordinate* getCoordinate(SceneObject* object1, SceneObject* object2, float distanceFromObject1);

	bool isInRange(SceneObject* obj, float range);

	bool isInRange(float x, float y, float range);

	ZoneProcessServerImplementation* getZoneProcessServer();

	bool isPlayer();

	bool isNonPlayerCreature();

	bool isPlayerInventory();

	bool isPlayerBankStorage();

	bool isBuilding();

	bool isCell();

	bool isTangible();

	bool isIntangible();

	bool isStatic();

	bool isShip();

	bool isAttackable();

	bool isMission();

	bool isPlayerObject();

	bool isWaypoint();

	bool isManufactureSchematic();

	int compareTo(SceneObject* obj);

	void setParent(SceneObject* par, unsigned int linktype = 04);

	void setZoneProcessServer(ZoneProcessServerImplementation* server);

	void setZone(Zone* zone);

	void setZoneIndex(int id);

	void setObjectID(unsigned long long oid);

	void setObjectCRC(unsigned int crc);

	void setObjectType(int tp);

	void setObjectKeeping(bool keeping);

	void clearUndeploymentEvent();

	bool isUndeploymentScheduled();

	void setAssociatedArea(unsigned long long uid);

	Zone* getZone();

	int getZoneID();

	unsigned long long getObjectID();

	unsigned int getObjectCRC();

	int getObjectType();

	unsigned int getMovementCounter();

	bool isMoving();

	float getPositionX();

	float getPositionZ();

	float getPositionY();

	float getDirectionX();

	float getDirectionZ();

	float getDirectionY();

	float getDirectionW();

	byte getDirectionAngle();

	float getPrecisionDirectionAngle();

	SceneObject* getParent();

	QuadTreeEntry* getQuadTreeEntry();

	unsigned long long getParentID();

	unicode& getCustomName();

	void setCustomName(const string& name);

	void setCustomName(const unicode& name);

	void setStfName(const string& name);

	string& getStfName();

	void setStfFile(const string& file);

	string& getStfFile();

	void setStfDetail(const string& detail);

	string& getStfDetail();

	float getPrecision(float num, int digits);

	void getCustomizationString(string& appearance);

	bool isPersistent();

	bool isUpdated();

	bool isDeleted();

	void setAttributes(string& attributeString);

	string& getAttributes();

	unsigned long long getAssociatedArea();

	bool doKeepObject();

	void setDefender(SceneObject* defender);

	void addDefender(SceneObject* defender);

	void removeDefender(SceneObject* defender);

	void removeDefenders();

	bool hasDefender(SceneObject* defender);

	void setCombatState();

	void clearCombatState(bool removeDefenders = true);

	SceneObject* getDefender(int idx);

	bool isPeaced();

	unsigned int getDefenderListSize();

	bool isAttackableBy(CreatureObject* creature);

	bool isInANoBuildArea();

	void onIncapacitateTarget(CreatureObject* victim);

	void onInflictDamage(CreatureObject* victim, byte attribute, unsigned int damage);

	void onKill(CreatureObject* victim);

	void onDeathblow(Player* victim);

	void onResuscitateTarget(CreatureObject* patient);

	void onHealTargetDamage(CreatureObject* patient, byte attribute, unsigned int amount);

	void onHealTargetWound(CreatureObject* patient, byte attribute, unsigned int amount);

	void onHealEnhanceTarget(CreatureObject* patient, byte attribute, unsigned int amount, float duration);

	void onReceivePaymentFrom(CreatureObject* sender, unsigned int amount);

	void onTrade(Player* sender, Player* receiver);

	bool inflictDamage(CreatureObject* victim, byte attribute, unsigned int damage);

	void incapacitate(CreatureObject* victim);

	void kill(CreatureObject* victim);

	void deathblow(Player* victim);

	void resuscitate(CreatureObject* patient, bool forced = false);

	unsigned int healDamage(CreatureObject* patient, byte attribute, unsigned int amount);

	unsigned int healWound(CreatureObject* patient, byte attribute, unsigned int amount);

	unsigned int healEnhance(CreatureObject* patient, byte attribute, unsigned int amount, float duration);

	void receivePaymentFrom(CreatureObject* sender, unsigned int amount);

	void warpTo(float x, float z, float y, unsigned long long parentID = 0);

	float calculateDistance(SceneObject* scno);

	bool getPickupFlag();

	void setPickupFlag(bool pickup);

	void addSerializableVariables();

protected:
	SceneObject(DummyConstructorParameter* param);

	virtual ~SceneObject();

	string _return_getAttributes;
	string _return_getStfDetail;
	string _return_getStfFile;
	string _return_getStfName;

	unicode _return_getCustomName;

	friend class SceneObjectHelper;
};

} // namespace scene
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::scene;

#include "engine/core/ManagedObjectImplementation.h"

namespace server {
namespace zone {
namespace objects {
namespace scene {

class SceneObjectImplementation : public ManagedObjectImplementation, public ContainerObject, public QuadTreeEntry, public Logger, public Serializable {
protected:
	ZoneProcessServerImplementation* server;

	Zone* zone;

	int objectType;

	unsigned int objectCRC;

	unicode& customName;

	string& stfFile;

	string& stfName;

	string& stfDetail;

	int zoneID;

	string& attributeString;

	CustomizationVariables* customizationVariables;

	ItemAttributes* itemAttributes;

	unsigned int movementCounter;

	bool moving;

	bool persistent;

	bool updated;

	bool deleted;

	float directionX;

	float directionZ;

	float directionY;

	float directionW;

	byte directionAngle;

	float precisionDirectionAngle;

	SceneObject* parent;

	unsigned int linkType;

	UndeploySceneObjectEvent* undeployEvent;

	bool keepObject;

	bool canPickup;

	unsigned long long associatedArea;

	bool attackable;

	VectorMap<GroupObject*, int >* groupDamageList;

	VectorMap<ManagedReference<CreatureObject* >, DamageDone* >* playerDamageList;

public:
	static const int NONPLAYERCREATURE = 1;

	static const int PLAYER = 2;

	static const int TANGIBLE = 3;

	static const int GROUP = 4;

	static const int BUILDING = 5;

	static const int CELL = 6;

	static const int INTANGIBLE = 7;

	static const int STATIC = 8;

	static const int SHIP = 9;

	static const int ATTACKABLE = 10;

	static const int MISSION = 11;

	static const int PLAYEROBJECT = 12;

	static const int WAYPOINT = 13;

	static const int MANUFACTURESCHEMATIC = 14;

	static const int CAMPSITE = 15;

	static const int INVENTORYOBJECT = 16;

	static const int BANKINVENTORYSTORAGE = 17;

	static const int NONATTACKABLEBITMASK = 1000;

	static const int CREOBITMASK = 80;

	SceneObjectImplementation();

	SceneObjectImplementation(unsigned long long oid, int type);

	bool destroy();

	void redeploy();

	void scheduleUndeploy();

	void undeploy();

	void removeUndeploymentEvent();

	void create(ZoneClientSession* client);

	void destroy(ZoneClientSession* client);

	void link(ZoneClientSession* client, SceneObject* obj);

	BaseMessage* link(SceneObject* obj, unsigned int type);

	BaseMessage* link(SceneObject* obj);

	BaseMessage* link(unsigned long long container, unsigned int type);

	void close(ZoneClientSession* client);

	void init();

	virtual void initScriptedValues();

	virtual void insertToZone(Zone* zone);

	virtual void insertToBuilding(BuildingObject* building);

	virtual void removeFromZone(bool doLock = true);

	virtual void removeFromBuilding(BuildingObject* building);

	void addDamageDone(CreatureObject* creature, int damage, string& skillname);

	void dropDamageDone(CreatureObject* creature);

private:
	int getTotalDamage();

public:
	void disseminateXp(int levels);

	void cleanupDamageDone();

	void broadcastMessage(BaseMessage* msg, int range = 128, bool doLock = true, bool sendSelf = true);

	void broadcastMessage(StandaloneBaseMessage* msg, int range = 128, bool doLock = true);

	void broadcastMessages(Vector<BaseMessage* >* msgs, int range = 128, bool doLock = true);

	virtual void sendTo(Player* player, bool doClose = true);

	virtual void sendDestroyTo(Player* player);

	virtual void notifyInsert(QuadTreeEntry* obj);

	virtual void notifyDissapear(QuadTreeEntry* obj);

	virtual void sendConversationStartTo(SceneObject* obj);

	virtual void selectConversationOption(int option, SceneObject* obj);

	virtual void sendConversationStopTo(SceneObject* obj);

	virtual void sendRadialResponseTo(Player* player, ObjectMenuResponse* omr);

	virtual int useObject(Player* player);

	virtual void generateAttributes(SceneObject* obj);

	virtual void addAttributes(AttributeListMessage* alm);

	virtual void parseItemAttributes();

	virtual void synchronizedUIListen(Player* player, int value);

	virtual void synchronizedUIStopListen(Player* player, int value);

	void randomizePosition(float radius);

	void lock(bool doLock = true);

	void lock(ManagedObject* obj);

	void wlock(bool doLock = true);

	void wlock(ManagedObject* obj);

	void unlock(bool doLock = true);

	void setLockName(const string& name);

	void setMovementCounter(unsigned int cnt);

	void switchMovingState();

private:
	unsigned int returnMovementCounter();

public:
	void increaseMovementCounter();

	void setCustomizationString(const string& cust);

	void setCustomizationVariable(byte type, unsigned short value);

	void setCustomizationVariable(const string& type, byte value);

	void setNorthDirection();

	void setSouthDirection();

	void setWestDirection();

	void setEastDirection();

	void setDirection(float angle);

	void setRadialDirection(float radangle);

	void setDirection(float x, float z, float y, float w);

	void setPersistent(bool pers);

	void setUpdated(bool upd);

	void setDeleted(bool del);

	Coordinate* getCoordinate(float x, float y, float distance, float angle);

	Coordinate* getCoordinate(SceneObject* object, float distance, float angle);

	Coordinate* getCoordinate(SceneObject* object1, SceneObject* object2, float distanceFromObject1);

	bool isInRange(SceneObject* obj, float range);

	bool isInRange(float x, float y, float range);

	ZoneProcessServerImplementation* getZoneProcessServer();

	bool isPlayer();

	bool isNonPlayerCreature();

	bool isPlayerInventory();

	bool isPlayerBankStorage();

	bool isBuilding();

	bool isCell();

	bool isTangible();

	bool isIntangible();

	bool isStatic();

	bool isShip();

	bool isAttackable();

	bool isMission();

	bool isPlayerObject();

	bool isWaypoint();

	bool isManufactureSchematic();

	int compareTo(SceneObject* obj);

	void setParent(SceneObject* par, unsigned int linktype = 04);

	void setZoneProcessServer(ZoneProcessServerImplementation* server);

	void setZone(Zone* zone);

	void setZoneIndex(int id);

	void setObjectID(unsigned long long oid);

	void setObjectCRC(unsigned int crc);

	void setObjectType(int tp);

	void setObjectKeeping(bool keeping);

	void clearUndeploymentEvent();

	bool isUndeploymentScheduled();

	void setAssociatedArea(unsigned long long uid);

	Zone* getZone();

	int getZoneID();

	unsigned long long getObjectID();

	unsigned int getObjectCRC();

	int getObjectType();

	unsigned int getMovementCounter();

	bool isMoving();

	float getPositionX();

	float getPositionZ();

	float getPositionY();

	float getDirectionX();

	float getDirectionZ();

	float getDirectionY();

	float getDirectionW();

	byte getDirectionAngle();

	float getPrecisionDirectionAngle();

	SceneObject* getParent();

	QuadTreeEntry* getQuadTreeEntry();

	unsigned long long getParentID();

	unicode& getCustomName();

	void setCustomName(const string& name);

	void setCustomName(const unicode& name);

	void setStfName(const string& name);

	string& getStfName();

	void setStfFile(const string& file);

	string& getStfFile();

	void setStfDetail(const string& detail);

	string& getStfDetail();

	float getPrecision(float num, int digits);

	void getCustomizationString(string& appearance);

	bool isPersistent();

	bool isUpdated();

	bool isDeleted();

	void setAttributes(string& attributeString);

	string& getAttributes();

	unsigned long long getAssociatedArea();

	bool doKeepObject();

	virtual void setDefender(SceneObject* defender);

	virtual void addDefender(SceneObject* defender);

	virtual void removeDefender(SceneObject* defender);

	virtual void removeDefenders();

	virtual bool hasDefender(SceneObject* defender);

	virtual void setCombatState();

	virtual void clearCombatState(bool removeDefenders = true);

	virtual SceneObject* getDefender(int idx);

	virtual bool isPeaced();

	virtual unsigned int getDefenderListSize();

	virtual bool isAttackableBy(CreatureObject* creature);

	bool isInANoBuildArea();

	virtual void onIncapacitateTarget(CreatureObject* victim);

	virtual void onInflictDamage(CreatureObject* victim, byte attribute, unsigned int damage);

	virtual void onKill(CreatureObject* victim);

	virtual void onDeathblow(Player* victim);

	virtual void onResuscitateTarget(CreatureObject* patient);

	virtual void onHealTargetDamage(CreatureObject* patient, byte attribute, unsigned int amount);

	virtual void onHealTargetWound(CreatureObject* patient, byte attribute, unsigned int amount);

	virtual void onHealEnhanceTarget(CreatureObject* patient, byte attribute, unsigned int amount, float duration);

	virtual void onReceivePaymentFrom(CreatureObject* sender, unsigned int amount);

	virtual void onTrade(Player* sender, Player* receiver);

	virtual bool inflictDamage(CreatureObject* victim, byte attribute, unsigned int damage);

	virtual void incapacitate(CreatureObject* victim);

	virtual void kill(CreatureObject* victim);

	virtual void deathblow(Player* victim);

	virtual void resuscitate(CreatureObject* patient, bool forced = false);

	virtual unsigned int healDamage(CreatureObject* patient, byte attribute, unsigned int amount);

	virtual unsigned int healWound(CreatureObject* patient, byte attribute, unsigned int amount);

	virtual unsigned int healEnhance(CreatureObject* patient, byte attribute, unsigned int amount, float duration);

	virtual void receivePaymentFrom(CreatureObject* sender, unsigned int amount);

	virtual void warpTo(float x, float z, float y, unsigned long long parentID = 0);

private:
	float calculateDistance(SceneObject* scno);

public:
	virtual bool getPickupFlag();

	virtual void setPickupFlag(bool pickup);

private:
	void addSerializableVariables();

public:
	SceneObject* _this;

protected:
	virtual ~SceneObjectImplementation();

	void _setStub(DistributedObjectStub* stub);
	DistributedObjectStub* _getStub();
};

class SceneObjectAdapter : public ManagedObjectAdapter {
public:
	SceneObjectAdapter(SceneObjectImplementation* impl);

	Packet* invokeMethod(sys::uint32 methid, DistributedMethod* method);

	void finalize();

	bool destroy();

	void redeploy();

	void scheduleUndeploy();

	void undeploy();

	void removeUndeploymentEvent();

	void create(ZoneClientSession* client);

	void destroy(ZoneClientSession* client);

	void link(ZoneClientSession* client, SceneObject* obj);

	BaseMessage* link(SceneObject* obj, unsigned int type);

	BaseMessage* link(SceneObject* obj);

	BaseMessage* link(unsigned long long container, unsigned int type);

	void close(ZoneClientSession* client);

	void init();

	void initScriptedValues();

	void insertToZone(Zone* zone);

	void insertToBuilding(BuildingObject* building);

	void removeFromZone(bool doLock);

	void removeFromBuilding(BuildingObject* building);

	void addDamageDone(CreatureObject* creature, int damage, string& skillname);

	void dropDamageDone(CreatureObject* creature);

	int getTotalDamage();

	void disseminateXp(int levels);

	void cleanupDamageDone();

	void broadcastMessage(BaseMessage* msg, int range, bool doLock, bool sendSelf);

	void broadcastMessage(StandaloneBaseMessage* msg, int range, bool doLock);

	void broadcastMessages(Vector<BaseMessage* >* msgs, int range, bool doLock);

	void sendTo(Player* player, bool doClose);

	void sendDestroyTo(Player* player);

	void notifyInsert(QuadTreeEntry* obj);

	void notifyDissapear(QuadTreeEntry* obj);

	void sendConversationStartTo(SceneObject* obj);

	void selectConversationOption(int option, SceneObject* obj);

	void sendConversationStopTo(SceneObject* obj);

	void sendRadialResponseTo(Player* player, ObjectMenuResponse* omr);

	int useObject(Player* player);

	void generateAttributes(SceneObject* obj);

	void addAttributes(AttributeListMessage* alm);

	void parseItemAttributes();

	void synchronizedUIListen(Player* player, int value);

	void synchronizedUIStopListen(Player* player, int value);

	void randomizePosition(float radius);

	void lock(bool doLock);

	void lock(ManagedObject* obj);

	void wlock(bool doLock);

	void wlock(ManagedObject* obj);

	void unlock(bool doLock);

	void setLockName(const string& name);

	void setMovementCounter(unsigned int cnt);

	void switchMovingState();

	unsigned int returnMovementCounter();

	void increaseMovementCounter();

	void setCustomizationString(const string& cust);

	void setCustomizationVariable(byte type, unsigned short value);

	void setCustomizationVariable(const string& type, byte value);

	void setNorthDirection();

	void setSouthDirection();

	void setWestDirection();

	void setEastDirection();

	void setDirection(float angle);

	void setRadialDirection(float radangle);

	void setDirection(float x, float z, float y, float w);

	void setPersistent(bool pers);

	void setUpdated(bool upd);

	void setDeleted(bool del);

	Coordinate* getCoordinate(float x, float y, float distance, float angle);

	Coordinate* getCoordinate(SceneObject* object, float distance, float angle);

	Coordinate* getCoordinate(SceneObject* object1, SceneObject* object2, float distanceFromObject1);

	bool isInRange(SceneObject* obj, float range);

	bool isInRange(float x, float y, float range);

	ZoneProcessServerImplementation* getZoneProcessServer();

	bool isPlayer();

	bool isNonPlayerCreature();

	bool isPlayerInventory();

	bool isPlayerBankStorage();

	bool isBuilding();

	bool isCell();

	bool isTangible();

	bool isIntangible();

	bool isStatic();

	bool isShip();

	bool isAttackable();

	bool isMission();

	bool isPlayerObject();

	bool isWaypoint();

	bool isManufactureSchematic();

	int compareTo(SceneObject* obj);

	void setParent(SceneObject* par, unsigned int linktype);

	void setZoneProcessServer(ZoneProcessServerImplementation* server);

	void setZone(Zone* zone);

	void setZoneIndex(int id);

	void setObjectID(unsigned long long oid);

	void setObjectCRC(unsigned int crc);

	void setObjectType(int tp);

	void setObjectKeeping(bool keeping);

	void clearUndeploymentEvent();

	bool isUndeploymentScheduled();

	void setAssociatedArea(unsigned long long uid);

	Zone* getZone();

	int getZoneID();

	unsigned long long getObjectID();

	unsigned int getObjectCRC();

	int getObjectType();

	unsigned int getMovementCounter();

	bool isMoving();

	float getPositionX();

	float getPositionZ();

	float getPositionY();

	float getDirectionX();

	float getDirectionZ();

	float getDirectionY();

	float getDirectionW();

	byte getDirectionAngle();

	float getPrecisionDirectionAngle();

	SceneObject* getParent();

	QuadTreeEntry* getQuadTreeEntry();

	unsigned long long getParentID();

	unicode& getCustomName();

	void setCustomName(const string& name);

	void setCustomName(const unicode& name);

	void setStfName(const string& name);

	string& getStfName();

	void setStfFile(const string& file);

	string& getStfFile();

	void setStfDetail(const string& detail);

	string& getStfDetail();

	float getPrecision(float num, int digits);

	void getCustomizationString(string& appearance);

	bool isPersistent();

	bool isUpdated();

	bool isDeleted();

	void setAttributes(string& attributeString);

	string& getAttributes();

	unsigned long long getAssociatedArea();

	bool doKeepObject();

	void setDefender(SceneObject* defender);

	void addDefender(SceneObject* defender);

	void removeDefender(SceneObject* defender);

	void removeDefenders();

	bool hasDefender(SceneObject* defender);

	void setCombatState();

	void clearCombatState(bool removeDefenders);

	SceneObject* getDefender(int idx);

	bool isPeaced();

	unsigned int getDefenderListSize();

	bool isAttackableBy(CreatureObject* creature);

	bool isInANoBuildArea();

	void onIncapacitateTarget(CreatureObject* victim);

	void onInflictDamage(CreatureObject* victim, byte attribute, unsigned int damage);

	void onKill(CreatureObject* victim);

	void onDeathblow(Player* victim);

	void onResuscitateTarget(CreatureObject* patient);

	void onHealTargetDamage(CreatureObject* patient, byte attribute, unsigned int amount);

	void onHealTargetWound(CreatureObject* patient, byte attribute, unsigned int amount);

	void onHealEnhanceTarget(CreatureObject* patient, byte attribute, unsigned int amount, float duration);

	void onReceivePaymentFrom(CreatureObject* sender, unsigned int amount);

	void onTrade(Player* sender, Player* receiver);

	bool inflictDamage(CreatureObject* victim, byte attribute, unsigned int damage);

	void incapacitate(CreatureObject* victim);

	void kill(CreatureObject* victim);

	void deathblow(Player* victim);

	void resuscitate(CreatureObject* patient, bool forced);

	unsigned int healDamage(CreatureObject* patient, byte attribute, unsigned int amount);

	unsigned int healWound(CreatureObject* patient, byte attribute, unsigned int amount);

	unsigned int healEnhance(CreatureObject* patient, byte attribute, unsigned int amount, float duration);

	void receivePaymentFrom(CreatureObject* sender, unsigned int amount);

	void warpTo(float x, float z, float y, unsigned long long parentID);

	float calculateDistance(SceneObject* scno);

	bool getPickupFlag();

	void setPickupFlag(bool pickup);

	void addSerializableVariables();

protected:
	string _param2_addDamageDone__CreatureObject_int_string_;
	string _param0_setLockName__string_;
	string _param0_setCustomizationString__string_;
	string _param0_setCustomizationVariable__string_byte_;
	string _param0_setCustomName__string_;
	unicode _param0_setCustomName__unicode_;
	string _param0_setStfName__string_;
	string _param0_setStfFile__string_;
	string _param0_setStfDetail__string_;
	string _param0_getCustomizationString__string_;
	string _param0_setAttributes__string_;
};

class SceneObjectHelper : public DistributedObjectClassHelper, public Singleton<SceneObjectHelper> {
	static SceneObjectHelper* staticInitializer;

public:
	SceneObjectHelper();

	void finalizeHelper();

	DistributedObject* instantiateObject();

	DistributedObjectAdapter* createAdapter(DistributedObjectStub* obj);

	friend class Singleton<SceneObjectHelper>;
};

} // namespace scene
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::scene;

#endif /*SCENEOBJECT_H_*/
