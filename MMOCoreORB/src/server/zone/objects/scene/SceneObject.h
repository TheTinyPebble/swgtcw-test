/*
 *	server/zone/objects/scene/SceneObject.h generated by engine3 IDL compiler 0.60
 */

#ifndef SCENEOBJECT_H_
#define SCENEOBJECT_H_

#include "engine/core/Core.h"

#include "engine/core/ManagedReference.h"

#include "engine/core/ManagedWeakReference.h"

namespace server {
namespace zone {
namespace managers {
namespace objectcontroller {

class ObjectController;

} // namespace objectcontroller
} // namespace managers
} // namespace zone
} // namespace server

using namespace server::zone::managers::objectcontroller;

namespace server {
namespace zone {

class ZoneProcessServer;

} // namespace zone
} // namespace server

using namespace server::zone;

namespace server {
namespace zone {

class ZoneClientSession;

} // namespace zone
} // namespace server

using namespace server::zone;

namespace server {
namespace zone {

class Zone;

} // namespace zone
} // namespace server

using namespace server::zone;

namespace server {
namespace zone {

class ZoneServer;

} // namespace zone
} // namespace server

using namespace server::zone;

namespace server {
namespace zone {
namespace objects {
namespace building {

class BuildingObject;

} // namespace building
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::building;

namespace server {
namespace zone {
namespace packets {
namespace object {

class ObjectMenuResponse;

} // namespace object
} // namespace packets
} // namespace zone
} // namespace server

using namespace server::zone::packets::object;

namespace server {
namespace zone {
namespace objects {
namespace creature {

class CreatureObject;

} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature;

namespace server {
namespace zone {
namespace packets {
namespace scene {

class AttributeListMessage;

} // namespace scene
} // namespace packets
} // namespace zone
} // namespace server

using namespace server::zone::packets::scene;

namespace server {
namespace zone {
namespace templates {

class SharedObjectTemplate;

} // namespace templates
} // namespace zone
} // namespace server

using namespace server::zone::templates;

namespace server {
namespace zone {
namespace objects {
namespace area {

class ActiveArea;

} // namespace area
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::area;

namespace server {
namespace zone {
namespace objects {
namespace region {

class CityRegion;

} // namespace region
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::region;

namespace server {
namespace zone {
namespace objects {
namespace creature {

class CreatureObject;

} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature;

#include "gmock/gmock.h"

#include "engine/core/ManagedObject.h"

#include "engine/util/Facade.h"

#include "server/zone/objects/scene/ObserverEventType.h"

#include "server/zone/ZoneReference.h"

#include "server/zone/objects/scene/SceneObjectType.h"

#include "server/zone/objects/scene/variables/StringId.h"

#include "server/zone/objects/scene/TransferErrorCode.h"

#include "server/zone/objects/scene/variables/PendingTasksMap.h"

#include "server/zone/objects/scene/SessionFacadeType.h"

#include "server/zone/objects/scene/ObserverType.h"

#include "server/zone/managers/templates/PlanetMapCategory.h"

#include "server/zone/managers/templates/TemplateManager.h"

#include "server/zone/objects/scene/components/ZoneComponent.h"

#include "server/zone/objects/scene/components/ObjectMenuComponent.h"

#include "server/zone/objects/scene/components/ContainerComponent.h"

#include "server/zone/objects/scene/components/AttributeListComponent.h"

#include "server/zone/objects/scene/components/DataObjectComponentReference.h"

#include "server/zone/objects/scene/variables/ContainerPermissions.h"

#include "server/zone/objects/scene/variables/ContainerObjectsMap.h"

#include "engine/log/Logger.h"

#include "engine/core/ManagedReference.h"

#include "engine/util/u3d/Coordinate.h"

#include "engine/util/u3d/QuadTreeEntry.h"

#include "system/io/Serializable.h"

#include "engine/lua/Lua.h"

#include "engine/lua/LuaObject.h"

#include "system/util/Vector.h"

#include "system/util/VectorMap.h"

#include "engine/util/u3d/Quaternion.h"

#include "engine/service/proto/BasePacket.h"

#include "engine/service/proto/BaseMessage.h"

#include "system/util/SortedVector.h"

#include "system/lang/StackTrace.h"

#include "system/lang/ref/Reference.h"

#include "engine/core/Task.h"

#include "engine/util/u3d/Vector3.h"

#include "engine/util/Observable.h"

#include "engine/util/Observer.h"

#include "engine/util/u3d/Matrix4.h"

#include "system/thread/ReadWriteLock.h"

#include "system/thread/Mutex.h"

namespace server {
namespace zone {
namespace objects {
namespace scene {

class SceneObject : public QuadTreeEntry {
public:
	/**
	 * SceneObject constructor, used to initialize the object.
	 * @pre { templateData is a valid SharedObjectTemplate LuaObject that contains the necessary values to initialize SceneObject }
	 * @post { SceneObject is initialized } 
	 * @param templateData templateData points to the SharedObjectTemplate LuaObject that is used to initialize SceneObejct members 
	 */
	SceneObject();

	void initializePrivateData();

	/**
	 * Reads and sets the template data from a SharedObjectTemplate LuaObject
	 * @pre { templateData is a valid pointer }
	 * @post { SceneObject members are initialized }
	 * @param templateData templateData points to the LuaObject that is used to initialize SceneObejct members
	 */
	void loadTemplateData(SharedObjectTemplate* templateData);

	void createComponents();

	void createContainerComponent();

	/**
	 * Initializes the transient members of SceneObject, must call the inherited object method first.
	 * @pre {transient members are not initialized }
	 * @post { transient members are initialized }
	 */
	void initializeTransientMembers();

	/**
	 * Gets called when this objects is loaded from database
	 * @pre { this locked }
	 * @post { this locked }
	 */
	void notifyLoadFromDatabase();

	/**
	 * Logs an info message
	 * @pre {}
	 * @post { message has been printed to console or file }
	 * @param msg message to print
	 * @param forced if true, always prints the message to console 
	 */
	void info(const String& msg, bool forced = false);

	/**
	 * Logs an error message
	 * @pre {}
	 * @post {error message has been printed to console and file }
	 * @param msg error message to print
	 */
	void error(const String& msg);

	/**
	 * Returns number of specified game objects in range
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return number of objects in range
	 */
	int inRangeObjects(unsigned int gameObjectType, float range);

	/**
	 * Evaluates if the object is in range
	 * @pre { this object is locked, obj is locked}
	 * @post { thisobject is locked, obj is locked }
	 * @param obj object that will be checked against
	 * @param range range to check
	 * @return returns true if this object is in range with obj
	 */
	bool isInRange(SceneObject* obj, float range);

	/**
	 * Tries to add/link object
	 * @pre { this object is locked, object is locked }
	 * @post {this object is locked, object is locked }
	 * @param object SceneObject that will be added to the current object
	 * @param containmentType arrangement type that will be used to add the object
	 * @param notifyClient if true in range objects will be updated with the change
	 * @return returns true if the object has been successfully added
	 */
	bool transferObject(SceneObject* object, int containmentType, bool notifyClient = false, bool allowOverflow = false);

	/**
	 * Tries to remove/unlink object
	 * @pre { this object is locked, object is locked }
	 * @post {this object is locked, object is locked }
	 * @param object SceneObject that will be removed from the current object
	 * @param destination SceneObject that will be the new destination of the object.
	 * @param notifyClient not used currently
	 * @return returns true if the object has been successfully removed
	 */
	bool removeObject(SceneObject* object, SceneObject* destination, bool notifyClient = false);

	/**
	 * Destroys the object from the world
	 */
	void destroyObjectFromWorld(bool sendSelfDestroy);

	/**
	 * Evaluates if this object has the necessary free slots to be able to add the specified SceneObject
	 * @pre { this object is locked, object is locked }
	 * @post {this object is locked, object is locked }
	 * @param object SceneObject that will be checked
	 * @param error error string that the player will receive on error
	 * @return returns 0 on success, or error code
	 */
	int canAddObject(SceneObject* object, int containmentType, String& errorDescription);

	/**
	 * 
	 */
	int notifyObjectInsertedToChild(SceneObject* object, SceneObject* child, SceneObject* oldParent);

	int notifyObjectRemovedFromChild(SceneObject* object, SceneObject* child);

	/**
	 * Calls the appropriate UI Listener Function
	 * @pre { this object is locked, object is locked }
	 * @post {this object is locked, object is locked }
	 * @param player CreatureObject using the item
	 * @param value value from packet
	 */
	void synchronizedUIListen(SceneObject* player, int value);

	/**
	 * Calls the appropriate UI Stop Listener Function
	 * @pre { this object is locked, object is locked }
	 * @post {this object is locked, object is locked }
	 * @param player CreatureObject using the item
	 * @param value value from packet
	 */
	void synchronizedUIStopListen(SceneObject* player, int value);

	/**
	 * Updates this object to database (calls updatesToDatabaseAllObjects())
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param startTask if true, queues a new update task
	 */
	void updateToDatabase();

	/**
	  * Updates only this object to database without updating children
	  * WARNING use only when necessary
	  */
	void updateToDatabaseWithoutChildren();

	/**
	 * Updates this object and childre objects to database
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param startTask if true, queues a new update task
	 */
	void updateToDatabaseAllObjects(bool startTask);

	/**
	 * Destroys a PlayerCreature from the database. If this object is not a PlayerCreature then the method will return without doing anything.
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param destroyContainedObjects if true, will destroy from database all its contained objects
	 */
	void destroyPlayerCreatureFromDatabase(bool destroyContainedObjects = false);

	/**
	 * Destroys this object from database
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param destroyContainedObjects if true, will destroy from database all its contained objects
	 */
	void destroyObjectFromDatabase(bool destroyContainedObjects = false);

	/**
	 * Checks if the object can be destroyed
	 * @pre { player is locked }
	 * @post { player is locked }
	 * @param player Player that attempts to destroy this object
	 * @returns 0 on succes, != 0 on error
	 */
	int canBeDestroyed(CreatureObject* player);

	/**
	 * Creates a new UpdateContainmentMessage that adds/links this object to the specified objectID
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param objectID object id of object to link
	 * @param containmentType arrangement type?
	 * @return returns a new valid UpdateContainmentMessage
	 */
	BaseMessage* link(unsigned long long objectID, unsigned int containmentType = 4);

	/**
	 * Sends the necessary messages to player in order to create this object
	 * @pre { this object is locked }
	 * @post { this object is locked, player received this object }
	 * @param player SceneObject that will receive the messages
	 * @param doClose if true a SceneObjectCloseMessage is sent to finish the object
	 */
	void sendTo(SceneObject* player, bool doClose);

	/**
	 * Sends the object without linking to its actual parent and without sending its children (f.e trade)
	 */
	void sendWithoutParentTo(SceneObject* player);

	void sendWithoutContainerObjectsTo(SceneObject* player);

	/**
	 * Sends a SceneObjectDestroyMessage of this object to client
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the destroy message }
	 * @param plaer SceneObject that will receive the message 
	 */
	void sendDestroyTo(SceneObject* player);

	/**
	 * Sends the baseline messages of this object to the specified player, needs to be overriden
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the baseline messages }
	 * @param player SceneObject that will receive the baselines 
	 */
	void sendBaselinesTo(SceneObject* player);

	/**
	 * Sends the contained non slotted objects to the specified player
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the container objects }
	 * @param player SceneObject that will receive the objects 
	 */
	void sendContainerObjectsTo(SceneObject* player);

	/**
	 * Sends the contained slotted objects to the specified player
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the slotted objects }
	 * @param player SceneObject that will receive the objects 
	 */
	void sendSlottedObjectsTo(SceneObject* player);

	/**
	 * Sends the necessary messages to owner client, needs to be overriden
	 * @pre { this object is locked }
	 * @post { this object is locked, owner received its own scene object }
	 * @param doClose if true a SceneObjectCloseMessage is sent to finish the object
	 */
	void sendToOwner(bool doClose = true);

	/**
	 * Sends an AttributeListMessage to specified object
	 * @pre { this object is locked }
	 * @post { this object is locked, object received the attribute list message }
	 * @param object SceneObject that will receive the message
	 */
	void sendAttributeListTo(CreatureObject* object);

	/**
	 * Fills the attribute list message options that are sent to player creature
	 * @pre { }
	 * @post { }
	 * @param msg attribute list message with the attributes
	 * @param object player creature to which the message is sent
	 */
	void fillAttributeList(AttributeListMessage* msg, CreatureObject* object);

	/**
	 * Updates the custom name of the object
	 * @pre { this locked }
	 * @post { this locked }
	 */
	void setCustomObjectName(const UnicodeString& name, bool notifyClient);

	/**
	 * Fills the radial options, needs to be overriden
	 * @pre { this object is locked }
	 * @post { this object is locked, menuResponse is complete}
	 * @param menuResponse ObjectMenuResponse that will be sent to the client
	 */
	void fillObjectMenuResponse(ObjectMenuResponse* menuResponse, CreatureObject* player);

	/**
	 * Opens container contents to player
	 * @pre { }
	 * @post { }
	 * @param player CreatureObject to open the container to   
	 */
	void openContainerTo(CreatureObject* player);

	byte checkContainerPermission(CreatureObject* player, unsigned short permission);

	/**
	 * Closes the container of a player
	 */
	void closeContainerTo(CreatureObject* player, bool notify = true);

	/**
	 * Inserts this object into zone
	 * @pre { this object is locked }
	 * @post { this object is locked and inserted into zone }
	 * @param zone Zone object where this object will be inserted
	 */
	void notifyInsertToZone(Zone* zone);

	/**
	 * Switches zone and position of this object
	 * @pre { this object is locked }
	 * @post { this object is locked, is in the new zone and in the new position }
	 * @param newTerrainName Name of the new terrain where the player will be inserted.
	 * @param newPositionX new position X
	 * @param newPositionZ new position Z
	 * @param newPositionY new position Y
	 */
	void switchZone(const String& newTerrainName, float newPostionX, float newPositionZ, float newPositionY, unsigned long long parentID = 0);

	void teleport(float newPositionX, float newPositionZ, float newPositionY, unsigned long long parentID = 0);

	/**
	 * Updates the direction of this object, and braodcasts DataTransform with the update 
	 */
	void updateDirection(float fw, float fx, float fy, float fz);

	void updateDirection(float angleHeadingRadians);

	void notifyInsert(QuadTreeEntry* entry);

	void notifyDissapear(QuadTreeEntry* entry);

	void notifyRemoveFromZone();

	/**
	 * Updates position of this object to the rest of in range objects
	 * @pre { this object is locked}
	 * @post { this object is locked, in range objects are updated with the new position }
	 * @param lightUpdate if true a standalone message is sent to the in range objects
	 */
	void updateZone(bool lightUpdate, bool sendPackets = true);

	/**
	 * Updates position and/or parent of this object and to the rest of in range objects
	 * @pre { this object is locked, newParent is a CellObject }
	 * @post {this object is locked, in range objects are updated of the new position and parent }
	 * @param newParent cellObject where this object is
	 * @param lightUpdate if true a standalone message is sent to the in range objects
	 */
	void updateZoneWithParent(SceneObject* newParent, bool lightUpdate, bool sendPackets = true);

	/**
	 * Broadcasts the message to the in range objects
	 * @pre {this object is locked, message is not null }
	 * @post {this object is locked, in range objects received a copy of the message, message is deleted }
	 * @param sendSelf if true the owner if this object receives the message too
	 */
	void broadcastMessage(BasePacket* message, bool sendSelf, bool lockZone = true);

	void broadcastMessagePrivate(BasePacket* message, SceneObject* selfObject, bool lockZone);

	/**
	 * Broadcasts an object to the in range objects
	 * @pre {this object is locked, object is not null }
	 * @post {this object is locked, in range objects received the object }
	 * @param object SceneObject that will be sent to the in range objects
	 * @param sendSelf if true the owner of this object receives the object too
	 */
	void broadcastObject(SceneObject* object, bool sendSelf);

	void broadcastObjectPrivate(SceneObject* object, SceneObject* selfObject);

	/**
	 * Broadcasts an object to the in range objects
	 * @pre {this object is locked, object is not null }
	 * @post {this object is locked, in range objects received the object }
	 * @param object SceneObject that will be sent to the in range objects
	 * @param sendSelf if true the owner of this object receives the object too
	 */
	void broadcastDestroy(SceneObject* object, bool sendSelf);

	void broadcastDestroyPrivate(SceneObject* object, SceneObject* selfObject);

	/**
	 * Broadcasts a vector of messages to the in range objects
	 * @pre {this object is locked }
	 * @post { this object is locked, in range objects received the messages, messages are deleted and removed from the vector }
	 * @param messages a vector containing the messages to be sent, it will be emptied when messages get sent
	 * @param sendSelf if true the owner of this object receives the messages too
	 */
	void broadcastMessages(Vector<BasePacket*>* messages, bool sendSelf);

	void broadcastMessagesPrivate(Vector<BasePacket*>* messages, SceneObject* selfObject);

	/**
	 * Sends BasePacket msg to the owner of this object, needs to be overriden
	 * @pre { } 
	 * @post {owner of this object received message, message is deleted }
	 * @param msg BasePacket to be sent
	 */
	void sendMessage(BasePacket* msg);

	/**
	 * Compares object ids of this object with obj
	 * @pre { this object is locked, obj is not null }
	 * @post {this object is locked }
	 * @param obj SceneObject that will be compared to
	 * @return returns 1 if this < obj, -1 if this > obj and 0 if this == obj 
	 */
	int compareTo(SceneObject* obj);

	/**
	 * Fills the specified vector with the containment objects of this object
	 * @pre { this obejct is locked }
	 * @post { this object is locked, objects is a vector map with the contained objects and their occupied slots }
	 * @param objects the vector map that will contain the objects and their occupied slots 
	 */
	void getSlottedObjects(VectorMap<String, ManagedReference<SceneObject* > >& objects);

	void getContainerObjects(VectorMap<unsigned long long, ManagedReference<SceneObject* > >& objects);

	/**
	 * Returns the object id of the parent of this object
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return returns 0 if this object doesnt have a parent, otherwise returns its object id
	 */
	unsigned long long getParentID();

	/**
	 * Adds a pending task of this SceneObject
	 * @pre { this locked }
	 * @post { this locked}
	 * @param name Name of the task
	 * @param task Task to add
	 */
	void addPendingTask(const String& name, Task* task, int miliseconds);

	/**
	 * Removes a pending task from this SceneObject
	 * @pre { this locked }
	 * @post { this locked }
	 * @param name Name of the task to drop
	 */
	void removePendingTask(const String& name);

	PendingTasksMap* getPendingTasks();

	/**
	 * Looks up a specific pending tasks by the name
	 * @pre { this locked }
	 * @post { this locked }
	 * @param name Name of the task to lookup
	 */
	Reference<Task* > getPendingTask(const String& name);

	bool containsPendingTask(const String& name);

	void showFlyText(const String& file, const String& uax, byte red, byte green, byte blue);

	int getContainedObjectsRecursive();

	int getCountableObjectsRecursive();

	/**
	 * Returns a Facade session
	 */
	Reference<Facade* > getActiveSession(unsigned int type);

	void addActiveSession(unsigned int type, Facade* session);

	bool containsActiveSession(unsigned int type);

	bool dropActiveSession(unsigned int type);

	int getActiveSessionsCount();

	VectorMap<unsigned int, ManagedReference<Facade* > >* getObjectActiveSessions();

	/**
	 * Handles the radial selection sent by the client, must be overriden by inherited objects
	 * @pre { this object is locked, player is locked }
	 * @post { this object is locked, player is locked }
	 * @param player CreatureObject that selected the option
	 * @param selectedID selected menu id
	 * @returns 0 if successfull
	 */
	int handleObjectMenuSelect(CreatureObject* player, byte selectedID);

	float getDistanceTo(SceneObject* object);

	float getDistanceTo(Coordinate* coordinate);

	void updateVehiclePosition(bool sendPackets);

	/**
	 * Is called when this object has been inserted with an object
	 * @param object object that has been inserted
	 */
	int notifyObjectInserted(SceneObject* object);

	/**
	 * Is called when an object was removed
	 * @param object object that has been inserted
	 */
	int notifyObjectRemoved(SceneObject* object);

	void addActiveArea(ActiveArea* area);

	void dropActiveArea(ActiveArea* area);

	bool hasActiveArea(ActiveArea* area);

	bool hasActiveArea(unsigned long long objectid);

	Vector<ManagedReference<ActiveArea* > >* getActiveAreas();

	int getActiveAreasSize();

	Reference<ActiveArea* > getActiveRegion();

	ManagedWeakReference<CityRegion* > getCityRegion();

	void setCityRegion(CityRegion* region);

	Zone* getZone();

	Zone* getLocalZone();

	unsigned long long getObjectID();

	Vector3 getCoordinate(float distance, float angleDegrees);

	Vector3 getWorldCoordinate(float distance, float angleDegrees);

	virtual float getWorldPositionX();

	virtual float getWorldPositionY();

	virtual float getWorldPositionZ();

	virtual Vector3 getWorldPosition();

	float getDirectionX();

	float getDirectionZ();

	float getDirectionY();

	float getDirectionW();

	Quaternion* getDirection();

	unsigned int getClientObjectCRC();

	unsigned int getServerObjectCRC();

	bool isWaypointObject();

	StringId* getObjectName();

	String getObjectNameStringIdFile();

	String getObjectNameStringIdName();

	String getDetailedDescription();

	void setDetailedDescription(const String& detail);

	int getArrangementDescriptorSize();

	String getArrangementDescriptor(int idx);

	String getSlotDescriptor(int idx);

	bool hasSlotDescriptor(const String& descr);

	bool hasArrangementDescriptor(const String& descr);

	VectorMap<String, ManagedReference<SceneObject* > >* getSlottedObjects();

	Reference<SceneObject* > getSlottedObject(const String& slot);

	int getSlotDescriptorSize();

	Reference<SceneObject* > getSlottedObject(int idx);

	Reference<SceneObject* > getContainerObjectRecursive(unsigned long long oid);

	void dropSlottedObject(const String& arrengementDescriptor);

	void removeSlottedObject(int index);

	int getContainerObjectsSize();

	int getSlottedObjectsSize();

	bool hasFullContainerObjects();

	unsigned int getContainerVolumeLimit();

	Reference<SceneObject* > getContainerObject(int idx);

	VectorMap<unsigned long long, ManagedReference<SceneObject* > >* getContainerObjects();

	bool hasObjectInContainer(unsigned long long objectID);

	bool hasObjectInSlottedContainer(SceneObject* object);

	Reference<SceneObject* > getContainerObject(unsigned long long objectID);

	void removeAllContainerObjects();

	void putInContainer(SceneObject* obj, unsigned long long key);

	void removeFromContainerObjects(int index);

	void setContainerVolumeLimit(int lim);

	void setContainerType(int type);

	unsigned int getContainerType();

	ZoneClientSession* getClient();

	unsigned int getGameObjectType();

	unsigned int getClientGameObjectType();

	unsigned int getContainmentType();

	float getDirectionAngle();

	float getSpecialDirectionAngle();

	/**
	 * Rotates an object by a specified number of degrees.
	 * @param degrees How many degrees to rotate the object with 0 being North.
	 * TODO: @param notifyClient
	 */
	void rotate(int degrees);

	/**
	 * Sets this objects direction so that the object is facing the specified object.
	 * @param obj The object to face.
	 */
	void faceObject(SceneObject* obj);

	void notifySelfPositionUpdate();

	void notifyPositionUpdate(QuadTreeEntry* entry);

	/**
	 * @param player player that closed the container
	 */
	void notifyCloseContainer(CreatureObject* player);

	unsigned int getMovementCounter();

	ManagedWeakReference<SceneObject* > getParent();

	void setParent(QuadTreeEntry* entry);

	ZoneServer* getZoneServer();

	/**
	 * Returns the parent of all children in the object tree
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return returns the parent of all children in the object tree
	 */
	ManagedWeakReference<SceneObject* > getRootParent();

	/**
	 * Returns the parent of object type in the tree
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return Returns the parent of object type in the tree
	 */
	ManagedWeakReference<SceneObject* > getParentRecursively(unsigned int gameObjectType);

	/**
	 * Evaluates if this object is a child of the specified SceneObject
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return returns true if this object is a child of object
	 */
	bool isASubChildOf(SceneObject* object);

	ReadWriteLock* getContainerLock();

	UnicodeString getCustomObjectName();

	String getLoggingName();

	bool isPlayerCreature();

	bool isVendor();

	bool isGCWBase();

	bool isTurret();

	bool isMinefield();

	bool isDetector();

	bool isSecurityTerminal();

	bool isTurretControlTerminal();

	ZoneComponent* getZoneComponent();

	ObjectMenuComponent* getObjectMenuComponent();

	DataObjectComponentReference* getDataObjectComponent();

	bool isDecoration();

	void setObjectMenuComponent(const String& name);

	void setContainerComponent(const String& name);

	void setZoneComponent(const String& name);

	bool isNoTrade();

	bool isContainerFull();

	bool isShuttleInstallation();

	bool isPlayerObject();

	bool isActiveArea();

	bool isRegion();

	bool isCreatureObject();

	bool isAiAgent();

	bool isJunkDealer();

	bool isShipObject();

	bool isVehicleObject();

	bool isBuildingObject();

	bool isCloningBuildingObject();

	bool isGarage();

	bool isWeaponObject();

	bool isWearableObject();

	bool isWearableContainerObject();

	bool isArmorObject();

	bool isRobeObject();

	bool isLightsaberCrystalObject();

	bool isFireworkObject();

	bool isPsgArmorObject();

	bool isCellObject();

	bool isTangibleObject();

	bool isResourceContainer();

	bool isResourceSpawn();

	bool isComponent();

	bool isIntangibleObject();

	bool isInstrument();

	bool isBazaarTerminal();

	bool isLiveSample();

	bool isInstallationObject();

	bool isHarvesterObject();

	bool isGeneratorObject();

	bool isCityTerminal();

	bool isCityVoteTerminal();

	bool isFactory();

	bool isFactoryCrate();

	bool isFishingPoleObject();

	bool isDeedObject();

	bool isVehicleDeedObject();

	bool isBuildingDeed();

	bool isSignObject();

	bool isInstallationDeed();

	bool isCraftingTool();

	bool isCraftingStation();

	bool isManufactureSchematic();

	bool isStructureObject();

	bool isAuctionObject();

	bool isFishingBait();

	bool isTrapObject();

	bool isRepairTool();

	bool isCamoKit();

	bool isAttachment();

	bool isDiceObject();

	bool isCreatureHabitat();

	bool isCampKit();

	bool isCampStructure();

	bool isRecycleToolObject();

	ContainerPermissions* getContainerPermissions();

	void setContainerDefaultAllowPermission(unsigned short perm);

	void clearContainerDefaultAllowPermission(unsigned short perm);

	void setContainerDefaultDenyPermission(unsigned short perm);

	void clearContainerDefaultDenyPermission(unsigned short perm);

	void setContainerInheritPermissionsFromParent(bool val);

	void setContainerOwnerID(unsigned long long id);

	void setContainerAllowPermission(const String& group, unsigned short perm);

	void setContainerDenyPermission(const String& group, unsigned short perm);

	void setGameObjectType(unsigned int type);

	void setClientObjectCRC(unsigned int objCRC);

	void setServerObjectCRC(unsigned int objCRC);

	void setZoneProcessServer(ZoneProcessServer* srv);

	ZoneProcessServer* getZoneProcessServer();

	void setZone(Zone* zone);

	void setObjectName(StringId& stringID);

	void setDirection(float fw, float fx, float fy, float fz);

	void setDirection(float headingAngleRadians);

	void setDirection(const Quaternion& dir);

	void setMovementCounter(unsigned int count);

	void incrementMovementCounter();

	void setContainmentType(unsigned int type);

	void setLoggingName(const String& name);

	void setClientObject(bool val);

	unsigned int getPlanetCRC();

	bool isStaticObject();

	bool isContainerObject();

	bool isTerminal();

	bool isGroupObject();

	bool isGuildObject();

	bool isControlDevice();

	bool isMissionTerminal();

	bool isMissionObject();

	bool isActorObject();

	int getPlanetMapCategoryCRC();

	int getPlanetMapSubCategoryCRC();

	void setPlanetMapCategory(PlanetMapCategory* pmc);

	void setPlanetMapSubCategory(PlanetMapCategory* pmc);

	PlanetMapCategory* getPlanetMapCategory();

	PlanetMapCategory* getPlanetMapSubCategory();

	SortedVector<ManagedReference<SceneObject* > >* getChildObjects();

	bool containsChildObject(SceneObject* obj);

	SharedObjectTemplate* getObjectTemplate();

	/**
	 * The returning value points directly to the internal vector, do not delete it or store it
	 */
	SortedVector<ManagedReference<Observer* > > getObservers(unsigned int eventType);

	void createChildObjects();

	Matrix4* getTransformForCollisionMatrix();

	bool setTransformForCollisionMatrixIfNull(Matrix4* mat);

	/**
	 * This method initializes "this" object as if it were a "childObject" of the controller object that is passed
	 * as an argument to the method.
	 * NOTE: The controllerObject is not necessarily the "parent" of the child object. The childObject just happens
	 * to be specified in the controllerObject's childObjects vector.
	 * @param controllerObject The object that has this object specified as a "childObject".
	 */
	void initializeChildObject(SceneObject* controllerObject);

	bool isInWater();

	String getDisplayedName();

	bool doSendToClient();

	void setSendToClient(bool val);

	DistributedObjectServant* _getImplementation();
	DistributedObjectServant* _getImplementationForRead();

	void _setImplementation(DistributedObjectServant* servant);

protected:
	SceneObject(DummyConstructorParameter* param);

	virtual ~SceneObject();

	friend class SceneObjectHelper;
};

} // namespace scene
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::scene;

namespace server {
namespace zone {
namespace objects {
namespace scene {

class SceneObjectImplementation : public QuadTreeEntryImplementation, public Logger {
protected:
	ManagedReference<ZoneProcessServer* > server;

	Reference<ZoneComponent* > zoneComponent;

	Reference<ObjectMenuComponent* > objectMenuComponent;

	Reference<AttributeListComponent* > attributeListComponent;

	Reference<ContainerComponent* > containerComponent;

	Reference<SharedObjectTemplate* > templateObject;

	bool sendToClient;

	ZoneReference zone;

	DataObjectComponentReference dataObjectComponent;

	Reference<Matrix4* > transformForCollisionMatrix;

	unsigned int containerType;

	unsigned int containerVolumeLimit;

	ContainerPermissions containerPermissions;

	unsigned int serverObjectCRC;

	unsigned int clientObjectCRC;

	Quaternion direction;

	unsigned int movementCounter;

	StringId objectName;

	Reference<PendingTasksMap* > pendingTasks;

	bool staticObject;

	VectorMap<unsigned int, ManagedReference<Facade* > > objectActiveSessions;

	unsigned int gameObjectType;

	unsigned int containmentType;

	int planetMapCategory;

	int planetMapSubCategory;

	UnicodeString customName;

	ManagedWeakReference<CityRegion* > cityRegion;

	SortedVector<ManagedReference<ActiveArea* > > activeAreas;

	SortedVector<ManagedReference<SceneObject* > > childObjects;

	VectorMap<String, ManagedReference<SceneObject* > > slottedObjects;

	ReadWriteLock containerLock;

	Mutex parentLock;

	ContainerObjectsMap containerObjects;

public:
	SceneObjectImplementation();

	SceneObjectImplementation(DummyConstructorParameter* param);

	void finalize();

	void initializePrivateData();

	/**
	 * Reads and sets the template data from a SharedObjectTemplate LuaObject
	 * @pre { templateData is a valid pointer }
	 * @post { SceneObject members are initialized }
	 * @param templateData templateData points to the LuaObject that is used to initialize SceneObejct members
	 */
	virtual void loadTemplateData(SharedObjectTemplate* templateData);

	virtual void createComponents();

	virtual void createContainerComponent();

	/**
	 * Initializes the transient members of SceneObject, must call the inherited object method first.
	 * @pre {transient members are not initialized }
	 * @post { transient members are initialized }
	 */
	void initializeTransientMembers();

	/**
	 * Gets called when this objects is loaded from database
	 * @pre { this locked }
	 * @post { this locked }
	 */
	void notifyLoadFromDatabase();

	/**
	 * Logs an info message
	 * @pre {}
	 * @post { message has been printed to console or file }
	 * @param msg message to print
	 * @param forced if true, always prints the message to console 
	 */
	void info(const String& msg, bool forced = false);

	/**
	 * Logs an error message
	 * @pre {}
	 * @post {error message has been printed to console and file }
	 * @param msg error message to print
	 */
	void error(const String& msg);

	/**
	 * Returns number of specified game objects in range
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return number of objects in range
	 */
	int inRangeObjects(unsigned int gameObjectType, float range);

	/**
	 * Evaluates if the object is in range
	 * @pre { this object is locked, obj is locked}
	 * @post { thisobject is locked, obj is locked }
	 * @param obj object that will be checked against
	 * @param range range to check
	 * @return returns true if this object is in range with obj
	 */
	bool isInRange(SceneObject* obj, float range);

	/**
	 * Tries to add/link object
	 * @pre { this object is locked, object is locked }
	 * @post {this object is locked, object is locked }
	 * @param object SceneObject that will be added to the current object
	 * @param containmentType arrangement type that will be used to add the object
	 * @param notifyClient if true in range objects will be updated with the change
	 * @return returns true if the object has been successfully added
	 */
	virtual bool transferObject(SceneObject* object, int containmentType, bool notifyClient = false, bool allowOverflow = false);

	/**
	 * Tries to remove/unlink object
	 * @pre { this object is locked, object is locked }
	 * @post {this object is locked, object is locked }
	 * @param object SceneObject that will be removed from the current object
	 * @param destination SceneObject that will be the new destination of the object.
	 * @param notifyClient not used currently
	 * @return returns true if the object has been successfully removed
	 */
	virtual bool removeObject(SceneObject* object, SceneObject* destination, bool notifyClient = false);

	/**
	 * Destroys the object from the world
	 */
	virtual void destroyObjectFromWorld(bool sendSelfDestroy);

	/**
	 * Evaluates if this object has the necessary free slots to be able to add the specified SceneObject
	 * @pre { this object is locked, object is locked }
	 * @post {this object is locked, object is locked }
	 * @param object SceneObject that will be checked
	 * @param error error string that the player will receive on error
	 * @return returns 0 on success, or error code
	 */
	virtual int canAddObject(SceneObject* object, int containmentType, String& errorDescription);

	/**
	 * 
	 */
	virtual int notifyObjectInsertedToChild(SceneObject* object, SceneObject* child, SceneObject* oldParent);

	virtual int notifyObjectRemovedFromChild(SceneObject* object, SceneObject* child);

	/**
	 * Calls the appropriate UI Listener Function
	 * @pre { this object is locked, object is locked }
	 * @post {this object is locked, object is locked }
	 * @param player CreatureObject using the item
	 * @param value value from packet
	 */
	virtual void synchronizedUIListen(SceneObject* player, int value);

	/**
	 * Calls the appropriate UI Stop Listener Function
	 * @pre { this object is locked, object is locked }
	 * @post {this object is locked, object is locked }
	 * @param player CreatureObject using the item
	 * @param value value from packet
	 */
	virtual void synchronizedUIStopListen(SceneObject* player, int value);

	/**
	 * Updates this object to database (calls updatesToDatabaseAllObjects())
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param startTask if true, queues a new update task
	 */
	void updateToDatabase();

	/**
	  * Updates only this object to database without updating children
	  * WARNING use only when necessary
	  */
	void updateToDatabaseWithoutChildren();

	/**
	 * Updates this object and childre objects to database
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param startTask if true, queues a new update task
	 */
	void updateToDatabaseAllObjects(bool startTask);

	/**
	 * Destroys a PlayerCreature from the database. If this object is not a PlayerCreature then the method will return without doing anything.
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param destroyContainedObjects if true, will destroy from database all its contained objects
	 */
	virtual void destroyPlayerCreatureFromDatabase(bool destroyContainedObjects = false);

	/**
	 * Destroys this object from database
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param destroyContainedObjects if true, will destroy from database all its contained objects
	 */
	virtual void destroyObjectFromDatabase(bool destroyContainedObjects = false);

	/**
	 * Checks if the object can be destroyed
	 * @pre { player is locked }
	 * @post { player is locked }
	 * @param player Player that attempts to destroy this object
	 * @returns 0 on succes, != 0 on error
	 */
	virtual int canBeDestroyed(CreatureObject* player);

protected:
	/**
	 * Sends a SceneObjectCloseMessage of this object to client
	 * @pre { this object is locked }
	 * @post { this object is locked, client received the close message }
	 * @param client ZoneClientSession that will receive the message
	 */
	void close(SceneObject* client);

	/**
	 * Sends an UpdateContainmentMessage to client that adds/links this object to its parent object 
	 * @pre { this object is locked }
	 * @post { this object is locked, client received the link message }
	 * @param client ZoneClientSession that will receive the message
	 * @param containmentType arrangement type?
	 */
	void link(SceneObject* client, unsigned int containmentType = 4);

public:
	/**
	 * Creates a new UpdateContainmentMessage that adds/links this object to the specified objectID
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param objectID object id of object to link
	 * @param containmentType arrangement type?
	 * @return returns a new valid UpdateContainmentMessage
	 */
	BaseMessage* link(unsigned long long objectID, unsigned int containmentType = 4);

	/**
	 * Sends the necessary messages to player in order to create this object
	 * @pre { this object is locked }
	 * @post { this object is locked, player received this object }
	 * @param player SceneObject that will receive the messages
	 * @param doClose if true a SceneObjectCloseMessage is sent to finish the object
	 */
	virtual void sendTo(SceneObject* player, bool doClose);

	/**
	 * Sends the object without linking to its actual parent and without sending its children (f.e trade)
	 */
	virtual void sendWithoutParentTo(SceneObject* player);

	virtual void sendWithoutContainerObjectsTo(SceneObject* player);

	/**
	 * Sends a SceneObjectDestroyMessage of this object to client
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the destroy message }
	 * @param plaer SceneObject that will receive the message 
	 */
	virtual void sendDestroyTo(SceneObject* player);

	/**
	 * Sends the baseline messages of this object to the specified player, needs to be overriden
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the baseline messages }
	 * @param player SceneObject that will receive the baselines 
	 */
	virtual void sendBaselinesTo(SceneObject* player);

	/**
	 * Sends the contained non slotted objects to the specified player
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the container objects }
	 * @param player SceneObject that will receive the objects 
	 */
	virtual void sendContainerObjectsTo(SceneObject* player);

	/**
	 * Sends the contained slotted objects to the specified player
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the slotted objects }
	 * @param player SceneObject that will receive the objects 
	 */
	virtual void sendSlottedObjectsTo(SceneObject* player);

	/**
	 * Sends the necessary messages to owner client, needs to be overriden
	 * @pre { this object is locked }
	 * @post { this object is locked, owner received its own scene object }
	 * @param doClose if true a SceneObjectCloseMessage is sent to finish the object
	 */
	virtual void sendToOwner(bool doClose = true);

	/**
	 * Sends an AttributeListMessage to specified object
	 * @pre { this object is locked }
	 * @post { this object is locked, object received the attribute list message }
	 * @param object SceneObject that will receive the message
	 */
	virtual void sendAttributeListTo(CreatureObject* object);

	/**
	 * Fills the attribute list message options that are sent to player creature
	 * @pre { }
	 * @post { }
	 * @param msg attribute list message with the attributes
	 * @param object player creature to which the message is sent
	 */
	virtual void fillAttributeList(AttributeListMessage* msg, CreatureObject* object);

	/**
	 * Updates the custom name of the object
	 * @pre { this locked }
	 * @post { this locked }
	 */
	virtual void setCustomObjectName(const UnicodeString& name, bool notifyClient);

	/**
	 * Fills the radial options, needs to be overriden
	 * @pre { this object is locked }
	 * @post { this object is locked, menuResponse is complete}
	 * @param menuResponse ObjectMenuResponse that will be sent to the client
	 */
	virtual void fillObjectMenuResponse(ObjectMenuResponse* menuResponse, CreatureObject* player);

	/**
	 * Opens container contents to player
	 * @pre { }
	 * @post { }
	 * @param player CreatureObject to open the container to   
	 */
	virtual void openContainerTo(CreatureObject* player);

	virtual byte checkContainerPermission(CreatureObject* player, unsigned short permission);

	/**
	 * Closes the container of a player
	 */
	virtual void closeContainerTo(CreatureObject* player, bool notify = true);

	/**
	 * Inserts this object into zone
	 * @pre { this object is locked }
	 * @post { this object is locked and inserted into zone }
	 * @param zone Zone object where this object will be inserted
	 */
	virtual void notifyInsertToZone(Zone* zone);

	/**
	 * Switches zone and position of this object
	 * @pre { this object is locked }
	 * @post { this object is locked, is in the new zone and in the new position }
	 * @param newTerrainName Name of the new terrain where the player will be inserted.
	 * @param newPositionX new position X
	 * @param newPositionZ new position Z
	 * @param newPositionY new position Y
	 */
	virtual void switchZone(const String& newTerrainName, float newPostionX, float newPositionZ, float newPositionY, unsigned long long parentID = 0);

	virtual void teleport(float newPositionX, float newPositionZ, float newPositionY, unsigned long long parentID = 0);

	/**
	 * Updates the direction of this object, and braodcasts DataTransform with the update 
	 */
	void updateDirection(float fw, float fx, float fy, float fz);

	void updateDirection(float angleHeadingRadians);

	void notifyInsert(QuadTreeEntry* entry);

	void notifyDissapear(QuadTreeEntry* entry);

	virtual void notifyRemoveFromZone();

	/**
	 * Updates position of this object to the rest of in range objects
	 * @pre { this object is locked}
	 * @post { this object is locked, in range objects are updated with the new position }
	 * @param lightUpdate if true a standalone message is sent to the in range objects
	 */
	virtual void updateZone(bool lightUpdate, bool sendPackets = true);

	/**
	 * Updates position and/or parent of this object and to the rest of in range objects
	 * @pre { this object is locked, newParent is a CellObject }
	 * @post {this object is locked, in range objects are updated of the new position and parent }
	 * @param newParent cellObject where this object is
	 * @param lightUpdate if true a standalone message is sent to the in range objects
	 */
	virtual void updateZoneWithParent(SceneObject* newParent, bool lightUpdate, bool sendPackets = true);

	/**
	 * Broadcasts the message to the in range objects
	 * @pre {this object is locked, message is not null }
	 * @post {this object is locked, in range objects received a copy of the message, message is deleted }
	 * @param sendSelf if true the owner if this object receives the message too
	 */
	void broadcastMessage(BasePacket* message, bool sendSelf, bool lockZone = true);

	void broadcastMessagePrivate(BasePacket* message, SceneObject* selfObject, bool lockZone);

	/**
	 * Broadcasts an object to the in range objects
	 * @pre {this object is locked, object is not null }
	 * @post {this object is locked, in range objects received the object }
	 * @param object SceneObject that will be sent to the in range objects
	 * @param sendSelf if true the owner of this object receives the object too
	 */
	void broadcastObject(SceneObject* object, bool sendSelf);

	void broadcastObjectPrivate(SceneObject* object, SceneObject* selfObject);

	/**
	 * Broadcasts an object to the in range objects
	 * @pre {this object is locked, object is not null }
	 * @post {this object is locked, in range objects received the object }
	 * @param object SceneObject that will be sent to the in range objects
	 * @param sendSelf if true the owner of this object receives the object too
	 */
	void broadcastDestroy(SceneObject* object, bool sendSelf);

	void broadcastDestroyPrivate(SceneObject* object, SceneObject* selfObject);

	/**
	 * Broadcasts a vector of messages to the in range objects
	 * @pre {this object is locked }
	 * @post { this object is locked, in range objects received the messages, messages are deleted and removed from the vector }
	 * @param messages a vector containing the messages to be sent, it will be emptied when messages get sent
	 * @param sendSelf if true the owner of this object receives the messages too
	 */
	void broadcastMessages(Vector<BasePacket*>* messages, bool sendSelf);

	void broadcastMessagesPrivate(Vector<BasePacket*>* messages, SceneObject* selfObject);

	/**
	 * Sends BasePacket msg to the owner of this object, needs to be overriden
	 * @pre { } 
	 * @post {owner of this object received message, message is deleted }
	 * @param msg BasePacket to be sent
	 */
	virtual void sendMessage(BasePacket* msg);

	/**
	 * Compares object ids of this object with obj
	 * @pre { this object is locked, obj is not null }
	 * @post {this object is locked }
	 * @param obj SceneObject that will be compared to
	 * @return returns 1 if this < obj, -1 if this > obj and 0 if this == obj 
	 */
	int compareTo(SceneObject* obj);

	/**
	 * Fills the specified vector with the containment objects of this object
	 * @pre { this obejct is locked }
	 * @post { this object is locked, objects is a vector map with the contained objects and their occupied slots }
	 * @param objects the vector map that will contain the objects and their occupied slots 
	 */
	void getSlottedObjects(VectorMap<String, ManagedReference<SceneObject* > >& objects);

	void getContainerObjects(VectorMap<unsigned long long, ManagedReference<SceneObject* > >& objects);

	/**
	 * Returns the object id of the parent of this object
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return returns 0 if this object doesnt have a parent, otherwise returns its object id
	 */
	unsigned long long getParentID();

	/**
	 * Adds a pending task of this SceneObject
	 * @pre { this locked }
	 * @post { this locked}
	 * @param name Name of the task
	 * @param task Task to add
	 */
	void addPendingTask(const String& name, Task* task, int miliseconds);

	/**
	 * Removes a pending task from this SceneObject
	 * @pre { this locked }
	 * @post { this locked }
	 * @param name Name of the task to drop
	 */
	void removePendingTask(const String& name);

	PendingTasksMap* getPendingTasks();

	/**
	 * Looks up a specific pending tasks by the name
	 * @pre { this locked }
	 * @post { this locked }
	 * @param name Name of the task to lookup
	 */
	Reference<Task* > getPendingTask(const String& name);

	bool containsPendingTask(const String& name);

	void showFlyText(const String& file, const String& uax, byte red, byte green, byte blue);

	int getContainedObjectsRecursive();

	virtual int getCountableObjectsRecursive();

	/**
	 * Returns a Facade session
	 */
	Reference<Facade* > getActiveSession(unsigned int type);

	void addActiveSession(unsigned int type, Facade* session);

	bool containsActiveSession(unsigned int type);

	bool dropActiveSession(unsigned int type);

	int getActiveSessionsCount();

	VectorMap<unsigned int, ManagedReference<Facade* > >* getObjectActiveSessions();

	/**
	 * Handles the radial selection sent by the client, must be overriden by inherited objects
	 * @pre { this object is locked, player is locked }
	 * @post { this object is locked, player is locked }
	 * @param player CreatureObject that selected the option
	 * @param selectedID selected menu id
	 * @returns 0 if successfull
	 */
	virtual int handleObjectMenuSelect(CreatureObject* player, byte selectedID);

	float getDistanceTo(SceneObject* object);

	float getDistanceTo(Coordinate* coordinate);

	void updateVehiclePosition(bool sendPackets);

	/**
	 * Is called when this object has been inserted with an object
	 * @param object object that has been inserted
	 */
	virtual int notifyObjectInserted(SceneObject* object);

	/**
	 * Is called when an object was removed
	 * @param object object that has been inserted
	 */
	virtual int notifyObjectRemoved(SceneObject* object);

	void addActiveArea(ActiveArea* area);

	void dropActiveArea(ActiveArea* area);

	bool hasActiveArea(ActiveArea* area);

	bool hasActiveArea(unsigned long long objectid);

	Vector<ManagedReference<ActiveArea* > >* getActiveAreas();

	int getActiveAreasSize();

	Reference<ActiveArea* > getActiveRegion();

	virtual ManagedWeakReference<CityRegion* > getCityRegion();

	void setCityRegion(CityRegion* region);

	Zone* getZone();

	Zone* getLocalZone();

	unsigned long long getObjectID();

	Vector3 getCoordinate(float distance, float angleDegrees);

	Vector3 getWorldCoordinate(float distance, float angleDegrees);

	virtual float getWorldPositionX();

	virtual float getWorldPositionY();

	virtual float getWorldPositionZ();

	virtual Vector3 getWorldPosition();

	float getDirectionX();

	float getDirectionZ();

	float getDirectionY();

	float getDirectionW();

	Quaternion* getDirection();

	unsigned int getClientObjectCRC();

	unsigned int getServerObjectCRC();

	bool isWaypointObject();

	StringId* getObjectName();

	String getObjectNameStringIdFile();

	String getObjectNameStringIdName();

	virtual String getDetailedDescription();

	virtual void setDetailedDescription(const String& detail);

	int getArrangementDescriptorSize();

	String getArrangementDescriptor(int idx);

	String getSlotDescriptor(int idx);

	bool hasSlotDescriptor(const String& descr);

	bool hasArrangementDescriptor(const String& descr);

	VectorMap<String, ManagedReference<SceneObject* > >* getSlottedObjects();

	Reference<SceneObject* > getSlottedObject(const String& slot);

	int getSlotDescriptorSize();

	Reference<SceneObject* > getSlottedObject(int idx);

	Reference<SceneObject* > getContainerObjectRecursive(unsigned long long oid);

	void dropSlottedObject(const String& arrengementDescriptor);

	void removeSlottedObject(int index);

	int getContainerObjectsSize();

	int getSlottedObjectsSize();

	bool hasFullContainerObjects();

	unsigned int getContainerVolumeLimit();

	Reference<SceneObject* > getContainerObject(int idx);

	VectorMap<unsigned long long, ManagedReference<SceneObject* > >* getContainerObjects();

	bool hasObjectInContainer(unsigned long long objectID);

	bool hasObjectInSlottedContainer(SceneObject* object);

	Reference<SceneObject* > getContainerObject(unsigned long long objectID);

	void removeAllContainerObjects();

	void putInContainer(SceneObject* obj, unsigned long long key);

	void removeFromContainerObjects(int index);

	void setContainerVolumeLimit(int lim);

	void setContainerType(int type);

	unsigned int getContainerType();

	virtual ZoneClientSession* getClient();

	unsigned int getGameObjectType();

	unsigned int getClientGameObjectType();

	unsigned int getContainmentType();

	float getDirectionAngle();

	float getSpecialDirectionAngle();

	/**
	 * Rotates an object by a specified number of degrees.
	 * @param degrees How many degrees to rotate the object with 0 being North.
	 * TODO: @param notifyClient
	 */
	void rotate(int degrees);

	/**
	 * Sets this objects direction so that the object is facing the specified object.
	 * @param obj The object to face.
	 */
	void faceObject(SceneObject* obj);

	virtual void notifySelfPositionUpdate();

	void notifyPositionUpdate(QuadTreeEntry* entry);

	/**
	 * @param player player that closed the container
	 */
	virtual void notifyCloseContainer(CreatureObject* player);

	unsigned int getMovementCounter();

	ManagedWeakReference<SceneObject* > getParent();

	void setParent(QuadTreeEntry* entry);

	ZoneServer* getZoneServer();

	/**
	 * Returns the parent of all children in the object tree
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return returns the parent of all children in the object tree
	 */
	ManagedWeakReference<SceneObject* > getRootParent();

	/**
	 * Returns the parent of object type in the tree
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return Returns the parent of object type in the tree
	 */
	ManagedWeakReference<SceneObject* > getParentRecursively(unsigned int gameObjectType);

	/**
	 * Evaluates if this object is a child of the specified SceneObject
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return returns true if this object is a child of object
	 */
	bool isASubChildOf(SceneObject* object);

	ReadWriteLock* getContainerLock();

	UnicodeString getCustomObjectName();

	String getLoggingName();

	virtual bool isPlayerCreature();

	bool isVendor();

	bool isGCWBase();

	bool isTurret();

	bool isMinefield();

	bool isDetector();

	bool isSecurityTerminal();

	bool isTurretControlTerminal();

	ZoneComponent* getZoneComponent();

	ObjectMenuComponent* getObjectMenuComponent();

	DataObjectComponentReference* getDataObjectComponent();

	bool isDecoration();

	void setObjectMenuComponent(const String& name);

	void setContainerComponent(const String& name);

	void setZoneComponent(const String& name);

	bool isNoTrade();

	bool isContainerFull();

	bool isShuttleInstallation();

	bool isPlayerObject();

	virtual bool isActiveArea();

	virtual bool isRegion();

	virtual bool isCreatureObject();

	virtual bool isAiAgent();

	virtual bool isJunkDealer();

	virtual bool isShipObject();

	virtual bool isVehicleObject();

	virtual bool isBuildingObject();

	virtual bool isCloningBuildingObject();

	bool isGarage();

	virtual bool isWeaponObject();

	virtual bool isWearableObject();

	virtual bool isWearableContainerObject();

	virtual bool isArmorObject();

	virtual bool isRobeObject();

	virtual bool isLightsaberCrystalObject();

	virtual bool isFireworkObject();

	bool isPsgArmorObject();

	virtual bool isCellObject();

	virtual bool isTangibleObject();

	virtual bool isResourceContainer();

	virtual bool isResourceSpawn();

	virtual bool isComponent();

	virtual bool isIntangibleObject();

	bool isInstrument();

	bool isBazaarTerminal();

	bool isLiveSample();

	virtual bool isInstallationObject();

	virtual bool isHarvesterObject();

	virtual bool isGeneratorObject();

	virtual bool isCityTerminal();

	virtual bool isCityVoteTerminal();

	virtual bool isFactory();

	virtual bool isFactoryCrate();

	bool isFishingPoleObject();

	virtual bool isDeedObject();

	virtual bool isVehicleDeedObject();

	virtual bool isBuildingDeed();

	virtual bool isSignObject();

	virtual bool isInstallationDeed();

	virtual bool isCraftingTool();

	virtual bool isCraftingStation();

	virtual bool isManufactureSchematic();

	virtual bool isStructureObject();

	virtual bool isAuctionObject();

	bool isFishingBait();

	bool isTrapObject();

	bool isRepairTool();

	bool isCamoKit();

	virtual bool isAttachment();

	bool isDiceObject();

	bool isCreatureHabitat();

	bool isCampKit();

	virtual bool isCampStructure();

	virtual bool isRecycleToolObject();

	ContainerPermissions* getContainerPermissions();

	void setContainerDefaultAllowPermission(unsigned short perm);

	void clearContainerDefaultAllowPermission(unsigned short perm);

	void setContainerDefaultDenyPermission(unsigned short perm);

	void clearContainerDefaultDenyPermission(unsigned short perm);

	void setContainerInheritPermissionsFromParent(bool val);

	void setContainerOwnerID(unsigned long long id);

	void setContainerAllowPermission(const String& group, unsigned short perm);

	void setContainerDenyPermission(const String& group, unsigned short perm);

	void setGameObjectType(unsigned int type);

	void setClientObjectCRC(unsigned int objCRC);

	void setServerObjectCRC(unsigned int objCRC);

	void setZoneProcessServer(ZoneProcessServer* srv);

	ZoneProcessServer* getZoneProcessServer();

	void setZone(Zone* zone);

	void setObjectName(StringId& stringID);

	void setDirection(float fw, float fx, float fy, float fz);

	void setDirection(float headingAngleRadians);

	void setDirection(const Quaternion& dir);

	void setMovementCounter(unsigned int count);

	void incrementMovementCounter();

	void setContainmentType(unsigned int type);

	void setLoggingName(const String& name);

	void setClientObject(bool val);

	virtual unsigned int getPlanetCRC();

	bool isStaticObject();

	virtual bool isContainerObject();

	virtual bool isTerminal();

	virtual bool isGroupObject();

	virtual bool isGuildObject();

	virtual bool isControlDevice();

	virtual bool isMissionTerminal();

	virtual bool isMissionObject();

	virtual bool isActorObject();

	int getPlanetMapCategoryCRC();

	int getPlanetMapSubCategoryCRC();

	void setPlanetMapCategory(PlanetMapCategory* pmc);

	void setPlanetMapSubCategory(PlanetMapCategory* pmc);

	PlanetMapCategory* getPlanetMapCategory();

	PlanetMapCategory* getPlanetMapSubCategory();

	SortedVector<ManagedReference<SceneObject* > >* getChildObjects();

	bool containsChildObject(SceneObject* obj);

	SharedObjectTemplate* getObjectTemplate();

	/**
	 * The returning value points directly to the internal vector, do not delete it or store it
	 */
	SortedVector<ManagedReference<Observer* > > getObservers(unsigned int eventType);

	virtual void createChildObjects();

	Matrix4* getTransformForCollisionMatrix();

	bool setTransformForCollisionMatrixIfNull(Matrix4* mat);

	/**
	 * This method initializes "this" object as if it were a "childObject" of the controller object that is passed
	 * as an argument to the method.
	 * NOTE: The controllerObject is not necessarily the "parent" of the child object. The childObject just happens
	 * to be specified in the controllerObject's childObjects vector.
	 * @param controllerObject The object that has this object specified as a "childObject".
	 */
	virtual void initializeChildObject(SceneObject* controllerObject);

	bool isInWater();

	String getDisplayedName();

	bool doSendToClient();

	void setSendToClient(bool val);

	WeakReference<SceneObject*> _this;

	operator const SceneObject*();

	DistributedObjectStub* _getStub();
	virtual void readObject(ObjectInputStream* stream);
	virtual void writeObject(ObjectOutputStream* stream);
protected:
	virtual ~SceneObjectImplementation();

	void _initializeImplementation();

	void _setStub(DistributedObjectStub* stub);

	void lock(bool doLock = true);

	void lock(ManagedObject* obj);

	void rlock(bool doLock = true);

	void wlock(bool doLock = true);

	void wlock(ManagedObject* obj);

	void unlock(bool doLock = true);

	void runlock(bool doLock = true);

	void _serializationHelperMethod();
	bool readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode);
	int writeObjectMembers(ObjectOutputStream* stream);

	friend class SceneObject;
};

class SceneObjectAdapter : public QuadTreeEntryAdapter {
public:
	SceneObjectAdapter(SceneObject* impl);

	void invokeMethod(sys::uint32 methid, DistributedMethod* method);

	void finalize();

	void initializePrivateData();

	void createComponents();

	void createContainerComponent();

	void initializeTransientMembers();

	void notifyLoadFromDatabase();

	void info(const String& msg, bool forced);

	void error(const String& msg);

	int inRangeObjects(unsigned int gameObjectType, float range);

	bool isInRange(SceneObject* obj, float range);

	bool transferObject(SceneObject* object, int containmentType, bool notifyClient, bool allowOverflow);

	bool removeObject(SceneObject* object, SceneObject* destination, bool notifyClient);

	void destroyObjectFromWorld(bool sendSelfDestroy);

	int canAddObject(SceneObject* object, int containmentType, String& errorDescription);

	int notifyObjectInsertedToChild(SceneObject* object, SceneObject* child, SceneObject* oldParent);

	int notifyObjectRemovedFromChild(SceneObject* object, SceneObject* child);

	void synchronizedUIListen(SceneObject* player, int value);

	void synchronizedUIStopListen(SceneObject* player, int value);

	void updateToDatabase();

	void updateToDatabaseWithoutChildren();

	void updateToDatabaseAllObjects(bool startTask);

	void destroyPlayerCreatureFromDatabase(bool destroyContainedObjects);

	void destroyObjectFromDatabase(bool destroyContainedObjects);

	int canBeDestroyed(CreatureObject* player);

	BaseMessage* link(unsigned long long objectID, unsigned int containmentType);

	void sendTo(SceneObject* player, bool doClose);

	void sendWithoutParentTo(SceneObject* player);

	void sendWithoutContainerObjectsTo(SceneObject* player);

	void sendDestroyTo(SceneObject* player);

	void sendBaselinesTo(SceneObject* player);

	void sendContainerObjectsTo(SceneObject* player);

	void sendSlottedObjectsTo(SceneObject* player);

	void sendToOwner(bool doClose);

	void sendAttributeListTo(CreatureObject* object);

	void setCustomObjectName(const UnicodeString& name, bool notifyClient);

	void openContainerTo(CreatureObject* player);

	void closeContainerTo(CreatureObject* player, bool notify);

	void notifyInsertToZone(Zone* zone);

	void switchZone(const String& newTerrainName, float newPostionX, float newPositionZ, float newPositionY, unsigned long long parentID);

	void teleport(float newPositionX, float newPositionZ, float newPositionY, unsigned long long parentID);

	void updateDirection(float fw, float fx, float fy, float fz);

	void updateDirection(float angleHeadingRadians);

	void notifyRemoveFromZone();

	void updateZone(bool lightUpdate, bool sendPackets);

	void updateZoneWithParent(SceneObject* newParent, bool lightUpdate, bool sendPackets);

	void broadcastMessage(BasePacket* message, bool sendSelf, bool lockZone);

	void broadcastMessagePrivate(BasePacket* message, SceneObject* selfObject, bool lockZone);

	void broadcastObject(SceneObject* object, bool sendSelf);

	void broadcastObjectPrivate(SceneObject* object, SceneObject* selfObject);

	void broadcastDestroy(SceneObject* object, bool sendSelf);

	void broadcastDestroyPrivate(SceneObject* object, SceneObject* selfObject);

	void sendMessage(BasePacket* msg);

	int compareTo(SceneObject* obj);

	unsigned long long getParentID();

	bool containsPendingTask(const String& name);

	void showFlyText(const String& file, const String& uax, byte red, byte green, byte blue);

	int getContainedObjectsRecursive();

	int getCountableObjectsRecursive();

	Reference<Facade* > getActiveSession(unsigned int type);

	void addActiveSession(unsigned int type, Facade* session);

	bool containsActiveSession(unsigned int type);

	bool dropActiveSession(unsigned int type);

	int getActiveSessionsCount();

	int handleObjectMenuSelect(CreatureObject* player, byte selectedID);

	float getDistanceTo(SceneObject* object);

	void updateVehiclePosition(bool sendPackets);

	int notifyObjectInserted(SceneObject* object);

	int notifyObjectRemoved(SceneObject* object);

	void addActiveArea(ActiveArea* area);

	void dropActiveArea(ActiveArea* area);

	bool hasActiveArea(ActiveArea* area);

	bool hasActiveArea(unsigned long long objectid);

	int getActiveAreasSize();

	Reference<ActiveArea* > getActiveRegion();

	Zone* getZone();

	Zone* getLocalZone();

	unsigned long long getObjectID();

	float getWorldPositionX();

	float getWorldPositionY();

	float getWorldPositionZ();

	float getDirectionX();

	float getDirectionZ();

	float getDirectionY();

	float getDirectionW();

	unsigned int getClientObjectCRC();

	unsigned int getServerObjectCRC();

	bool isWaypointObject();

	String getObjectNameStringIdFile();

	String getObjectNameStringIdName();

	void setDetailedDescription(const String& detail);

	int getArrangementDescriptorSize();

	String getArrangementDescriptor(int idx);

	String getSlotDescriptor(int idx);

	bool hasSlotDescriptor(const String& descr);

	bool hasArrangementDescriptor(const String& descr);

	Reference<SceneObject* > getSlottedObject(const String& slot);

	int getSlotDescriptorSize();

	Reference<SceneObject* > getSlottedObject(int idx);

	Reference<SceneObject* > getContainerObjectRecursive(unsigned long long oid);

	void dropSlottedObject(const String& arrengementDescriptor);

	void removeSlottedObject(int index);

	int getContainerObjectsSize();

	int getSlottedObjectsSize();

	bool hasFullContainerObjects();

	unsigned int getContainerVolumeLimit();

	Reference<SceneObject* > getContainerObject(int idx);

	bool hasObjectInContainer(unsigned long long objectID);

	bool hasObjectInSlottedContainer(SceneObject* object);

	Reference<SceneObject* > getContainerObject(unsigned long long objectID);

	void removeAllContainerObjects();

	void putInContainer(SceneObject* obj, unsigned long long key);

	void removeFromContainerObjects(int index);

	void setContainerVolumeLimit(int lim);

	void setContainerType(int type);

	unsigned int getContainerType();

	ZoneClientSession* getClient();

	unsigned int getGameObjectType();

	unsigned int getClientGameObjectType();

	unsigned int getContainmentType();

	float getDirectionAngle();

	float getSpecialDirectionAngle();

	void rotate(int degrees);

	void faceObject(SceneObject* obj);

	void notifySelfPositionUpdate();

	void notifyPositionUpdate(QuadTreeEntry* entry);

	void notifyCloseContainer(CreatureObject* player);

	unsigned int getMovementCounter();

	ManagedWeakReference<SceneObject* > getParent();

	void setParent(QuadTreeEntry* entry);

	ZoneServer* getZoneServer();

	ManagedWeakReference<SceneObject* > getRootParent();

	ManagedWeakReference<SceneObject* > getParentRecursively(unsigned int gameObjectType);

	bool isASubChildOf(SceneObject* object);

	UnicodeString getCustomObjectName();

	String getLoggingName();

	bool isPlayerCreature();

	bool isDecoration();

	void setZoneComponent(const String& name);

	bool isNoTrade();

	bool isContainerFull();

	bool isShuttleInstallation();

	bool isPlayerObject();

	bool isActiveArea();

	bool isRegion();

	bool isCreatureObject();

	bool isAiAgent();

	bool isJunkDealer();

	bool isShipObject();

	bool isVehicleObject();

	bool isBuildingObject();

	bool isCloningBuildingObject();

	bool isGarage();

	bool isWeaponObject();

	bool isWearableObject();

	bool isWearableContainerObject();

	bool isArmorObject();

	bool isRobeObject();

	bool isLightsaberCrystalObject();

	bool isFireworkObject();

	bool isPsgArmorObject();

	bool isCellObject();

	bool isTangibleObject();

	bool isResourceContainer();

	bool isResourceSpawn();

	bool isComponent();

	bool isIntangibleObject();

	bool isInstrument();

	bool isBazaarTerminal();

	bool isLiveSample();

	bool isInstallationObject();

	bool isHarvesterObject();

	bool isGeneratorObject();

	bool isCityTerminal();

	bool isCityVoteTerminal();

	bool isFactory();

	bool isFactoryCrate();

	bool isFishingPoleObject();

	bool isDeedObject();

	bool isVehicleDeedObject();

	bool isBuildingDeed();

	bool isSignObject();

	bool isInstallationDeed();

	bool isCraftingTool();

	bool isCraftingStation();

	bool isManufactureSchematic();

	bool isStructureObject();

	bool isAuctionObject();

	bool isFishingBait();

	bool isTrapObject();

	bool isRepairTool();

	bool isCamoKit();

	bool isAttachment();

	bool isDiceObject();

	bool isCreatureHabitat();

	bool isCampKit();

	bool isCampStructure();

	bool isRecycleToolObject();

	void setContainerDefaultAllowPermission(unsigned short perm);

	void clearContainerDefaultAllowPermission(unsigned short perm);

	void setContainerDefaultDenyPermission(unsigned short perm);

	void clearContainerDefaultDenyPermission(unsigned short perm);

	void setContainerInheritPermissionsFromParent(bool val);

	void setContainerOwnerID(unsigned long long id);

	void setContainerAllowPermission(const String& group, unsigned short perm);

	void setContainerDenyPermission(const String& group, unsigned short perm);

	void setGameObjectType(unsigned int type);

	void setClientObjectCRC(unsigned int objCRC);

	void setServerObjectCRC(unsigned int objCRC);

	void setZone(Zone* zone);

	void setDirection(float fw, float fx, float fy, float fz);

	void setDirection(float headingAngleRadians);

	void setMovementCounter(unsigned int count);

	void incrementMovementCounter();

	void setContainmentType(unsigned int type);

	void setLoggingName(const String& name);

	void setClientObject(bool val);

	unsigned int getPlanetCRC();

	bool isStaticObject();

	bool isContainerObject();

	bool isTerminal();

	bool isGroupObject();

	bool isGuildObject();

	bool isControlDevice();

	bool isMissionTerminal();

	bool isMissionObject();

	bool isActorObject();

	int getPlanetMapCategoryCRC();

	int getPlanetMapSubCategoryCRC();

	bool containsChildObject(SceneObject* obj);

	void createChildObjects();

	void initializeChildObject(SceneObject* controllerObject);

	bool isInWater();

	String getDisplayedName();

	bool doSendToClient();

	void setSendToClient(bool val);

};

class SceneObjectHelper : public DistributedObjectClassHelper, public Singleton<SceneObjectHelper> {
	static SceneObjectHelper* staticInitializer;

public:
	SceneObjectHelper();

	void finalizeHelper();

	DistributedObject* instantiateObject();

	DistributedObjectServant* instantiateServant();

	DistributedObjectAdapter* createAdapter(DistributedObjectStub* obj);

	friend class Singleton<SceneObjectHelper>;
};

class MockSceneObject : public SceneObject {
public:

	MOCK_METHOD0(getWorldPositionX,float());
	MOCK_METHOD0(getWorldPositionY,float());
	MOCK_METHOD0(getWorldPositionZ,float());
	MOCK_METHOD0(getWorldPosition,Vector3());

};

} // namespace scene
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::scene;

#endif /*SCENEOBJECT_H_*/
