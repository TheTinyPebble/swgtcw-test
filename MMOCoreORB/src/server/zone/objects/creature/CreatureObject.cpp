/*
 *	server/zone/objects/creature/CreatureObject.cpp generated by engine3 IDL compiler 0.60
 */

#include "CreatureObject.h"

#include "server/chat/StringIdChatParameter.h"

#include "server/zone/objects/creature/professions/SkillBox.h"

#include "server/zone/objects/group/GroupObject.h"

#include "server/zone/objects/guild/GuildObject.h"

#include "server/zone/objects/tangible/weapon/WeaponObject.h"

#include "server/zone/managers/objectcontroller/ObjectController.h"

#include "server/zone/objects/player/PlayerCreature.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/objects/intangible/ControlDevice.h"

#include "server/zone/objects/area/ActiveArea.h"

#include "server/zone/Zone.h"

#include "server/zone/templates/SharedObjectTemplate.h"

#include "server/zone/objects/creature/buffs/Buff.h"

#include "server/zone/objects/tangible/weapon/WeaponObject.h"

/*
 *	CreatureObjectStub
 */

enum {RPC_INITIALIZEMEMBERS__ = 6,RPC_FINALIZE__,RPC_INITIALIZETRANSIENTMEMBERS__,RPC_CLEARQUEUEACTION__INT_FLOAT_INT_INT_,RPC_SENDBASELINESTO__SCENEOBJECT_,RPC_SENDSYSTEMMESSAGE__STRING_,RPC_SENDSYSTEMMESSAGE__UNICODESTRING_,RPC_SENDSYSTEMMESSAGE__STRING_STRING_,RPC_SENDSLOTTEDOBJECTSTO__SCENEOBJECT_,RPC_SETCOMBATSTATE__,RPC_CLEARCOMBATSTATE__BOOL_,RPC_SETPOSTURE__INT_BOOL_,RPC_SETACCELERATIONMULTIPLIERBASE__FLOAT_BOOL_,RPC_SETACCELERATIONMULTIPLIERMOD__FLOAT_BOOL_,RPC_SETSPEEDMULTIPLIERBASE__FLOAT_BOOL_,RPC_SETSPEEDMULTIPLIERMOD__FLOAT_BOOL_,RPC_SETRUNSPEED__FLOAT_BOOL_,RPC_SETHAM__INT_INT_BOOL_,RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_INT_BOOL_BOOL_,RPC_HASDAMAGE__INT_,RPC_HEALDAMAGE__TANGIBLEOBJECT_INT_INT_BOOL_,RPC_SETBASEHAM__INT_INT_BOOL_,RPC_SETWOUNDS__INT_INT_BOOL_,RPC_ADDWOUNDS__INT_INT_BOOL_,RPC_SETMAXHAM__INT_INT_BOOL_,RPC_ADDMAXHAM__INT_INT_BOOL_,RPC_SETENCUMBRANCE__INT_INT_BOOL_,RPC_ADDENCUMBRANCE__INT_INT_BOOL_,RPC_SETWEAPON__WEAPONOBJECT_BOOL_,RPC_NOTIFYOBJECTINSERTED__SCENEOBJECT_,RPC_NOTIFYOBJECTREMOVED__SCENEOBJECT_,RPC_SETINSTRUMENTID__INT_BOOL_,RPC_SETLISTENTOID__LONG_BOOL_,RPC_SETPERFORMANCECOUNTER__INT_BOOL_,RPC_SETPERFORMANCEANIMATION__STRING_BOOL_,RPC_SETSHOCKWOUNDS__INT_BOOL_,RPC_ADDSHOCKWOUNDS__INT_BOOL_,RPC_SETTARGETID__LONG_BOOL_,RPC_SETBANKCREDITS__INT_BOOL_,RPC_ADDBUFF__BUFF_,RPC_REMOVEBUFF__INT_,RPC_REMOVEBUFF__BUFF_,RPC_CLEARBUFFS__BOOL_,RPC_GETBUFF__INT_,RPC_ADDDOTSTATE__LONG_INT_BYTE_INT_FLOAT_INT_,RPC_HEALDOT__LONG_INT_,RPC_CLEARDOTS__,RPC_HASBUFF__INT_,RPC_NOTIFYSELFPOSITIONUPDATE__,RPC_NOTIFYPOSTURECHANGE__INT_,RPC_UPDATETODATABASEALLOBJECTS__BOOL_,RPC_ISRESUSCITABLE__,RPC_ADDBANKCREDITS__INT_BOOL_,RPC_ADDCASHCREDITS__INT_BOOL_,RPC_SUBSTRACTBANKCREDITS__INT_,RPC_SUBSTRACTCASHCREDITS__INT_,RPC_VERIFYCASHCREDITS__INT_,RPC_VERIFYBANKCREDITS__INT_,RPC_ISDANCING__,RPC_ISPLAYINGMUSIC__,RPC_STOPENTERTAINING__,RPC_ISENTERTAINING__,RPC_SETCASHCREDITS__INT_BOOL_,RPC_SETTERRAINNEGOTIATION__FLOAT_BOOL_,RPC_ADDSKILLBOX__STRING_BOOL_,RPC_REMOVESKILLBOX__STRING_BOOL_,RPC_ADDSKILLMOD__STRING_LONG_BOOL_,RPC_REMOVESKILLMOD__STRING_BOOL_,RPC_UPDATEGROUPINVITERID__LONG_BOOL_,RPC_UPDATEGROUP__GROUPOBJECT_BOOL_,RPC_ENQUEUECOMMAND__INT_INT_LONG_UNICODESTRING_INT_,RPC_SETMOOD__BYTE_BOOL_,RPC_SETMOODSTRING__STRING_BOOL_,RPC_DELETEQUEUEACTION__INT_,RPC_SETSTATE__LONG_BOOL_,RPC_CLEARSTATE__LONG_BOOL_,RPC_SETCONTROLDEVICE__CONTROLDEVICE_,RPC_GETWEARABLEMASK__,RPC_SETCREATURELINK__CREATUREOBJECT_BOOL_,RPC_EXECUTEOBJECTCONTROLLERACTION__INT_,RPC_EXECUTEOBJECTCONTROLLERACTION__INT_LONG_UNICODESTRING_,RPC_ISATTACKABLEBY__CREATUREOBJECT_,RPC_SENDCONVERSATIONSTARTTO__SCENEOBJECT_,RPC_SELECTCONVERSATIONOPTION__INT_SCENEOBJECT_,RPC_CANTREATINJURIES__,RPC_CANTREATSTATES__,RPC_CANTREATWOUNDS__,RPC_CANTREATCONDITIONS__,RPC_ISLISTENING__,RPC_ISWATCHING__,RPC_DISMOUNT__,RPC_CALCULATEBFRATIO__,RPC_SETDIZZIEDSTATE__INT_,RPC_SETRALLIEDSTATE__INT_,RPC_SETAIMINGSTATE__INT_,RPC_SETCOVERSTATE__INT_,RPC_SETBERSERKEDSTATE__INT_,RPC_SETSTUNNEDSTATE__INT_,RPC_SETBLINDEDSTATE__INT_,RPC_SETINTIMIDATEDSTATE__INT_,RPC_SETSNAREDSTATE__INT_,RPC_SETROOTEDSTATE__INT_,RPC_SETNEXTATTACKDELAY__INT_,RPC_SETMEDITATESTATE__,RPC_ACTIVATEHAMREGENERATION__,RPC_ACTIVATESTATERECOVERY__,RPC_UPDATETIMEOFDEATH__,RPC_HASATTACKDELAY__,RPC_REMOVEATTACKDELAY__,RPC_HASSPICE__,RPC_UPDATELASTSUCCESSFULCOMBATACTION__,RPC_UPDATEKNOCKDOWNRECOVERY__,RPC_QUEUEDIZZYFALLEVENT__,RPC_UPDATELASTKNOCKDOWN__,RPC_CHECKKNOCKDOWNRECOVERY__,RPC_CHECKLASTKNOCKDOWN__,RPC_UPDATEPOSTUREDOWNRECOVERY__,RPC_UPDATEPOSTUREUPRECOVERY__,RPC_CHECKPOSTUREDOWNRECOVERY__,RPC_CHECKPOSTUREUPRECOVERY__,RPC_UPDATECOOLDOWNTIMER__STRING_INT_,RPC_CHECKCOOLDOWNRECOVERY__STRING_,RPC_ADDCOOLDOWN__STRING_INT_,RPC_CANADDOBJECT__SCENEOBJECT_INT_STRING_,RPC_DOANIMATION__STRING_,RPC_DOCOMBATANIMATION__CREATUREOBJECT_INT_BYTE_,RPC_PLAYEFFECT__STRING_STRING_,RPC_PLAYEFFECT__STRING_,RPC_SHOWFLYTEXT__STRING_STRING_BYTE_BYTE_BYTE_,RPC_ACTIVATEQUEUEACTION__,RPC_GETCREATURENAME__,RPC_ISGROUPED__,RPC_GETBANKCREDITS__,RPC_GETCASHCREDITS__,RPC_GETBASEHAM__INT_,RPC_GETWOUNDS__INT_,RPC_GETHAM__INT_,RPC_GETMAXHAM__INT_,RPC_GETENCUMBRANCE__INT_,RPC_GETPOSTURE__,RPC_GETFACTIONRANK__,RPC_GETLINKEDCREATURE__,RPC_GETCREATURELINKID__,RPC_GETSHOCKWOUNDS__,RPC_GETWATCHTOID__,RPC_GETSTATEBITMASK__,RPC_HASSTATE__LONG_,RPC_HASSTATES__,RPC_GETLISTENID__,RPC_GETACCELERATIONMULTIPLIERBASE__,RPC_GETACCELERATIONMULTIPLIERMOD__,RPC_GETSPEEDMULTIPLIERBASE__,RPC_GETSPEEDMULTIPLIERMOD__,RPC_GETRUNSPEED__,RPC_GETWALKSPEED__,RPC_GETTERRAINNEGOTIATION__,RPC_GETRUNACCELERATION__,RPC_GETWALKACCELERATION__,RPC_GETPERFORMANCEANIMATION__,RPC_GETMOODSTRING__,RPC_GETWEAPONID__,RPC_GETWEAPON__,RPC_GETGUILDOBJECT__,RPC_GETGUILDID__,RPC_ISINGUILD__,RPC_SETGUILDOBJECT__GUILDOBJECT_,RPC_GETGROUPID__,RPC_GETGROUPINVITERID__,RPC_GETGROUP__,RPC_GETGROUPINVITECOUNTER__,RPC_GETTARGETID__,RPC_GETMOODID__,RPC_GETSLOPEMODPERCENT__,RPC_GETPERFORMANCECOUNTER__,RPC_GETINSTRUMENTID__,RPC_GETFROZEN__,RPC_GETHEIGHT__,RPC_GETSPECIES__,RPC_GETSPECIESNAME__,RPC_GETGENDER__,RPC_GETSKILLMOD__STRING_,RPC_HASSKILLBOX__STRING_,RPC_SETHEIGHT__FLOAT_,RPC_SETWATCHTOID__LONG_,RPC_ISCREATUREOBJECT__,RPC_ISTRAINERCREATURE__,RPC_ISSWIMMING__,RPC_ISRIDINGMOUNT__,RPC_GETCONTROLDEVICE__,RPC_GETSWIMHEIGHT__,RPC_ISINCAPACITATED__,RPC_ISDEAD__,RPC_ISKNOCKEDDOWN__,RPC_ISKNEELING__,RPC_ISPRONE__,RPC_ISSTANDING__,RPC_ISSITTING__,RPC_ISSKILLANIMATING__,RPC_ISRALLIED__,RPC_ISINCOMBAT__,RPC_ISDIZZIED__,RPC_ISBERSERKED__,RPC_ISSTUNNED__,RPC_ISBLINDED__,RPC_ISINTIMIDATED__,RPC_ISSNARED__,RPC_ISROOTED__,RPC_ISDISEASED__,RPC_ISPOISONED__,RPC_ISBLEEDING__,RPC_ISONFIRE__,RPC_ISMOUNTED__,RPC_ISRIDINGCREATURE__,RPC_ISPEACED__,RPC_ISMEDITATING__,RPC_ISAIMING__,RPC_ISINCOVER__,RPC_ISNONPLAYERCREATURE__,RPC_ISCREATURE__,RPC_ISAIAGENT__,RPC_ISINFORMANTCREATURE__,RPC_ISVENDORCREATURE__};

CreatureObject::CreatureObject() : TangibleObject(DummyConstructorParameter::instance()) {
	CreatureObjectImplementation* _implementation = new CreatureObjectImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
}

CreatureObject::CreatureObject(DummyConstructorParameter* param) : TangibleObject(param) {
}

CreatureObject::~CreatureObject() {
}


void CreatureObject::initializeMembers() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZEMEMBERS__);

		method.executeWithVoidReturn();
	} else
		_implementation->initializeMembers();
}

void CreatureObject::loadTemplateData(SharedObjectTemplate* templateData) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->loadTemplateData(templateData);
}

void CreatureObject::initializeTransientMembers() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else
		_implementation->initializeTransientMembers();
}

void CreatureObject::clearQueueAction(unsigned int actioncntr, float timer, unsigned int tab1, unsigned int tab2) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARQUEUEACTION__INT_FLOAT_INT_INT_);
		method.addUnsignedIntParameter(actioncntr);
		method.addFloatParameter(timer);
		method.addUnsignedIntParameter(tab1);
		method.addUnsignedIntParameter(tab2);

		method.executeWithVoidReturn();
	} else
		_implementation->clearQueueAction(actioncntr, timer, tab1, tab2);
}

void CreatureObject::sendBaselinesTo(SceneObject* player) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDBASELINESTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		_implementation->sendBaselinesTo(player);
}

void CreatureObject::sendSystemMessage(const String& message) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDSYSTEMMESSAGE__STRING_);
		method.addAsciiParameter(message);

		method.executeWithVoidReturn();
	} else
		_implementation->sendSystemMessage(message);
}

void CreatureObject::sendSystemMessage(UnicodeString& message) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDSYSTEMMESSAGE__UNICODESTRING_);
		method.addUnicodeParameter(message);

		method.executeWithVoidReturn();
	} else
		_implementation->sendSystemMessage(message);
}

void CreatureObject::sendSystemMessage(const String& file, const String& stringid) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDSYSTEMMESSAGE__STRING_STRING_);
		method.addAsciiParameter(file);
		method.addAsciiParameter(stringid);

		method.executeWithVoidReturn();
	} else
		_implementation->sendSystemMessage(file, stringid);
}

void CreatureObject::sendSystemMessage(StringIdChatParameter& stringid) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->sendSystemMessage(stringid);
}

void CreatureObject::sendSlottedObjectsTo(SceneObject* player) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDSLOTTEDOBJECTSTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		_implementation->sendSlottedObjectsTo(player);
}

void CreatureObject::setCombatState() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCOMBATSTATE__);

		method.executeWithVoidReturn();
	} else
		_implementation->setCombatState();
}

void CreatureObject::clearCombatState(bool clearDefenders) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARCOMBATSTATE__BOOL_);
		method.addBooleanParameter(clearDefenders);

		method.executeWithVoidReturn();
	} else
		_implementation->clearCombatState(clearDefenders);
}

void CreatureObject::setPosture(int newPosture, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPOSTURE__INT_BOOL_);
		method.addSignedIntParameter(newPosture);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setPosture(newPosture, notifyClient);
}

void CreatureObject::setAccelerationMultiplierBase(float newMultiplierBase, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETACCELERATIONMULTIPLIERBASE__FLOAT_BOOL_);
		method.addFloatParameter(newMultiplierBase);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setAccelerationMultiplierBase(newMultiplierBase, notifyClient);
}

void CreatureObject::setAccelerationMultiplierMod(float newMultiplierMod, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETACCELERATIONMULTIPLIERMOD__FLOAT_BOOL_);
		method.addFloatParameter(newMultiplierMod);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setAccelerationMultiplierMod(newMultiplierMod, notifyClient);
}

void CreatureObject::setSpeedMultiplierBase(float newMultiplierBase, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSPEEDMULTIPLIERBASE__FLOAT_BOOL_);
		method.addFloatParameter(newMultiplierBase);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setSpeedMultiplierBase(newMultiplierBase, notifyClient);
}

void CreatureObject::setSpeedMultiplierMod(float newMultiplierMod, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSPEEDMULTIPLIERMOD__FLOAT_BOOL_);
		method.addFloatParameter(newMultiplierMod);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setSpeedMultiplierMod(newMultiplierMod, notifyClient);
}

void CreatureObject::setRunSpeed(float newSpeed, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETRUNSPEED__FLOAT_BOOL_);
		method.addFloatParameter(newSpeed);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setRunSpeed(newSpeed, notifyClient);
}

void CreatureObject::setHAM(int type, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETHAM__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setHAM(type, value, notifyClient);
}

int CreatureObject::inflictDamage(TangibleObject* attacker, int damageType, int damage, bool destroy, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_INT_BOOL_BOOL_);
		method.addObjectParameter(attacker);
		method.addSignedIntParameter(damageType);
		method.addSignedIntParameter(damage);
		method.addBooleanParameter(destroy);
		method.addBooleanParameter(notifyClient);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->inflictDamage(attacker, damageType, damage, destroy, notifyClient);
}

bool CreatureObject::hasDamage(int attribute) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASDAMAGE__INT_);
		method.addSignedIntParameter(attribute);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasDamage(attribute);
}

int CreatureObject::healDamage(TangibleObject* healer, int damageType, int damage, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HEALDAMAGE__TANGIBLEOBJECT_INT_INT_BOOL_);
		method.addObjectParameter(healer);
		method.addSignedIntParameter(damageType);
		method.addSignedIntParameter(damage);
		method.addBooleanParameter(notifyClient);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->healDamage(healer, damageType, damage, notifyClient);
}

void CreatureObject::setBaseHAM(int type, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBASEHAM__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setBaseHAM(type, value, notifyClient);
}

void CreatureObject::setWounds(int type, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETWOUNDS__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setWounds(type, value, notifyClient);
}

int CreatureObject::addWounds(int type, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDWOUNDS__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->addWounds(type, value, notifyClient);
}

void CreatureObject::setMaxHAM(int type, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMAXHAM__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setMaxHAM(type, value, notifyClient);
}

void CreatureObject::addMaxHAM(int type, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDMAXHAM__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->addMaxHAM(type, value, notifyClient);
}

void CreatureObject::setEncumbrance(int type, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETENCUMBRANCE__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setEncumbrance(type, value, notifyClient);
}

void CreatureObject::addEncumbrance(int type, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDENCUMBRANCE__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->addEncumbrance(type, value, notifyClient);
}

void CreatureObject::setWeapon(WeaponObject* weao, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETWEAPON__WEAPONOBJECT_BOOL_);
		method.addObjectParameter(weao);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setWeapon(weao, notifyClient);
}

int CreatureObject::notifyObjectInserted(SceneObject* object) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYOBJECTINSERTED__SCENEOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->notifyObjectInserted(object);
}

int CreatureObject::notifyObjectRemoved(SceneObject* object) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYOBJECTREMOVED__SCENEOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->notifyObjectRemoved(object);
}

void CreatureObject::setInstrumentID(int instrumentid, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETINSTRUMENTID__INT_BOOL_);
		method.addSignedIntParameter(instrumentid);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setInstrumentID(instrumentid, notifyClient);
}

void CreatureObject::setListenToID(unsigned long long id, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLISTENTOID__LONG_BOOL_);
		method.addUnsignedLongParameter(id);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setListenToID(id, notifyClient);
}

void CreatureObject::setPerformanceCounter(int counter, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPERFORMANCECOUNTER__INT_BOOL_);
		method.addSignedIntParameter(counter);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setPerformanceCounter(counter, notifyClient);
}

void CreatureObject::setPerformanceAnimation(const String& animation, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPERFORMANCEANIMATION__STRING_BOOL_);
		method.addAsciiParameter(animation);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setPerformanceAnimation(animation, notifyClient);
}

void CreatureObject::setShockWounds(int newShock, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSHOCKWOUNDS__INT_BOOL_);
		method.addSignedIntParameter(newShock);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setShockWounds(newShock, notifyClient);
}

void CreatureObject::addShockWounds(int shockToAdd, bool notiyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSHOCKWOUNDS__INT_BOOL_);
		method.addSignedIntParameter(shockToAdd);
		method.addBooleanParameter(notiyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->addShockWounds(shockToAdd, notiyClient);
}

void CreatureObject::setTargetID(unsigned long long targetID, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETTARGETID__LONG_BOOL_);
		method.addUnsignedLongParameter(targetID);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setTargetID(targetID, notifyClient);
}

void CreatureObject::setBankCredits(int credits, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBANKCREDITS__INT_BOOL_);
		method.addSignedIntParameter(credits);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setBankCredits(credits, notifyClient);
}

void CreatureObject::addBuff(Buff* buff) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDBUFF__BUFF_);
		method.addObjectParameter(buff);

		method.executeWithVoidReturn();
	} else
		_implementation->addBuff(buff);
}

void CreatureObject::removeBuff(unsigned int buffcrc) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEBUFF__INT_);
		method.addUnsignedIntParameter(buffcrc);

		method.executeWithVoidReturn();
	} else
		_implementation->removeBuff(buffcrc);
}

void CreatureObject::removeBuff(Buff* buff) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEBUFF__BUFF_);
		method.addObjectParameter(buff);

		method.executeWithVoidReturn();
	} else
		_implementation->removeBuff(buff);
}

void CreatureObject::clearBuffs(bool updateclient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARBUFFS__BOOL_);
		method.addBooleanParameter(updateclient);

		method.executeWithVoidReturn();
	} else
		_implementation->clearBuffs(updateclient);
}

Buff* CreatureObject::getBuff(unsigned int buffcrc) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBUFF__INT_);
		method.addUnsignedIntParameter(buffcrc);

		return (Buff*) method.executeWithObjectReturn();
	} else
		return _implementation->getBuff(buffcrc);
}

int CreatureObject::addDotState(unsigned long long dotType, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDDOTSTATE__LONG_INT_BYTE_INT_FLOAT_INT_);
		method.addUnsignedLongParameter(dotType);
		method.addUnsignedIntParameter(strength);
		method.addByteParameter(type);
		method.addUnsignedIntParameter(duration);
		method.addFloatParameter(potency);
		method.addUnsignedIntParameter(defense);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->addDotState(dotType, strength, type, duration, potency, defense);
}

bool CreatureObject::healDot(unsigned long long dotType, int reduction) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HEALDOT__LONG_INT_);
		method.addUnsignedLongParameter(dotType);
		method.addSignedIntParameter(reduction);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->healDot(dotType, reduction);
}

void CreatureObject::clearDots() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARDOTS__);

		method.executeWithVoidReturn();
	} else
		_implementation->clearDots();
}

bool CreatureObject::hasBuff(unsigned int buffcrc) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASBUFF__INT_);
		method.addUnsignedIntParameter(buffcrc);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasBuff(buffcrc);
}

void CreatureObject::notifySelfPositionUpdate() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYSELFPOSITIONUPDATE__);

		method.executeWithVoidReturn();
	} else
		_implementation->notifySelfPositionUpdate();
}

void CreatureObject::notifyPostureChange(int newPosture) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYPOSTURECHANGE__INT_);
		method.addSignedIntParameter(newPosture);

		method.executeWithVoidReturn();
	} else
		_implementation->notifyPostureChange(newPosture);
}

void CreatureObject::updateToDatabaseAllObjects(bool startTask) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATETODATABASEALLOBJECTS__BOOL_);
		method.addBooleanParameter(startTask);

		method.executeWithVoidReturn();
	} else
		_implementation->updateToDatabaseAllObjects(startTask);
}

bool CreatureObject::isResuscitable() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRESUSCITABLE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isResuscitable();
}

void CreatureObject::addBankCredits(int credits, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDBANKCREDITS__INT_BOOL_);
		method.addSignedIntParameter(credits);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->addBankCredits(credits, notifyClient);
}

void CreatureObject::addCashCredits(int credits, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDCASHCREDITS__INT_BOOL_);
		method.addSignedIntParameter(credits);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->addCashCredits(credits, notifyClient);
}

void CreatureObject::substractBankCredits(int credits) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SUBSTRACTBANKCREDITS__INT_);
		method.addSignedIntParameter(credits);

		method.executeWithVoidReturn();
	} else
		_implementation->substractBankCredits(credits);
}

void CreatureObject::substractCashCredits(int credits) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SUBSTRACTCASHCREDITS__INT_);
		method.addSignedIntParameter(credits);

		method.executeWithVoidReturn();
	} else
		_implementation->substractCashCredits(credits);
}

bool CreatureObject::verifyCashCredits(int credits) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_VERIFYCASHCREDITS__INT_);
		method.addSignedIntParameter(credits);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->verifyCashCredits(credits);
}

bool CreatureObject::verifyBankCredits(int credits) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_VERIFYBANKCREDITS__INT_);
		method.addSignedIntParameter(credits);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->verifyBankCredits(credits);
}

bool CreatureObject::isDancing() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDANCING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isDancing();
}

bool CreatureObject::isPlayingMusic() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPLAYINGMUSIC__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isPlayingMusic();
}

void CreatureObject::stopEntertaining() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STOPENTERTAINING__);

		method.executeWithVoidReturn();
	} else
		_implementation->stopEntertaining();
}

bool CreatureObject::isEntertaining() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISENTERTAINING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isEntertaining();
}

void CreatureObject::setCashCredits(int credits, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCASHCREDITS__INT_BOOL_);
		method.addSignedIntParameter(credits);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setCashCredits(credits, notifyClient);
}

void CreatureObject::setTerrainNegotiation(float value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETTERRAINNEGOTIATION__FLOAT_BOOL_);
		method.addFloatParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setTerrainNegotiation(value, notifyClient);
}

void CreatureObject::addSkillBox(SkillBox* skillBox, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->addSkillBox(skillBox, notifyClient);
}

void CreatureObject::addSkillBox(const String& skillBox, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSKILLBOX__STRING_BOOL_);
		method.addAsciiParameter(skillBox);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->addSkillBox(skillBox, notifyClient);
}

void CreatureObject::removeSkillBox(SkillBox* skillBox, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->removeSkillBox(skillBox, notifyClient);
}

void CreatureObject::removeSkillBox(const String& skillBox, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVESKILLBOX__STRING_BOOL_);
		method.addAsciiParameter(skillBox);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->removeSkillBox(skillBox, notifyClient);
}

void CreatureObject::addSkillMod(const String& skillMod, long long value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSKILLMOD__STRING_LONG_BOOL_);
		method.addAsciiParameter(skillMod);
		method.addSignedLongParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->addSkillMod(skillMod, value, notifyClient);
}

void CreatureObject::removeSkillMod(const String& skillMod, bool notifyCLient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVESKILLMOD__STRING_BOOL_);
		method.addAsciiParameter(skillMod);
		method.addBooleanParameter(notifyCLient);

		method.executeWithVoidReturn();
	} else
		_implementation->removeSkillMod(skillMod, notifyCLient);
}

void CreatureObject::updateGroupInviterID(unsigned long long id, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEGROUPINVITERID__LONG_BOOL_);
		method.addUnsignedLongParameter(id);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->updateGroupInviterID(id, notifyClient);
}

void CreatureObject::updateGroup(GroupObject* group, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEGROUP__GROUPOBJECT_BOOL_);
		method.addObjectParameter(group);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->updateGroup(group, notifyClient);
}

void CreatureObject::enqueueCommand(unsigned int actionCRC, unsigned int actionCount, unsigned long long targetID, const UnicodeString& arguments, int priority) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ENQUEUECOMMAND__INT_INT_LONG_UNICODESTRING_INT_);
		method.addUnsignedIntParameter(actionCRC);
		method.addUnsignedIntParameter(actionCount);
		method.addUnsignedLongParameter(targetID);
		method.addUnicodeParameter(arguments);
		method.addSignedIntParameter(priority);

		method.executeWithVoidReturn();
	} else
		_implementation->enqueueCommand(actionCRC, actionCount, targetID, arguments, priority);
}

void CreatureObject::setMood(byte moodID, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMOOD__BYTE_BOOL_);
		method.addByteParameter(moodID);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setMood(moodID, notifyClient);
}

void CreatureObject::setMoodString(const String& animation, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMOODSTRING__STRING_BOOL_);
		method.addAsciiParameter(animation);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setMoodString(animation, notifyClient);
}

void CreatureObject::deleteQueueAction(unsigned int actionCount) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DELETEQUEUEACTION__INT_);
		method.addUnsignedIntParameter(actionCount);

		method.executeWithVoidReturn();
	} else
		_implementation->deleteQueueAction(actionCount);
}

bool CreatureObject::setState(unsigned long long state, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSTATE__LONG_BOOL_);
		method.addUnsignedLongParameter(state);
		method.addBooleanParameter(notifyClient);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->setState(state, notifyClient);
}

bool CreatureObject::clearState(unsigned long long state, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARSTATE__LONG_BOOL_);
		method.addUnsignedLongParameter(state);
		method.addBooleanParameter(notifyClient);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->clearState(state, notifyClient);
}

void CreatureObject::setControlDevice(ControlDevice* device) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCONTROLDEVICE__CONTROLDEVICE_);
		method.addObjectParameter(device);

		method.executeWithVoidReturn();
	} else
		_implementation->setControlDevice(device);
}

unsigned int CreatureObject::getWearableMask() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWEARABLEMASK__);

		return method.executeWithUnsignedIntReturn();
	} else
		return _implementation->getWearableMask();
}

void CreatureObject::setCreatureLink(CreatureObject* object, bool notifyClient) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCREATURELINK__CREATUREOBJECT_BOOL_);
		method.addObjectParameter(object);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setCreatureLink(object, notifyClient);
}

void CreatureObject::executeObjectControllerAction(unsigned int actionCRC) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_EXECUTEOBJECTCONTROLLERACTION__INT_);
		method.addUnsignedIntParameter(actionCRC);

		method.executeWithVoidReturn();
	} else
		_implementation->executeObjectControllerAction(actionCRC);
}

void CreatureObject::executeObjectControllerAction(unsigned int actionCRC, unsigned long long targetID, const UnicodeString& args) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_EXECUTEOBJECTCONTROLLERACTION__INT_LONG_UNICODESTRING_);
		method.addUnsignedIntParameter(actionCRC);
		method.addUnsignedLongParameter(targetID);
		method.addUnicodeParameter(args);

		method.executeWithVoidReturn();
	} else
		_implementation->executeObjectControllerAction(actionCRC, targetID, args);
}

bool CreatureObject::isAttackableBy(CreatureObject* object) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISATTACKABLEBY__CREATUREOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isAttackableBy(object);
}

void CreatureObject::sendConversationStartTo(SceneObject* player) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDCONVERSATIONSTARTTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		_implementation->sendConversationStartTo(player);
}

void CreatureObject::selectConversationOption(int option, SceneObject* obj) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SELECTCONVERSATIONOPTION__INT_SCENEOBJECT_);
		method.addSignedIntParameter(option);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else
		_implementation->selectConversationOption(option, obj);
}

bool CreatureObject::canTreatInjuries() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANTREATINJURIES__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->canTreatInjuries();
}

bool CreatureObject::canTreatStates() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANTREATSTATES__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->canTreatStates();
}

bool CreatureObject::canTreatWounds() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANTREATWOUNDS__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->canTreatWounds();
}

bool CreatureObject::canTreatConditions() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANTREATCONDITIONS__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->canTreatConditions();
}

bool CreatureObject::isListening() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISLISTENING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isListening();
}

bool CreatureObject::isWatching() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISWATCHING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isWatching();
}

void CreatureObject::dismount() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DISMOUNT__);

		method.executeWithVoidReturn();
	} else
		_implementation->dismount();
}

float CreatureObject::calculateBFRatio() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CALCULATEBFRATIO__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->calculateBFRatio();
}

void CreatureObject::setDizziedState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDIZZIEDSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else
		_implementation->setDizziedState(durationSeconds);
}

void CreatureObject::setRalliedState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETRALLIEDSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else
		_implementation->setRalliedState(durationSeconds);
}

void CreatureObject::setAimingState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETAIMINGSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else
		_implementation->setAimingState(durationSeconds);
}

void CreatureObject::setCoverState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCOVERSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else
		_implementation->setCoverState(durationSeconds);
}

void CreatureObject::setBerserkedState(unsigned int duration) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBERSERKEDSTATE__INT_);
		method.addUnsignedIntParameter(duration);

		method.executeWithVoidReturn();
	} else
		_implementation->setBerserkedState(duration);
}

void CreatureObject::setStunnedState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSTUNNEDSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else
		_implementation->setStunnedState(durationSeconds);
}

void CreatureObject::setBlindedState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBLINDEDSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else
		_implementation->setBlindedState(durationSeconds);
}

void CreatureObject::setIntimidatedState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETINTIMIDATEDSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else
		_implementation->setIntimidatedState(durationSeconds);
}

void CreatureObject::setSnaredState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSNAREDSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else
		_implementation->setSnaredState(durationSeconds);
}

void CreatureObject::setRootedState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETROOTEDSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else
		_implementation->setRootedState(durationSeconds);
}

bool CreatureObject::setNextAttackDelay(int del) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETNEXTATTACKDELAY__INT_);
		method.addSignedIntParameter(del);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->setNextAttackDelay(del);
}

void CreatureObject::setMeditateState() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMEDITATESTATE__);

		method.executeWithVoidReturn();
	} else
		_implementation->setMeditateState();
}

void CreatureObject::activateHAMRegeneration() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEHAMREGENERATION__);

		method.executeWithVoidReturn();
	} else
		_implementation->activateHAMRegeneration();
}

void CreatureObject::activateStateRecovery() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATESTATERECOVERY__);

		method.executeWithVoidReturn();
	} else
		_implementation->activateStateRecovery();
}

void CreatureObject::updateTimeOfDeath() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATETIMEOFDEATH__);

		method.executeWithVoidReturn();
	} else
		_implementation->updateTimeOfDeath();
}

bool CreatureObject::hasAttackDelay() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASATTACKDELAY__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasAttackDelay();
}

void CreatureObject::removeAttackDelay() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEATTACKDELAY__);

		method.executeWithVoidReturn();
	} else
		_implementation->removeAttackDelay();
}

bool CreatureObject::hasSpice() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSPICE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasSpice();
}

void CreatureObject::updateLastSuccessfulCombatAction() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATELASTSUCCESSFULCOMBATACTION__);

		method.executeWithVoidReturn();
	} else
		_implementation->updateLastSuccessfulCombatAction();
}

void CreatureObject::updateKnockdownRecovery() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEKNOCKDOWNRECOVERY__);

		method.executeWithVoidReturn();
	} else
		_implementation->updateKnockdownRecovery();
}

void CreatureObject::queueDizzyFallEvent() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_QUEUEDIZZYFALLEVENT__);

		method.executeWithVoidReturn();
	} else
		_implementation->queueDizzyFallEvent();
}

void CreatureObject::updateLastKnockdown() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATELASTKNOCKDOWN__);

		method.executeWithVoidReturn();
	} else
		_implementation->updateLastKnockdown();
}

bool CreatureObject::checkKnockdownRecovery() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKKNOCKDOWNRECOVERY__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->checkKnockdownRecovery();
}

bool CreatureObject::checkLastKnockdown() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKLASTKNOCKDOWN__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->checkLastKnockdown();
}

void CreatureObject::updatePostureDownRecovery() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEPOSTUREDOWNRECOVERY__);

		method.executeWithVoidReturn();
	} else
		_implementation->updatePostureDownRecovery();
}

void CreatureObject::updatePostureUpRecovery() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEPOSTUREUPRECOVERY__);

		method.executeWithVoidReturn();
	} else
		_implementation->updatePostureUpRecovery();
}

bool CreatureObject::checkPostureDownRecovery() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKPOSTUREDOWNRECOVERY__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->checkPostureDownRecovery();
}

bool CreatureObject::checkPostureUpRecovery() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKPOSTUREUPRECOVERY__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->checkPostureUpRecovery();
}

void CreatureObject::updateCooldownTimer(const String& coooldownTimer, unsigned int miliSecondsToAdd) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATECOOLDOWNTIMER__STRING_INT_);
		method.addAsciiParameter(coooldownTimer);
		method.addUnsignedIntParameter(miliSecondsToAdd);

		method.executeWithVoidReturn();
	} else
		_implementation->updateCooldownTimer(coooldownTimer, miliSecondsToAdd);
}

bool CreatureObject::checkCooldownRecovery(const String& cooldown) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKCOOLDOWNRECOVERY__STRING_);
		method.addAsciiParameter(cooldown);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->checkCooldownRecovery(cooldown);
}

Time* CreatureObject::getCooldownTime(const String& cooldown) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getCooldownTime(cooldown);
}

void CreatureObject::addCooldown(const String& name, unsigned int miliseconds) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDCOOLDOWN__STRING_INT_);
		method.addAsciiParameter(name);
		method.addUnsignedIntParameter(miliseconds);

		method.executeWithVoidReturn();
	} else
		_implementation->addCooldown(name, miliseconds);
}

int CreatureObject::canAddObject(SceneObject* object, int containmentType, String& errorDescription) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANADDOBJECT__SCENEOBJECT_INT_STRING_);
		method.addObjectParameter(object);
		method.addSignedIntParameter(containmentType);
		method.addAsciiParameter(errorDescription);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->canAddObject(object, containmentType, errorDescription);
}

void CreatureObject::doAnimation(const String& animation) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOANIMATION__STRING_);
		method.addAsciiParameter(animation);

		method.executeWithVoidReturn();
	} else
		_implementation->doAnimation(animation);
}

void CreatureObject::doCombatAnimation(CreatureObject* defender, unsigned int animationCRC, byte hit) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOCOMBATANIMATION__CREATUREOBJECT_INT_BYTE_);
		method.addObjectParameter(defender);
		method.addUnsignedIntParameter(animationCRC);
		method.addByteParameter(hit);

		method.executeWithVoidReturn();
	} else
		_implementation->doCombatAnimation(defender, animationCRC, hit);
}

void CreatureObject::playEffect(const String& file, const String& aux) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_PLAYEFFECT__STRING_STRING_);
		method.addAsciiParameter(file);
		method.addAsciiParameter(aux);

		method.executeWithVoidReturn();
	} else
		_implementation->playEffect(file, aux);
}

void CreatureObject::playEffect(const String& file) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_PLAYEFFECT__STRING_);
		method.addAsciiParameter(file);

		method.executeWithVoidReturn();
	} else
		_implementation->playEffect(file);
}

void CreatureObject::showFlyText(const String& file, const String& uax, byte red, byte green, byte blue) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SHOWFLYTEXT__STRING_STRING_BYTE_BYTE_BYTE_);
		method.addAsciiParameter(file);
		method.addAsciiParameter(uax);
		method.addByteParameter(red);
		method.addByteParameter(green);
		method.addByteParameter(blue);

		method.executeWithVoidReturn();
	} else
		_implementation->showFlyText(file, uax, red, green, blue);
}

void CreatureObject::activateQueueAction() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEQUEUEACTION__);

		method.executeWithVoidReturn();
	} else
		_implementation->activateQueueAction();
}

UnicodeString CreatureObject::getCreatureName() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCREATURENAME__);

		method.executeWithUnicodeReturn(_return_getCreatureName);
		return _return_getCreatureName;
	} else
		return _implementation->getCreatureName();
}

bool CreatureObject::isGrouped() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISGROUPED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isGrouped();
}

int CreatureObject::getBankCredits() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBANKCREDITS__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getBankCredits();
}

int CreatureObject::getCashCredits() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCASHCREDITS__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getCashCredits();
}

int CreatureObject::getBaseHAM(int idx) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBASEHAM__INT_);
		method.addSignedIntParameter(idx);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getBaseHAM(idx);
}

int CreatureObject::getWounds(int idx) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWOUNDS__INT_);
		method.addSignedIntParameter(idx);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getWounds(idx);
}

DeltaVector<int>* CreatureObject::getWounds() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getWounds();
}

int CreatureObject::getHAM(int idx) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHAM__INT_);
		method.addSignedIntParameter(idx);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getHAM(idx);
}

DeltaVector<int>* CreatureObject::getHAM() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getHAM();
}

int CreatureObject::getMaxHAM(int idx) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXHAM__INT_);
		method.addSignedIntParameter(idx);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getMaxHAM(idx);
}

DeltaVector<int>* CreatureObject::getMaxHAM() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getMaxHAM();
}

int CreatureObject::getEncumbrance(int idx) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETENCUMBRANCE__INT_);
		method.addSignedIntParameter(idx);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getEncumbrance(idx);
}

DeltaVector<int>* CreatureObject::getEncumbrances() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getEncumbrances();
}

byte CreatureObject::getPosture() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPOSTURE__);

		return method.executeWithByteReturn();
	} else
		return _implementation->getPosture();
}

byte CreatureObject::getFactionRank() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFACTIONRANK__);

		return method.executeWithByteReturn();
	} else
		return _implementation->getFactionRank();
}

CreatureObject* CreatureObject::getLinkedCreature() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLINKEDCREATURE__);

		return (CreatureObject*) method.executeWithObjectReturn();
	} else
		return _implementation->getLinkedCreature();
}

unsigned long long CreatureObject::getCreatureLinkID() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCREATURELINKID__);

		return method.executeWithUnsignedLongReturn();
	} else
		return _implementation->getCreatureLinkID();
}

float CreatureObject::getShockWounds() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSHOCKWOUNDS__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getShockWounds();
}

unsigned long long CreatureObject::getWatchToID() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWATCHTOID__);

		return method.executeWithUnsignedLongReturn();
	} else
		return _implementation->getWatchToID();
}

unsigned long long CreatureObject::getStateBitmask() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSTATEBITMASK__);

		return method.executeWithUnsignedLongReturn();
	} else
		return _implementation->getStateBitmask();
}

bool CreatureObject::hasState(unsigned long long state) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSTATE__LONG_);
		method.addUnsignedLongParameter(state);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasState(state);
}

bool CreatureObject::hasStates() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSTATES__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasStates();
}

unsigned long long CreatureObject::getListenID() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLISTENID__);

		return method.executeWithUnsignedLongReturn();
	} else
		return _implementation->getListenID();
}

float CreatureObject::getAccelerationMultiplierBase() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACCELERATIONMULTIPLIERBASE__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getAccelerationMultiplierBase();
}

float CreatureObject::getAccelerationMultiplierMod() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACCELERATIONMULTIPLIERMOD__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getAccelerationMultiplierMod();
}

float CreatureObject::getSpeedMultiplierBase() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPEEDMULTIPLIERBASE__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getSpeedMultiplierBase();
}

float CreatureObject::getSpeedMultiplierMod() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPEEDMULTIPLIERMOD__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getSpeedMultiplierMod();
}

SpeedMultiplierModChanges* CreatureObject::getSpeedMultiplierModChanges() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getSpeedMultiplierModChanges();
}

float CreatureObject::getRunSpeed() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETRUNSPEED__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getRunSpeed();
}

float CreatureObject::getWalkSpeed() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWALKSPEED__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getWalkSpeed();
}

float CreatureObject::getTerrainNegotiation() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTERRAINNEGOTIATION__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getTerrainNegotiation();
}

float CreatureObject::getRunAcceleration() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETRUNACCELERATION__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getRunAcceleration();
}

float CreatureObject::getWalkAcceleration() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWALKACCELERATION__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getWalkAcceleration();
}

String CreatureObject::getPerformanceAnimation() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPERFORMANCEANIMATION__);

		method.executeWithAsciiReturn(_return_getPerformanceAnimation);
		return _return_getPerformanceAnimation;
	} else
		return _implementation->getPerformanceAnimation();
}

String CreatureObject::getMoodString() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMOODSTRING__);

		method.executeWithAsciiReturn(_return_getMoodString);
		return _return_getMoodString;
	} else
		return _implementation->getMoodString();
}

unsigned long long CreatureObject::getWeaponID() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWEAPONID__);

		return method.executeWithUnsignedLongReturn();
	} else
		return _implementation->getWeaponID();
}

WeaponObject* CreatureObject::getWeapon() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWEAPON__);

		return (WeaponObject*) method.executeWithObjectReturn();
	} else
		return _implementation->getWeapon();
}

GuildObject* CreatureObject::getGuildObject() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGUILDOBJECT__);

		return (GuildObject*) method.executeWithObjectReturn();
	} else
		return _implementation->getGuildObject();
}

int CreatureObject::getGuildID() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGUILDID__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getGuildID();
}

bool CreatureObject::isInGuild() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINGUILD__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isInGuild();
}

void CreatureObject::setGuildObject(GuildObject* guildobj) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETGUILDOBJECT__GUILDOBJECT_);
		method.addObjectParameter(guildobj);

		method.executeWithVoidReturn();
	} else
		_implementation->setGuildObject(guildobj);
}

unsigned long long CreatureObject::getGroupID() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGROUPID__);

		return method.executeWithUnsignedLongReturn();
	} else
		return _implementation->getGroupID();
}

unsigned long long CreatureObject::getGroupInviterID() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGROUPINVITERID__);

		return method.executeWithUnsignedLongReturn();
	} else
		return _implementation->getGroupInviterID();
}

GroupObject* CreatureObject::getGroup() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGROUP__);

		return (GroupObject*) method.executeWithObjectReturn();
	} else
		return _implementation->getGroup();
}

unsigned long long CreatureObject::getGroupInviteCounter() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGROUPINVITECOUNTER__);

		return method.executeWithUnsignedLongReturn();
	} else
		return _implementation->getGroupInviteCounter();
}

unsigned long long CreatureObject::getTargetID() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTARGETID__);

		return method.executeWithUnsignedLongReturn();
	} else
		return _implementation->getTargetID();
}

byte CreatureObject::getMoodID() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMOODID__);

		return method.executeWithByteReturn();
	} else
		return _implementation->getMoodID();
}

float CreatureObject::getSlopeModPercent() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSLOPEMODPERCENT__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getSlopeModPercent();
}

int CreatureObject::getPerformanceCounter() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPERFORMANCECOUNTER__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getPerformanceCounter();
}

int CreatureObject::getInstrumentID() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETINSTRUMENTID__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getInstrumentID();
}

byte CreatureObject::getFrozen() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFROZEN__);

		return method.executeWithByteReturn();
	} else
		return _implementation->getFrozen();
}

float CreatureObject::getHeight() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHEIGHT__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getHeight();
}

int CreatureObject::getSpecies() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPECIES__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getSpecies();
}

String CreatureObject::getSpeciesName() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPECIESNAME__);

		method.executeWithAsciiReturn(_return_getSpeciesName);
		return _return_getSpeciesName;
	} else
		return _implementation->getSpeciesName();
}

int CreatureObject::getGender() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGENDER__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getGender();
}

DeltaVector<int>* CreatureObject::getBaseHAM() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getBaseHAM();
}

SkillBoxList* CreatureObject::getSkillBoxList() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getSkillBoxList();
}

long long CreatureObject::getSkillMod(const String& skillmod) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSKILLMOD__STRING_);
		method.addAsciiParameter(skillmod);

		return method.executeWithSignedLongReturn();
	} else
		return _implementation->getSkillMod(skillmod);
}

bool CreatureObject::hasSkillBox(const String& skillBox) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSKILLBOX__STRING_);
		method.addAsciiParameter(skillBox);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasSkillBox(skillBox);
}

DeltaVectorMap<String, long long>* CreatureObject::getSkillModList() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getSkillModList();
}

void CreatureObject::setHeight(float heigh) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETHEIGHT__FLOAT_);
		method.addFloatParameter(heigh);

		method.executeWithVoidReturn();
	} else
		_implementation->setHeight(heigh);
}

void CreatureObject::setWatchToID(unsigned long long id) {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETWATCHTOID__LONG_);
		method.addUnsignedLongParameter(id);

		method.executeWithVoidReturn();
	} else
		_implementation->setWatchToID(id);
}

bool CreatureObject::isCreatureObject() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCREATUREOBJECT__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isCreatureObject();
}

bool CreatureObject::isTrainerCreature() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISTRAINERCREATURE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isTrainerCreature();
}

bool CreatureObject::isSwimming() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSWIMMING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isSwimming();
}

bool CreatureObject::isRidingMount() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRIDINGMOUNT__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isRidingMount();
}

ControlDevice* CreatureObject::getControlDevice() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCONTROLDEVICE__);

		return (ControlDevice*) method.executeWithObjectReturn();
	} else
		return _implementation->getControlDevice();
}

float CreatureObject::getSwimHeight() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSWIMHEIGHT__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getSwimHeight();
}

bool CreatureObject::isIncapacitated() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINCAPACITATED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isIncapacitated();
}

bool CreatureObject::isDead() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDEAD__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isDead();
}

bool CreatureObject::isKnockedDown() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISKNOCKEDDOWN__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isKnockedDown();
}

bool CreatureObject::isKneeling() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISKNEELING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isKneeling();
}

bool CreatureObject::isProne() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPRONE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isProne();
}

bool CreatureObject::isStanding() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSTANDING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isStanding();
}

bool CreatureObject::isSitting() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSITTING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isSitting();
}

bool CreatureObject::isSkillAnimating() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSKILLANIMATING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isSkillAnimating();
}

bool CreatureObject::isRallied() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRALLIED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isRallied();
}

bool CreatureObject::isInCombat() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINCOMBAT__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isInCombat();
}

bool CreatureObject::isDizzied() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDIZZIED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isDizzied();
}

bool CreatureObject::isBerserked() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISBERSERKED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isBerserked();
}

bool CreatureObject::isStunned() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSTUNNED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isStunned();
}

bool CreatureObject::isBlinded() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISBLINDED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isBlinded();
}

bool CreatureObject::isIntimidated() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINTIMIDATED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isIntimidated();
}

bool CreatureObject::isSnared() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSNARED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isSnared();
}

bool CreatureObject::isRooted() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISROOTED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isRooted();
}

bool CreatureObject::isDiseased() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDISEASED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isDiseased();
}

bool CreatureObject::isPoisoned() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPOISONED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isPoisoned();
}

bool CreatureObject::isBleeding() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISBLEEDING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isBleeding();
}

bool CreatureObject::isOnFire() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISONFIRE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isOnFire();
}

bool CreatureObject::isMounted() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISMOUNTED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isMounted();
}

bool CreatureObject::isRidingCreature() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRIDINGCREATURE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isRidingCreature();
}

bool CreatureObject::isPeaced() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPEACED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isPeaced();
}

bool CreatureObject::isMeditating() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISMEDITATING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isMeditating();
}

bool CreatureObject::isAiming() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISAIMING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isAiming();
}

bool CreatureObject::isInCover() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINCOVER__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isInCover();
}

bool CreatureObject::isNonPlayerCreature() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISNONPLAYERCREATURE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isNonPlayerCreature();
}

bool CreatureObject::isCreature() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCREATURE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isCreature();
}

bool CreatureObject::isAiAgent() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISAIAGENT__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isAiAgent();
}

bool CreatureObject::isInformantCreature() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINFORMANTCREATURE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isInformantCreature();
}

bool CreatureObject::isVendorCreature() {
	CreatureObjectImplementation* _implementation = (CreatureObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISVENDORCREATURE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isVendorCreature();
}

DistributedObjectServant* CreatureObject::_getImplementation() {

	_updated = true;
	return _impl;
}

void CreatureObject::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	CreatureObjectImplementation
 */

CreatureObjectImplementation::CreatureObjectImplementation(DummyConstructorParameter* param) : TangibleObjectImplementation(param) {
	_initializeImplementation();
}


CreatureObjectImplementation::~CreatureObjectImplementation() {
	CreatureObjectImplementation::finalize();
}


void CreatureObjectImplementation::_initializeImplementation() {
	_setClassHelper(CreatureObjectHelper::instance());

	_serializationHelperMethod();
	_serializationHelperMethod();
}

void CreatureObjectImplementation::_setStub(DistributedObjectStub* stub) {
	_this = (CreatureObject*) stub;
	TangibleObjectImplementation::_setStub(stub);
}

DistributedObjectStub* CreatureObjectImplementation::_getStub() {
	return _this;
}

CreatureObjectImplementation::operator const CreatureObject*() {
	return _this;
}

void CreatureObjectImplementation::lock(bool doLock) {
	_this->lock(doLock);
}

void CreatureObjectImplementation::lock(ManagedObject* obj) {
	_this->lock(obj);
}

void CreatureObjectImplementation::rlock(bool doLock) {
	_this->rlock(doLock);
}

void CreatureObjectImplementation::wlock(bool doLock) {
	_this->wlock(doLock);
}

void CreatureObjectImplementation::wlock(ManagedObject* obj) {
	_this->wlock(obj);
}

void CreatureObjectImplementation::unlock(bool doLock) {
	_this->unlock(doLock);
}

void CreatureObjectImplementation::runlock(bool doLock) {
	_this->runlock(doLock);
}

void CreatureObjectImplementation::_serializationHelperMethod() {
	TangibleObjectImplementation::_serializationHelperMethod();

	_setClassName("CreatureObject");

}

void CreatureObjectImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		String _name;
		_name.parseFromBinaryStream(stream);

		uint16 _varSize = stream->readShort();

		int _currentOffset = stream->getOffset();

		if(CreatureObjectImplementation::readObjectMember(stream, _name)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool CreatureObjectImplementation::readObjectMember(ObjectInputStream* stream, const String& _name) {
	if (TangibleObjectImplementation::readObjectMember(stream, _name))
		return true;

	if (_name == "bankCredits") {
		TypeInfo<int >::parseFromBinaryStream(&bankCredits, stream);
		return true;
	}

	if (_name == "cashCredits") {
		TypeInfo<int >::parseFromBinaryStream(&cashCredits, stream);
		return true;
	}

	if (_name == "gender") {
		TypeInfo<int >::parseFromBinaryStream(&gender, stream);
		return true;
	}

	if (_name == "species") {
		TypeInfo<int >::parseFromBinaryStream(&species, stream);
		return true;
	}

	if (_name == "baseHAM") {
		TypeInfo<DeltaVector<int> >::parseFromBinaryStream(&baseHAM, stream);
		return true;
	}

	if (_name == "posture") {
		TypeInfo<byte >::parseFromBinaryStream(&posture, stream);
		return true;
	}

	if (_name == "factionRank") {
		TypeInfo<byte >::parseFromBinaryStream(&factionRank, stream);
		return true;
	}

	if (_name == "linkedCreature") {
		TypeInfo<ManagedWeakReference<CreatureObject* > >::parseFromBinaryStream(&linkedCreature, stream);
		return true;
	}

	if (_name == "controlDevice") {
		TypeInfo<ManagedWeakReference<ControlDevice* > >::parseFromBinaryStream(&controlDevice, stream);
		return true;
	}

	if (_name == "shockWounds") {
		TypeInfo<float >::parseFromBinaryStream(&shockWounds, stream);
		return true;
	}

	if (_name == "wounds") {
		TypeInfo<DeltaVector<int> >::parseFromBinaryStream(&wounds, stream);
		return true;
	}

	if (_name == "stateBitmask") {
		TypeInfo<unsigned long long >::parseFromBinaryStream(&stateBitmask, stream);
		return true;
	}

	if (_name == "encumbrances") {
		TypeInfo<DeltaVector<int> >::parseFromBinaryStream(&encumbrances, stream);
		return true;
	}

	if (_name == "accelerationMultiplierBase") {
		TypeInfo<float >::parseFromBinaryStream(&accelerationMultiplierBase, stream);
		return true;
	}

	if (_name == "accelerationMultiplierMod") {
		TypeInfo<float >::parseFromBinaryStream(&accelerationMultiplierMod, stream);
		return true;
	}

	if (_name == "speedMultiplierBase") {
		TypeInfo<float >::parseFromBinaryStream(&speedMultiplierBase, stream);
		return true;
	}

	if (_name == "speedMultiplierModChanges") {
		TypeInfo<SpeedMultiplierModChanges >::parseFromBinaryStream(&speedMultiplierModChanges, stream);
		return true;
	}

	if (_name == "speedMultiplierMod") {
		TypeInfo<float >::parseFromBinaryStream(&speedMultiplierMod, stream);
		return true;
	}

	if (_name == "runSpeed") {
		TypeInfo<float >::parseFromBinaryStream(&runSpeed, stream);
		return true;
	}

	if (_name == "walkSpeed") {
		TypeInfo<float >::parseFromBinaryStream(&walkSpeed, stream);
		return true;
	}

	if (_name == "terrainNegotiation") {
		TypeInfo<float >::parseFromBinaryStream(&terrainNegotiation, stream);
		return true;
	}

	if (_name == "runAcceleration") {
		TypeInfo<float >::parseFromBinaryStream(&runAcceleration, stream);
		return true;
	}

	if (_name == "walkAcceleration") {
		TypeInfo<float >::parseFromBinaryStream(&walkAcceleration, stream);
		return true;
	}

	if (_name == "height") {
		TypeInfo<float >::parseFromBinaryStream(&height, stream);
		return true;
	}

	if (_name == "swimHeight") {
		TypeInfo<float >::parseFromBinaryStream(&swimHeight, stream);
		return true;
	}

	if (_name == "slopeModPercent") {
		TypeInfo<float >::parseFromBinaryStream(&slopeModPercent, stream);
		return true;
	}

	if (_name == "slopeModAngle") {
		TypeInfo<float >::parseFromBinaryStream(&slopeModAngle, stream);
		return true;
	}

	if (_name == "listenToID") {
		TypeInfo<unsigned long long >::parseFromBinaryStream(&listenToID, stream);
		return true;
	}

	if (_name == "watchToID") {
		TypeInfo<unsigned long long >::parseFromBinaryStream(&watchToID, stream);
		return true;
	}

	if (_name == "performanceAnimation") {
		TypeInfo<String >::parseFromBinaryStream(&performanceAnimation, stream);
		return true;
	}

	if (_name == "moodString") {
		TypeInfo<String >::parseFromBinaryStream(&moodString, stream);
		return true;
	}

	if (_name == "weapon") {
		TypeInfo<ManagedReference<WeaponObject* > >::parseFromBinaryStream(&weapon, stream);
		return true;
	}

	if (_name == "group") {
		TypeInfo<ManagedReference<GroupObject* > >::parseFromBinaryStream(&group, stream);
		return true;
	}

	if (_name == "groupInviterID") {
		TypeInfo<unsigned long long >::parseFromBinaryStream(&groupInviterID, stream);
		return true;
	}

	if (_name == "groupInviteCounter") {
		TypeInfo<unsigned long long >::parseFromBinaryStream(&groupInviteCounter, stream);
		return true;
	}

	if (_name == "guild") {
		TypeInfo<ManagedReference<GuildObject* > >::parseFromBinaryStream(&guild, stream);
		return true;
	}

	if (_name == "targetID") {
		TypeInfo<unsigned long long >::parseFromBinaryStream(&targetID, stream);
		return true;
	}

	if (_name == "moodID") {
		TypeInfo<byte >::parseFromBinaryStream(&moodID, stream);
		return true;
	}

	if (_name == "performanceCounter") {
		TypeInfo<int >::parseFromBinaryStream(&performanceCounter, stream);
		return true;
	}

	if (_name == "instrumentID") {
		TypeInfo<int >::parseFromBinaryStream(&instrumentID, stream);
		return true;
	}

	if (_name == "hamList") {
		TypeInfo<DeltaVector<int> >::parseFromBinaryStream(&hamList, stream);
		return true;
	}

	if (_name == "maxHamList") {
		TypeInfo<DeltaVector<int> >::parseFromBinaryStream(&maxHamList, stream);
		return true;
	}

	if (_name == "lootGroup") {
		TypeInfo<Vector<unsigned int> >::parseFromBinaryStream(&lootGroup, stream);
		return true;
	}

	if (_name == "frozen") {
		TypeInfo<byte >::parseFromBinaryStream(&frozen, stream);
		return true;
	}

	if (_name == "templateString") {
		TypeInfo<String >::parseFromBinaryStream(&templateString, stream);
		return true;
	}

	if (_name == "skillBoxList") {
		TypeInfo<SkillBoxList >::parseFromBinaryStream(&skillBoxList, stream);
		return true;
	}

	if (_name == "skillModList") {
		TypeInfo<DeltaVectorMap<String, long long> >::parseFromBinaryStream(&skillModList, stream);
		return true;
	}

	if (_name == "commandQueue") {
		TypeInfo<Vector<CommandQueueAction*> >::parseFromBinaryStream(&commandQueue, stream);
		return true;
	}

	if (_name == "nextAction") {
		TypeInfo<Time >::parseFromBinaryStream(&nextAction, stream);
		return true;
	}

	if (_name == "cooldownTimerMap") {
		TypeInfo<CooldownTimerMap >::parseFromBinaryStream(&cooldownTimerMap, stream);
		return true;
	}

	if (_name == "creatureBuffs") {
		TypeInfo<BuffList >::parseFromBinaryStream(&creatureBuffs, stream);
		return true;
	}

	if (_name == "damageOverTimeList") {
		TypeInfo<DamageOverTimeList >::parseFromBinaryStream(&damageOverTimeList, stream);
		return true;
	}

	if (_name == "lastSuccessfulCombatAction") {
		TypeInfo<Time >::parseFromBinaryStream(&lastSuccessfulCombatAction, stream);
		return true;
	}

	if (_name == "timeOfDeath") {
		TypeInfo<Time >::parseFromBinaryStream(&timeOfDeath, stream);
		return true;
	}


	return false;
}

void CreatureObjectImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = CreatureObjectImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int CreatureObjectImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	String _name;
	int _offset;
	uint16 _totalSize;
	_name = "bankCredits";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&bankCredits, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "cashCredits";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&cashCredits, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "gender";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&gender, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "species";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&species, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "baseHAM";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<DeltaVector<int> >::toBinaryStream(&baseHAM, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "posture";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<byte >::toBinaryStream(&posture, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "factionRank";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<byte >::toBinaryStream(&factionRank, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "linkedCreature";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<ManagedWeakReference<CreatureObject* > >::toBinaryStream(&linkedCreature, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "controlDevice";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<ManagedWeakReference<ControlDevice* > >::toBinaryStream(&controlDevice, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "shockWounds";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<float >::toBinaryStream(&shockWounds, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "wounds";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<DeltaVector<int> >::toBinaryStream(&wounds, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "stateBitmask";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<unsigned long long >::toBinaryStream(&stateBitmask, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "encumbrances";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<DeltaVector<int> >::toBinaryStream(&encumbrances, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "accelerationMultiplierBase";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<float >::toBinaryStream(&accelerationMultiplierBase, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "accelerationMultiplierMod";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<float >::toBinaryStream(&accelerationMultiplierMod, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "speedMultiplierBase";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<float >::toBinaryStream(&speedMultiplierBase, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "speedMultiplierModChanges";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<SpeedMultiplierModChanges >::toBinaryStream(&speedMultiplierModChanges, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "speedMultiplierMod";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<float >::toBinaryStream(&speedMultiplierMod, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "runSpeed";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<float >::toBinaryStream(&runSpeed, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "walkSpeed";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<float >::toBinaryStream(&walkSpeed, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "terrainNegotiation";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<float >::toBinaryStream(&terrainNegotiation, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "runAcceleration";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<float >::toBinaryStream(&runAcceleration, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "walkAcceleration";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<float >::toBinaryStream(&walkAcceleration, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "height";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<float >::toBinaryStream(&height, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "swimHeight";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<float >::toBinaryStream(&swimHeight, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "slopeModPercent";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<float >::toBinaryStream(&slopeModPercent, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "slopeModAngle";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<float >::toBinaryStream(&slopeModAngle, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "listenToID";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<unsigned long long >::toBinaryStream(&listenToID, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "watchToID";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<unsigned long long >::toBinaryStream(&watchToID, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "performanceAnimation";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<String >::toBinaryStream(&performanceAnimation, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "moodString";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<String >::toBinaryStream(&moodString, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "weapon";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<ManagedReference<WeaponObject* > >::toBinaryStream(&weapon, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "group";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<ManagedReference<GroupObject* > >::toBinaryStream(&group, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "groupInviterID";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<unsigned long long >::toBinaryStream(&groupInviterID, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "groupInviteCounter";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<unsigned long long >::toBinaryStream(&groupInviteCounter, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "guild";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<ManagedReference<GuildObject* > >::toBinaryStream(&guild, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "targetID";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<unsigned long long >::toBinaryStream(&targetID, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "moodID";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<byte >::toBinaryStream(&moodID, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "performanceCounter";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&performanceCounter, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "instrumentID";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&instrumentID, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "hamList";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<DeltaVector<int> >::toBinaryStream(&hamList, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "maxHamList";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<DeltaVector<int> >::toBinaryStream(&maxHamList, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "lootGroup";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<Vector<unsigned int> >::toBinaryStream(&lootGroup, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "frozen";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<byte >::toBinaryStream(&frozen, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "templateString";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<String >::toBinaryStream(&templateString, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "skillBoxList";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<SkillBoxList >::toBinaryStream(&skillBoxList, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "skillModList";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<DeltaVectorMap<String, long long> >::toBinaryStream(&skillModList, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "commandQueue";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<Vector<CommandQueueAction*> >::toBinaryStream(&commandQueue, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "nextAction";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<Time >::toBinaryStream(&nextAction, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "cooldownTimerMap";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<CooldownTimerMap >::toBinaryStream(&cooldownTimerMap, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "creatureBuffs";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<BuffList >::toBinaryStream(&creatureBuffs, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "damageOverTimeList";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<DamageOverTimeList >::toBinaryStream(&damageOverTimeList, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "lastSuccessfulCombatAction";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<Time >::toBinaryStream(&lastSuccessfulCombatAction, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "timeOfDeath";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<Time >::toBinaryStream(&timeOfDeath, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);


	return 54 + TangibleObjectImplementation::writeObjectMembers(stream);
}

CreatureObjectImplementation::CreatureObjectImplementation() {
	_initializeImplementation();
	// server/zone/objects/creature/CreatureObject.idl():  		Logger.setLoggingName("CreatureObject");
	Logger::setLoggingName("CreatureObject");
	// server/zone/objects/creature/CreatureObject.idl():  		initializeMembers();
	initializeMembers();
}

bool CreatureObjectImplementation::hasDamage(int attribute) {
	// server/zone/objects/creature/CreatureObject.idl():  		return maxHamList.get(attribute) - hamList.get(attribute);
	return (&maxHamList)->get(attribute) - (&hamList)->get(attribute);
}

Buff* CreatureObjectImplementation::getBuff(unsigned int buffcrc) {
	// server/zone/objects/creature/CreatureObject.idl():  		return 
	if ((&creatureBuffs)->hasBuff(buffcrc))	// server/zone/objects/creature/CreatureObject.idl():  			return creatureBuffs.getBuffByCRC(buffcrc);
	return (&creatureBuffs)->getBuffByCRC(buffcrc);
	// server/zone/objects/creature/CreatureObject.idl():  		return null;
	return NULL;
}

int CreatureObjectImplementation::addDotState(unsigned long long dotType, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense) {
	// server/zone/objects/creature/CreatureObject.idl():  		return damageOverTimeList.addDot(this, duration, dotType, type, strength, potency, defense);
	return (&damageOverTimeList)->addDot(_this, duration, dotType, type, strength, potency, defense);
}

bool CreatureObjectImplementation::healDot(unsigned long long dotType, int reduction) {
	// server/zone/objects/creature/CreatureObject.idl():  		return damageOverTimeList.healState(this, dotType, reduction);
	return (&damageOverTimeList)->healState(_this, dotType, reduction);
}

void CreatureObjectImplementation::clearDots() {
	// server/zone/objects/creature/CreatureObject.idl():  		damageOverTimeList.clear(this);
	(&damageOverTimeList)->clear(_this);
}

bool CreatureObjectImplementation::hasBuff(unsigned int buffcrc) {
	// server/zone/objects/creature/CreatureObject.idl():  		return creatureBuffs.hasBuff(buffcrc);
	return (&creatureBuffs)->hasBuff(buffcrc);
}

void CreatureObjectImplementation::addBankCredits(int credits, bool notifyClient) {
	// server/zone/objects/creature/CreatureObject.idl():  		int newCredits = bankCredits + credits;
	int newCredits = bankCredits + credits;
	// server/zone/objects/creature/CreatureObject.idl():  		setBankCredits(newCredits);
	setBankCredits(newCredits);
}

void CreatureObjectImplementation::addCashCredits(int credits, bool notifyClient) {
	// server/zone/objects/creature/CreatureObject.idl():  		int newCredits = cashCredits + credits;
	int newCredits = cashCredits + credits;
	// server/zone/objects/creature/CreatureObject.idl():  		setCashCredits(newCredits);
	setCashCredits(newCredits);
}

void CreatureObjectImplementation::substractBankCredits(int credits) {
	// server/zone/objects/creature/CreatureObject.idl():  		int newCredits = bankCredits - credits;
	int newCredits = bankCredits - credits;
	// server/zone/objects/creature/CreatureObject.idl():  		setBankCredits(newCredits);
	setBankCredits(newCredits);
}

void CreatureObjectImplementation::substractCashCredits(int credits) {
	// server/zone/objects/creature/CreatureObject.idl():  		int newCredits = cashCredits - credits;
	int newCredits = cashCredits - credits;
	// server/zone/objects/creature/CreatureObject.idl():  		setCashCredits(newCredits);
	setCashCredits(newCredits);
}

bool CreatureObjectImplementation::verifyCashCredits(int credits) {
	// server/zone/objects/creature/CreatureObject.idl():  		if 
	if (credits < 0)	// server/zone/objects/creature/CreatureObject.idl():  			return false;
	return false;
	// server/zone/objects/creature/CreatureObject.idl():  		return 
	if (cashCredits < credits)	// server/zone/objects/creature/CreatureObject.idl():  			return false;
	return false;
	// server/zone/objects/creature/CreatureObject.idl():  		return true;
	return true;
}

bool CreatureObjectImplementation::verifyBankCredits(int credits) {
	// server/zone/objects/creature/CreatureObject.idl():  		if 
	if (credits < 0)	// server/zone/objects/creature/CreatureObject.idl():  			return false;
	return false;
	// server/zone/objects/creature/CreatureObject.idl():  		return 
	if (bankCredits < credits)	// server/zone/objects/creature/CreatureObject.idl():  			return false;
	return false;
	// server/zone/objects/creature/CreatureObject.idl():  		return true;
	return true;
}

bool CreatureObjectImplementation::isEntertaining() {
	// server/zone/objects/creature/CreatureObject.idl():  		return isDancing() || isPlayingMusic();
	return isDancing() || isPlayingMusic();
}

void CreatureObjectImplementation::setControlDevice(ControlDevice* device) {
	// server/zone/objects/creature/CreatureObject.idl():  		controlDevice = device;
	controlDevice = device;
}

bool CreatureObjectImplementation::isAttackableBy(CreatureObject* object) {
	// server/zone/objects/creature/CreatureObject.idl():  		return false;
	return false;
}

void CreatureObjectImplementation::sendConversationStartTo(SceneObject* player) {
}

void CreatureObjectImplementation::selectConversationOption(int option, SceneObject* obj) {
}

bool CreatureObjectImplementation::canTreatInjuries() {
	// server/zone/objects/creature/CreatureObject.idl():  		return super.getPendingTask("injuryTreatment") == null;
	return TangibleObjectImplementation::getPendingTask("injuryTreatment") == NULL;
}

bool CreatureObjectImplementation::canTreatStates() {
	// server/zone/objects/creature/CreatureObject.idl():  		return super.getPendingTask("stateTreatment") == null;
	return TangibleObjectImplementation::getPendingTask("stateTreatment") == NULL;
}

bool CreatureObjectImplementation::canTreatWounds() {
	// server/zone/objects/creature/CreatureObject.idl():  		return super.getPendingTask("woundTreatment") == null;
	return TangibleObjectImplementation::getPendingTask("woundTreatment") == NULL;
}

bool CreatureObjectImplementation::canTreatConditions() {
	// server/zone/objects/creature/CreatureObject.idl():  		return super.getPendingTask("conditionTreatment") == null;
	return TangibleObjectImplementation::getPendingTask("conditionTreatment") == NULL;
}

bool CreatureObjectImplementation::isListening() {
	// server/zone/objects/creature/CreatureObject.idl():  		return listenToID != 0;
	return listenToID != 0;
}

bool CreatureObjectImplementation::isWatching() {
	// server/zone/objects/creature/CreatureObject.idl():  		return watchToID != 0;
	return watchToID != 0;
}

void CreatureObjectImplementation::updateTimeOfDeath() {
	// server/zone/objects/creature/CreatureObject.idl():  		timeOfDeath.updateToCurrentTime();
	(&timeOfDeath)->updateToCurrentTime();
}

bool CreatureObjectImplementation::hasAttackDelay() {
	// server/zone/objects/creature/CreatureObject.idl():  		return !cooldownTimerMap.isPast("nextAttackDelay");
	return !(&cooldownTimerMap)->isPast("nextAttackDelay");
}

void CreatureObjectImplementation::removeAttackDelay() {
	// server/zone/objects/creature/CreatureObject.idl():  		cooldownTimerMap.updateToCurrentTime("nextAttackDelay");
	(&cooldownTimerMap)->updateToCurrentTime("nextAttackDelay");
}

bool CreatureObjectImplementation::hasSpice() {
	// server/zone/objects/creature/CreatureObject.idl():  		return creatureBuffs.hasSpice();
	return (&creatureBuffs)->hasSpice();
}

void CreatureObjectImplementation::updateLastSuccessfulCombatAction() {
	// server/zone/objects/creature/CreatureObject.idl():  		lastSuccessfulCombatAction.updateToCurrentTime();
	(&lastSuccessfulCombatAction)->updateToCurrentTime();
}

void CreatureObjectImplementation::updateKnockdownRecovery() {
	// server/zone/objects/creature/CreatureObject.idl():  		cooldownTimerMap.updateToCurrentAndAddMili("knockdownRecovery", 30000);
	(&cooldownTimerMap)->updateToCurrentAndAddMili("knockdownRecovery", 30000);
}

void CreatureObjectImplementation::updateLastKnockdown() {
	// server/zone/objects/creature/CreatureObject.idl():  		cooldownTimerMap.updateToCurrentAndAddMili("lastKnockdown", 60000);
	(&cooldownTimerMap)->updateToCurrentAndAddMili("lastKnockdown", 60000);
}

bool CreatureObjectImplementation::checkKnockdownRecovery() {
	// server/zone/objects/creature/CreatureObject.idl():  		return cooldownTimerMap.isPast("knockdownRecovery");
	return (&cooldownTimerMap)->isPast("knockdownRecovery");
}

bool CreatureObjectImplementation::checkLastKnockdown() {
	// server/zone/objects/creature/CreatureObject.idl():  		return cooldownTimerMap.isPast("lastKnockdown");
	return (&cooldownTimerMap)->isPast("lastKnockdown");
}

void CreatureObjectImplementation::updatePostureDownRecovery() {
	// server/zone/objects/creature/CreatureObject.idl():  		cooldownTimerMap.updateToCurrentAndAddMili("postureDownRecovery", 30000);
	(&cooldownTimerMap)->updateToCurrentAndAddMili("postureDownRecovery", 30000);
}

void CreatureObjectImplementation::updatePostureUpRecovery() {
	// server/zone/objects/creature/CreatureObject.idl():  		cooldownTimerMap.updateToCurrentAndAddMili("postureUpRecovery", 30000);
	(&cooldownTimerMap)->updateToCurrentAndAddMili("postureUpRecovery", 30000);
}

bool CreatureObjectImplementation::checkPostureDownRecovery() {
	// server/zone/objects/creature/CreatureObject.idl():  		return cooldownTimerMap.isPast("postureDownRecovery");
	return (&cooldownTimerMap)->isPast("postureDownRecovery");
}

bool CreatureObjectImplementation::checkPostureUpRecovery() {
	// server/zone/objects/creature/CreatureObject.idl():  		return cooldownTimerMap.isPast("postureUpRecovery");
	return (&cooldownTimerMap)->isPast("postureUpRecovery");
}

void CreatureObjectImplementation::updateCooldownTimer(const String& coooldownTimer, unsigned int miliSecondsToAdd) {
	// server/zone/objects/creature/CreatureObject.idl():  		}
	if (miliSecondsToAdd != 0){
	// server/zone/objects/creature/CreatureObject.idl():  			cooldownTimerMap.updateToCurrentAndAddMili(coooldownTimer, miliSecondsToAdd);
	(&cooldownTimerMap)->updateToCurrentAndAddMili(coooldownTimer, miliSecondsToAdd);
}

	else {
	// server/zone/objects/creature/CreatureObject.idl():  			cooldownTimerMap.updateToCurrentTime(coooldownTimer);
	(&cooldownTimerMap)->updateToCurrentTime(coooldownTimer);
}
}

bool CreatureObjectImplementation::checkCooldownRecovery(const String& cooldown) {
	// server/zone/objects/creature/CreatureObject.idl():  		return cooldownTimerMap.isPast(cooldown);
	return (&cooldownTimerMap)->isPast(cooldown);
}

Time* CreatureObjectImplementation::getCooldownTime(const String& cooldown) {
	// server/zone/objects/creature/CreatureObject.idl():  		return cooldownTimerMap.getTime(cooldown);
	return (&cooldownTimerMap)->getTime(cooldown);
}

void CreatureObjectImplementation::addCooldown(const String& name, unsigned int miliseconds) {
	// server/zone/objects/creature/CreatureObject.idl():  		cooldownTimerMap.updateToCurrentAndAddMili(name, miliseconds);
	(&cooldownTimerMap)->updateToCurrentAndAddMili(name, miliseconds);
}

void CreatureObjectImplementation::playEffect(const String& file) {
	// server/zone/objects/creature/CreatureObject.idl():  		playEffect(file, "");
	playEffect(file, "");
}

bool CreatureObjectImplementation::isGrouped() {
	// server/zone/objects/creature/CreatureObject.idl():  		return group != null;
	return group != NULL;
}

int CreatureObjectImplementation::getBankCredits() {
	// server/zone/objects/creature/CreatureObject.idl():  		return bankCredits;
	return bankCredits;
}

int CreatureObjectImplementation::getCashCredits() {
	// server/zone/objects/creature/CreatureObject.idl():  		return cashCredits;
	return cashCredits;
}

int CreatureObjectImplementation::getBaseHAM(int idx) {
	// server/zone/objects/creature/CreatureObject.idl():  		return baseHAM.get(idx);
	return (&baseHAM)->get(idx);
}

int CreatureObjectImplementation::getWounds(int idx) {
	// server/zone/objects/creature/CreatureObject.idl():  		return wounds.get(idx);
	return (&wounds)->get(idx);
}

DeltaVector<int>* CreatureObjectImplementation::getWounds() {
	// server/zone/objects/creature/CreatureObject.idl():  		return wounds;
	return (&wounds);
}

int CreatureObjectImplementation::getHAM(int idx) {
	// server/zone/objects/creature/CreatureObject.idl():  		return hamList.get(idx);
	return (&hamList)->get(idx);
}

DeltaVector<int>* CreatureObjectImplementation::getHAM() {
	// server/zone/objects/creature/CreatureObject.idl():  		return hamList;
	return (&hamList);
}

int CreatureObjectImplementation::getMaxHAM(int idx) {
	// server/zone/objects/creature/CreatureObject.idl():  		return maxHamList.get(idx);
	return (&maxHamList)->get(idx);
}

DeltaVector<int>* CreatureObjectImplementation::getMaxHAM() {
	// server/zone/objects/creature/CreatureObject.idl():  		return maxHamList;
	return (&maxHamList);
}

int CreatureObjectImplementation::getEncumbrance(int idx) {
	// server/zone/objects/creature/CreatureObject.idl():  		return encumbrances.get(idx);
	return (&encumbrances)->get(idx);
}

DeltaVector<int>* CreatureObjectImplementation::getEncumbrances() {
	// server/zone/objects/creature/CreatureObject.idl():  		return encumbrances;
	return (&encumbrances);
}

byte CreatureObjectImplementation::getPosture() {
	// server/zone/objects/creature/CreatureObject.idl():  		return posture;
	return posture;
}

byte CreatureObjectImplementation::getFactionRank() {
	// server/zone/objects/creature/CreatureObject.idl():  		return factionRank;
	return factionRank;
}

CreatureObject* CreatureObjectImplementation::getLinkedCreature() {
	// server/zone/objects/creature/CreatureObject.idl():  		return linkedCreature;
	return linkedCreature;
}

unsigned long long CreatureObjectImplementation::getCreatureLinkID() {
	// server/zone/objects/creature/CreatureObject.idl():  			return 0;
	if (linkedCreature != NULL)	// server/zone/objects/creature/CreatureObject.idl():  			return linkedCreature.getObjectID();
	return linkedCreature->getObjectID();

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return 0;
	return 0;
}

float CreatureObjectImplementation::getShockWounds() {
	// server/zone/objects/creature/CreatureObject.idl():  		return shockWounds;
	return shockWounds;
}

unsigned long long CreatureObjectImplementation::getWatchToID() {
	// server/zone/objects/creature/CreatureObject.idl():  		return watchToID;
	return watchToID;
}

unsigned long long CreatureObjectImplementation::getStateBitmask() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask;
	return stateBitmask;
}

bool CreatureObjectImplementation::hasState(unsigned long long state) {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & state;
	return stateBitmask & state;
}

bool CreatureObjectImplementation::hasStates() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask != 0;
	return stateBitmask != 0;
}

unsigned long long CreatureObjectImplementation::getListenID() {
	// server/zone/objects/creature/CreatureObject.idl():  		return listenToID;
	return listenToID;
}

float CreatureObjectImplementation::getAccelerationMultiplierBase() {
	// server/zone/objects/creature/CreatureObject.idl():  		return accelerationMultiplierBase;
	return accelerationMultiplierBase;
}

float CreatureObjectImplementation::getAccelerationMultiplierMod() {
	// server/zone/objects/creature/CreatureObject.idl():  		return accelerationMultiplierMod;
	return accelerationMultiplierMod;
}

float CreatureObjectImplementation::getSpeedMultiplierBase() {
	// server/zone/objects/creature/CreatureObject.idl():  		return speedMultiplierBase;
	return speedMultiplierBase;
}

float CreatureObjectImplementation::getSpeedMultiplierMod() {
	// server/zone/objects/creature/CreatureObject.idl():  		return speedMultiplierMod;
	return speedMultiplierMod;
}

SpeedMultiplierModChanges* CreatureObjectImplementation::getSpeedMultiplierModChanges() {
	// server/zone/objects/creature/CreatureObject.idl():  		return speedMultiplierModChanges;
	return (&speedMultiplierModChanges);
}

float CreatureObjectImplementation::getRunSpeed() {
	// server/zone/objects/creature/CreatureObject.idl():  		return runSpeed;
	return runSpeed;
}

float CreatureObjectImplementation::getWalkSpeed() {
	// server/zone/objects/creature/CreatureObject.idl():  		return walkSpeed;
	return walkSpeed;
}

float CreatureObjectImplementation::getTerrainNegotiation() {
	// server/zone/objects/creature/CreatureObject.idl():  		return terrainNegotiation;
	return terrainNegotiation;
}

float CreatureObjectImplementation::getRunAcceleration() {
	// server/zone/objects/creature/CreatureObject.idl():  		return runAcceleration;
	return runAcceleration;
}

float CreatureObjectImplementation::getWalkAcceleration() {
	// server/zone/objects/creature/CreatureObject.idl():  		return walkAcceleration;
	return walkAcceleration;
}

String CreatureObjectImplementation::getPerformanceAnimation() {
	// server/zone/objects/creature/CreatureObject.idl():  		return performanceAnimation;
	return performanceAnimation;
}

String CreatureObjectImplementation::getMoodString() {
	// server/zone/objects/creature/CreatureObject.idl():  		return moodString;
	return moodString;
}

unsigned long long CreatureObjectImplementation::getWeaponID() {
	// server/zone/objects/creature/CreatureObject.idl():  			return weapon.getObjectID();
	if (weapon == NULL)	// server/zone/objects/creature/CreatureObject.idl():  			return 0;
	return 0;

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return weapon.getObjectID();
	return weapon->getObjectID();
}

WeaponObject* CreatureObjectImplementation::getWeapon() {
	// server/zone/objects/creature/CreatureObject.idl():  			return weapon;
	if (weapon == NULL){
	// server/zone/objects/creature/CreatureObject.idl():  			return (WeaponObject) super.getSlottedObject("default_weapon");
	return (WeaponObject*) TangibleObjectImplementation::getSlottedObject("default_weapon");
}

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return weapon;
	return weapon;
}

GuildObject* CreatureObjectImplementation::getGuildObject() {
	// server/zone/objects/creature/CreatureObject.idl():  		return guild;
	return guild;
}

int CreatureObjectImplementation::getGuildID() {
	// server/zone/objects/creature/CreatureObject.idl():  		return 
	if (guild == NULL)	// server/zone/objects/creature/CreatureObject.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/CreatureObject.idl():  		return guild.getGuildID();
	return guild->getGuildID();
}

bool CreatureObjectImplementation::isInGuild() {
	// server/zone/objects/creature/CreatureObject.idl():  		return guild != null;
	return guild != NULL;
}

void CreatureObjectImplementation::setGuildObject(GuildObject* guildobj) {
	// server/zone/objects/creature/CreatureObject.idl():  		guild = guildobj;
	guild = guildobj;
}

unsigned long long CreatureObjectImplementation::getGroupID() {
	// server/zone/objects/creature/CreatureObject.idl():  			return 0;
	if (group != NULL)	// server/zone/objects/creature/CreatureObject.idl():  			return group.getObjectID();
	return group->getObjectID();

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return 0;
	return 0;
}

unsigned long long CreatureObjectImplementation::getGroupInviterID() {
	// server/zone/objects/creature/CreatureObject.idl():  		return groupInviterID;
	return groupInviterID;
}

GroupObject* CreatureObjectImplementation::getGroup() {
	// server/zone/objects/creature/CreatureObject.idl():  		return group;
	return group;
}

unsigned long long CreatureObjectImplementation::getGroupInviteCounter() {
	// server/zone/objects/creature/CreatureObject.idl():  		return groupInviteCounter;
	return groupInviteCounter;
}

unsigned long long CreatureObjectImplementation::getTargetID() {
	// server/zone/objects/creature/CreatureObject.idl():  		return targetID;
	return targetID;
}

byte CreatureObjectImplementation::getMoodID() {
	// server/zone/objects/creature/CreatureObject.idl():  		return moodID;
	return moodID;
}

float CreatureObjectImplementation::getSlopeModPercent() {
	// server/zone/objects/creature/CreatureObject.idl():  		return slopeModPercent;
	return slopeModPercent;
}

int CreatureObjectImplementation::getPerformanceCounter() {
	// server/zone/objects/creature/CreatureObject.idl():  		return performanceCounter;
	return performanceCounter;
}

int CreatureObjectImplementation::getInstrumentID() {
	// server/zone/objects/creature/CreatureObject.idl():  		return instrumentID;
	return instrumentID;
}

byte CreatureObjectImplementation::getFrozen() {
	// server/zone/objects/creature/CreatureObject.idl():  		return frozen;
	return frozen;
}

float CreatureObjectImplementation::getHeight() {
	// server/zone/objects/creature/CreatureObject.idl():  		return height;
	return height;
}

int CreatureObjectImplementation::getSpecies() {
	// server/zone/objects/creature/CreatureObject.idl():  		return species;
	return species;
}

String CreatureObjectImplementation::getSpeciesName() {
	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 0)	// server/zone/objects/creature/CreatureObject.idl():  			return "human";
	return "human";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 1)	// server/zone/objects/creature/CreatureObject.idl():  			return "rodian";
	return "rodian";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 2)	// server/zone/objects/creature/CreatureObject.idl():  			return "trandoshan";
	return "trandoshan";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 3)	// server/zone/objects/creature/CreatureObject.idl():  			return "moncal";
	return "moncal";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 4)	// server/zone/objects/creature/CreatureObject.idl():  			return "wookiee";
	return "wookiee";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 5)	// server/zone/objects/creature/CreatureObject.idl():  			return "bothan";
	return "bothan";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 6)	// server/zone/objects/creature/CreatureObject.idl():  			return "twilek";
	return "twilek";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 7)	// server/zone/objects/creature/CreatureObject.idl():  			return "zabrak";
	return "zabrak";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 0x21)	// server/zone/objects/creature/CreatureObject.idl():  			return "ithorian";
	return "ithorian";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 0x31)	// server/zone/objects/creature/CreatureObject.idl():  			return "sullustan";
	return "sullustan";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	return "";
}

int CreatureObjectImplementation::getGender() {
	// server/zone/objects/creature/CreatureObject.idl():  		return gender;
	return gender;
}

DeltaVector<int>* CreatureObjectImplementation::getBaseHAM() {
	// server/zone/objects/creature/CreatureObject.idl():  		return baseHAM;
	return (&baseHAM);
}

SkillBoxList* CreatureObjectImplementation::getSkillBoxList() {
	// server/zone/objects/creature/CreatureObject.idl():  		return skillBoxList;
	return (&skillBoxList);
}

long long CreatureObjectImplementation::getSkillMod(const String& skillmod) {
	// server/zone/objects/creature/CreatureObject.idl():  		return skillModList.get(skillmod);
	return (&skillModList)->get(skillmod);
}

bool CreatureObjectImplementation::hasSkillBox(const String& skillBox) {
	// server/zone/objects/creature/CreatureObject.idl():  		return skillBoxList.containsSkillBox(skillBox);
	return (&skillBoxList)->containsSkillBox(skillBox);
}

DeltaVectorMap<String, long long>* CreatureObjectImplementation::getSkillModList() {
	// server/zone/objects/creature/CreatureObject.idl():  		return skillModList;
	return (&skillModList);
}

void CreatureObjectImplementation::setHeight(float heigh) {
	// server/zone/objects/creature/CreatureObject.idl():  		height = heigh;
	height = heigh;
}

void CreatureObjectImplementation::setWatchToID(unsigned long long id) {
	// server/zone/objects/creature/CreatureObject.idl():  		watchToID = id;
	watchToID = id;
}

bool CreatureObjectImplementation::isCreatureObject() {
	// server/zone/objects/creature/CreatureObject.idl():  		return true;
	return true;
}

bool CreatureObjectImplementation::isTrainerCreature() {
	// server/zone/objects/creature/CreatureObject.idl():  		return false;
	return false;
}

bool CreatureObjectImplementation::isSwimming() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.SWIMMING;
	return stateBitmask & CreatureState::SWIMMING;
}

bool CreatureObjectImplementation::isRidingMount() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.RIDINGMOUNT;
	return stateBitmask & CreatureState::RIDINGMOUNT;
}

ControlDevice* CreatureObjectImplementation::getControlDevice() {
	// server/zone/objects/creature/CreatureObject.idl():  		return controlDevice;
	return controlDevice;
}

float CreatureObjectImplementation::getSwimHeight() {
	// server/zone/objects/creature/CreatureObject.idl():  		return swimHeight;
	return swimHeight;
}

bool CreatureObjectImplementation::isIncapacitated() {
	// server/zone/objects/creature/CreatureObject.idl():  		return posture == CreaturePosture.INCAPACITATED;
	return posture == CreaturePosture::INCAPACITATED;
}

bool CreatureObjectImplementation::isDead() {
	// server/zone/objects/creature/CreatureObject.idl():  		return posture == CreaturePosture.DEAD;
	return posture == CreaturePosture::DEAD;
}

bool CreatureObjectImplementation::isKnockedDown() {
	// server/zone/objects/creature/CreatureObject.idl():  		return posture == CreaturePosture.KNOCKEDDOWN;
	return posture == CreaturePosture::KNOCKEDDOWN;
}

bool CreatureObjectImplementation::isKneeling() {
	// server/zone/objects/creature/CreatureObject.idl():  		return posture == CreaturePosture.CROUCHED;
	return posture == CreaturePosture::CROUCHED;
}

bool CreatureObjectImplementation::isProne() {
	// server/zone/objects/creature/CreatureObject.idl():  		return posture == CreaturePosture.PRONE;
	return posture == CreaturePosture::PRONE;
}

bool CreatureObjectImplementation::isStanding() {
	// server/zone/objects/creature/CreatureObject.idl():  		return posture == CreaturePosture.UPRIGHT;
	return posture == CreaturePosture::UPRIGHT;
}

bool CreatureObjectImplementation::isSitting() {
	// server/zone/objects/creature/CreatureObject.idl():  		return posture == CreaturePosture.SITTING;
	return posture == CreaturePosture::SITTING;
}

bool CreatureObjectImplementation::isSkillAnimating() {
	// server/zone/objects/creature/CreatureObject.idl():  		return posture == CreaturePosture.SKILLANIMATING;
	return posture == CreaturePosture::SKILLANIMATING;
}

bool CreatureObjectImplementation::isRallied() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.RALLIED;
	return stateBitmask & CreatureState::RALLIED;
}

bool CreatureObjectImplementation::isInCombat() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.COMBAT;
	return stateBitmask & CreatureState::COMBAT;
}

bool CreatureObjectImplementation::isDizzied() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.DIZZY;
	return stateBitmask & CreatureState::DIZZY;
}

bool CreatureObjectImplementation::isBerserked() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.BERSERK;
	return stateBitmask & CreatureState::BERSERK;
}

bool CreatureObjectImplementation::isStunned() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.STUNNED;
	return stateBitmask & CreatureState::STUNNED;
}

bool CreatureObjectImplementation::isBlinded() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.BLINDED;
	return stateBitmask & CreatureState::BLINDED;
}

bool CreatureObjectImplementation::isIntimidated() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.INTIMIDATED;
	return stateBitmask & CreatureState::INTIMIDATED;
}

bool CreatureObjectImplementation::isSnared() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.SNARED;
	return stateBitmask & CreatureState::SNARED;
}

bool CreatureObjectImplementation::isRooted() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.ROOTED;
	return stateBitmask & CreatureState::ROOTED;
}

bool CreatureObjectImplementation::isDiseased() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.DISEASED;
	return stateBitmask & CreatureState::DISEASED;
}

bool CreatureObjectImplementation::isPoisoned() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.POISONED;
	return stateBitmask & CreatureState::POISONED;
}

bool CreatureObjectImplementation::isBleeding() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.BLEEDING;
	return stateBitmask & CreatureState::BLEEDING;
}

bool CreatureObjectImplementation::isOnFire() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.ONFIRE;
	return stateBitmask & CreatureState::ONFIRE;
}

bool CreatureObjectImplementation::isMounted() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.RIDINGMOUNT;
	return stateBitmask & CreatureState::RIDINGMOUNT;
}

bool CreatureObjectImplementation::isRidingCreature() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.MOUNTEDCREATURE;
	return stateBitmask & CreatureState::MOUNTEDCREATURE;
}

bool CreatureObjectImplementation::isPeaced() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.PEACE;
	return stateBitmask & CreatureState::PEACE;
}

bool CreatureObjectImplementation::isMeditating() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.ALERT;
	return stateBitmask & CreatureState::ALERT;
}

bool CreatureObjectImplementation::isAiming() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.AIMING;
	return stateBitmask & CreatureState::AIMING;
}

bool CreatureObjectImplementation::isInCover() {
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.COVER;
	return stateBitmask & CreatureState::COVER;
}

bool CreatureObjectImplementation::isNonPlayerCreature() {
	// server/zone/objects/creature/CreatureObject.idl():  		return false;
	return false;
}

bool CreatureObjectImplementation::isCreature() {
	// server/zone/objects/creature/CreatureObject.idl():  		return false;
	return false;
}

bool CreatureObjectImplementation::isAiAgent() {
	// server/zone/objects/creature/CreatureObject.idl():  		return false;
	return false;
}

bool CreatureObjectImplementation::isInformantCreature() {
	// server/zone/objects/creature/CreatureObject.idl():  		return false;
	return false;
}

bool CreatureObjectImplementation::isVendorCreature() {
	// server/zone/objects/creature/CreatureObject.idl():  		return false;
	return false;
}

/*
 *	CreatureObjectAdapter
 */

CreatureObjectAdapter::CreatureObjectAdapter(CreatureObjectImplementation* obj) : TangibleObjectAdapter(obj) {
}

Packet* CreatureObjectAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	Packet* resp = new MethodReturnMessage(0);

	switch (methid) {
	case RPC_INITIALIZEMEMBERS__:
		initializeMembers();
		break;
	case RPC_FINALIZE__:
		finalize();
		break;
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		initializeTransientMembers();
		break;
	case RPC_CLEARQUEUEACTION__INT_FLOAT_INT_INT_:
		clearQueueAction(inv->getUnsignedIntParameter(), inv->getFloatParameter(), inv->getUnsignedIntParameter(), inv->getUnsignedIntParameter());
		break;
	case RPC_SENDBASELINESTO__SCENEOBJECT_:
		sendBaselinesTo((SceneObject*) inv->getObjectParameter());
		break;
	case RPC_SENDSYSTEMMESSAGE__STRING_:
		sendSystemMessage(inv->getAsciiParameter(_param0_sendSystemMessage__String_));
		break;
	case RPC_SENDSYSTEMMESSAGE__UNICODESTRING_:
		sendSystemMessage(inv->getUnicodeParameter(_param0_sendSystemMessage__UnicodeString_));
		break;
	case RPC_SENDSYSTEMMESSAGE__STRING_STRING_:
		sendSystemMessage(inv->getAsciiParameter(_param0_sendSystemMessage__String_String_), inv->getAsciiParameter(_param1_sendSystemMessage__String_String_));
		break;
	case RPC_SENDSLOTTEDOBJECTSTO__SCENEOBJECT_:
		sendSlottedObjectsTo((SceneObject*) inv->getObjectParameter());
		break;
	case RPC_SETCOMBATSTATE__:
		setCombatState();
		break;
	case RPC_CLEARCOMBATSTATE__BOOL_:
		clearCombatState(inv->getBooleanParameter());
		break;
	case RPC_SETPOSTURE__INT_BOOL_:
		setPosture(inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case RPC_SETACCELERATIONMULTIPLIERBASE__FLOAT_BOOL_:
		setAccelerationMultiplierBase(inv->getFloatParameter(), inv->getBooleanParameter());
		break;
	case RPC_SETACCELERATIONMULTIPLIERMOD__FLOAT_BOOL_:
		setAccelerationMultiplierMod(inv->getFloatParameter(), inv->getBooleanParameter());
		break;
	case RPC_SETSPEEDMULTIPLIERBASE__FLOAT_BOOL_:
		setSpeedMultiplierBase(inv->getFloatParameter(), inv->getBooleanParameter());
		break;
	case RPC_SETSPEEDMULTIPLIERMOD__FLOAT_BOOL_:
		setSpeedMultiplierMod(inv->getFloatParameter(), inv->getBooleanParameter());
		break;
	case RPC_SETRUNSPEED__FLOAT_BOOL_:
		setRunSpeed(inv->getFloatParameter(), inv->getBooleanParameter());
		break;
	case RPC_SETHAM__INT_INT_BOOL_:
		setHAM(inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_INT_BOOL_BOOL_:
		resp->insertSignedInt(inflictDamage((TangibleObject*) inv->getObjectParameter(), inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter(), inv->getBooleanParameter()));
		break;
	case RPC_HASDAMAGE__INT_:
		resp->insertBoolean(hasDamage(inv->getSignedIntParameter()));
		break;
	case RPC_HEALDAMAGE__TANGIBLEOBJECT_INT_INT_BOOL_:
		resp->insertSignedInt(healDamage((TangibleObject*) inv->getObjectParameter(), inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter()));
		break;
	case RPC_SETBASEHAM__INT_INT_BOOL_:
		setBaseHAM(inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case RPC_SETWOUNDS__INT_INT_BOOL_:
		setWounds(inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case RPC_ADDWOUNDS__INT_INT_BOOL_:
		resp->insertSignedInt(addWounds(inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter()));
		break;
	case RPC_SETMAXHAM__INT_INT_BOOL_:
		setMaxHAM(inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case RPC_ADDMAXHAM__INT_INT_BOOL_:
		addMaxHAM(inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case RPC_SETENCUMBRANCE__INT_INT_BOOL_:
		setEncumbrance(inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case RPC_ADDENCUMBRANCE__INT_INT_BOOL_:
		addEncumbrance(inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case RPC_SETWEAPON__WEAPONOBJECT_BOOL_:
		setWeapon((WeaponObject*) inv->getObjectParameter(), inv->getBooleanParameter());
		break;
	case RPC_NOTIFYOBJECTINSERTED__SCENEOBJECT_:
		resp->insertSignedInt(notifyObjectInserted((SceneObject*) inv->getObjectParameter()));
		break;
	case RPC_NOTIFYOBJECTREMOVED__SCENEOBJECT_:
		resp->insertSignedInt(notifyObjectRemoved((SceneObject*) inv->getObjectParameter()));
		break;
	case RPC_SETINSTRUMENTID__INT_BOOL_:
		setInstrumentID(inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case RPC_SETLISTENTOID__LONG_BOOL_:
		setListenToID(inv->getUnsignedLongParameter(), inv->getBooleanParameter());
		break;
	case RPC_SETPERFORMANCECOUNTER__INT_BOOL_:
		setPerformanceCounter(inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case RPC_SETPERFORMANCEANIMATION__STRING_BOOL_:
		setPerformanceAnimation(inv->getAsciiParameter(_param0_setPerformanceAnimation__String_bool_), inv->getBooleanParameter());
		break;
	case RPC_SETSHOCKWOUNDS__INT_BOOL_:
		setShockWounds(inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case RPC_ADDSHOCKWOUNDS__INT_BOOL_:
		addShockWounds(inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case RPC_SETTARGETID__LONG_BOOL_:
		setTargetID(inv->getUnsignedLongParameter(), inv->getBooleanParameter());
		break;
	case RPC_SETBANKCREDITS__INT_BOOL_:
		setBankCredits(inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case RPC_ADDBUFF__BUFF_:
		addBuff((Buff*) inv->getObjectParameter());
		break;
	case RPC_REMOVEBUFF__INT_:
		removeBuff(inv->getUnsignedIntParameter());
		break;
	case RPC_REMOVEBUFF__BUFF_:
		removeBuff((Buff*) inv->getObjectParameter());
		break;
	case RPC_CLEARBUFFS__BOOL_:
		clearBuffs(inv->getBooleanParameter());
		break;
	case RPC_GETBUFF__INT_:
		resp->insertLong(getBuff(inv->getUnsignedIntParameter())->_getObjectID());
		break;
	case RPC_ADDDOTSTATE__LONG_INT_BYTE_INT_FLOAT_INT_:
		resp->insertSignedInt(addDotState(inv->getUnsignedLongParameter(), inv->getUnsignedIntParameter(), inv->getByteParameter(), inv->getUnsignedIntParameter(), inv->getFloatParameter(), inv->getUnsignedIntParameter()));
		break;
	case RPC_HEALDOT__LONG_INT_:
		resp->insertBoolean(healDot(inv->getUnsignedLongParameter(), inv->getSignedIntParameter()));
		break;
	case RPC_CLEARDOTS__:
		clearDots();
		break;
	case RPC_HASBUFF__INT_:
		resp->insertBoolean(hasBuff(inv->getUnsignedIntParameter()));
		break;
	case RPC_NOTIFYSELFPOSITIONUPDATE__:
		notifySelfPositionUpdate();
		break;
	case RPC_NOTIFYPOSTURECHANGE__INT_:
		notifyPostureChange(inv->getSignedIntParameter());
		break;
	case RPC_UPDATETODATABASEALLOBJECTS__BOOL_:
		updateToDatabaseAllObjects(inv->getBooleanParameter());
		break;
	case RPC_ISRESUSCITABLE__:
		resp->insertBoolean(isResuscitable());
		break;
	case RPC_ADDBANKCREDITS__INT_BOOL_:
		addBankCredits(inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case RPC_ADDCASHCREDITS__INT_BOOL_:
		addCashCredits(inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case RPC_SUBSTRACTBANKCREDITS__INT_:
		substractBankCredits(inv->getSignedIntParameter());
		break;
	case RPC_SUBSTRACTCASHCREDITS__INT_:
		substractCashCredits(inv->getSignedIntParameter());
		break;
	case RPC_VERIFYCASHCREDITS__INT_:
		resp->insertBoolean(verifyCashCredits(inv->getSignedIntParameter()));
		break;
	case RPC_VERIFYBANKCREDITS__INT_:
		resp->insertBoolean(verifyBankCredits(inv->getSignedIntParameter()));
		break;
	case RPC_ISDANCING__:
		resp->insertBoolean(isDancing());
		break;
	case RPC_ISPLAYINGMUSIC__:
		resp->insertBoolean(isPlayingMusic());
		break;
	case RPC_STOPENTERTAINING__:
		stopEntertaining();
		break;
	case RPC_ISENTERTAINING__:
		resp->insertBoolean(isEntertaining());
		break;
	case RPC_SETCASHCREDITS__INT_BOOL_:
		setCashCredits(inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case RPC_SETTERRAINNEGOTIATION__FLOAT_BOOL_:
		setTerrainNegotiation(inv->getFloatParameter(), inv->getBooleanParameter());
		break;
	case RPC_ADDSKILLBOX__STRING_BOOL_:
		addSkillBox(inv->getAsciiParameter(_param0_addSkillBox__String_bool_), inv->getBooleanParameter());
		break;
	case RPC_REMOVESKILLBOX__STRING_BOOL_:
		removeSkillBox(inv->getAsciiParameter(_param0_removeSkillBox__String_bool_), inv->getBooleanParameter());
		break;
	case RPC_ADDSKILLMOD__STRING_LONG_BOOL_:
		addSkillMod(inv->getAsciiParameter(_param0_addSkillMod__String_long_bool_), inv->getSignedLongParameter(), inv->getBooleanParameter());
		break;
	case RPC_REMOVESKILLMOD__STRING_BOOL_:
		removeSkillMod(inv->getAsciiParameter(_param0_removeSkillMod__String_bool_), inv->getBooleanParameter());
		break;
	case RPC_UPDATEGROUPINVITERID__LONG_BOOL_:
		updateGroupInviterID(inv->getUnsignedLongParameter(), inv->getBooleanParameter());
		break;
	case RPC_UPDATEGROUP__GROUPOBJECT_BOOL_:
		updateGroup((GroupObject*) inv->getObjectParameter(), inv->getBooleanParameter());
		break;
	case RPC_ENQUEUECOMMAND__INT_INT_LONG_UNICODESTRING_INT_:
		enqueueCommand(inv->getUnsignedIntParameter(), inv->getUnsignedIntParameter(), inv->getUnsignedLongParameter(), inv->getUnicodeParameter(_param3_enqueueCommand__int_int_long_UnicodeString_int_), inv->getSignedIntParameter());
		break;
	case RPC_SETMOOD__BYTE_BOOL_:
		setMood(inv->getByteParameter(), inv->getBooleanParameter());
		break;
	case RPC_SETMOODSTRING__STRING_BOOL_:
		setMoodString(inv->getAsciiParameter(_param0_setMoodString__String_bool_), inv->getBooleanParameter());
		break;
	case RPC_DELETEQUEUEACTION__INT_:
		deleteQueueAction(inv->getUnsignedIntParameter());
		break;
	case RPC_SETSTATE__LONG_BOOL_:
		resp->insertBoolean(setState(inv->getUnsignedLongParameter(), inv->getBooleanParameter()));
		break;
	case RPC_CLEARSTATE__LONG_BOOL_:
		resp->insertBoolean(clearState(inv->getUnsignedLongParameter(), inv->getBooleanParameter()));
		break;
	case RPC_SETCONTROLDEVICE__CONTROLDEVICE_:
		setControlDevice((ControlDevice*) inv->getObjectParameter());
		break;
	case RPC_GETWEARABLEMASK__:
		resp->insertInt(getWearableMask());
		break;
	case RPC_SETCREATURELINK__CREATUREOBJECT_BOOL_:
		setCreatureLink((CreatureObject*) inv->getObjectParameter(), inv->getBooleanParameter());
		break;
	case RPC_EXECUTEOBJECTCONTROLLERACTION__INT_:
		executeObjectControllerAction(inv->getUnsignedIntParameter());
		break;
	case RPC_EXECUTEOBJECTCONTROLLERACTION__INT_LONG_UNICODESTRING_:
		executeObjectControllerAction(inv->getUnsignedIntParameter(), inv->getUnsignedLongParameter(), inv->getUnicodeParameter(_param2_executeObjectControllerAction__int_long_UnicodeString_));
		break;
	case RPC_ISATTACKABLEBY__CREATUREOBJECT_:
		resp->insertBoolean(isAttackableBy((CreatureObject*) inv->getObjectParameter()));
		break;
	case RPC_SENDCONVERSATIONSTARTTO__SCENEOBJECT_:
		sendConversationStartTo((SceneObject*) inv->getObjectParameter());
		break;
	case RPC_SELECTCONVERSATIONOPTION__INT_SCENEOBJECT_:
		selectConversationOption(inv->getSignedIntParameter(), (SceneObject*) inv->getObjectParameter());
		break;
	case RPC_CANTREATINJURIES__:
		resp->insertBoolean(canTreatInjuries());
		break;
	case RPC_CANTREATSTATES__:
		resp->insertBoolean(canTreatStates());
		break;
	case RPC_CANTREATWOUNDS__:
		resp->insertBoolean(canTreatWounds());
		break;
	case RPC_CANTREATCONDITIONS__:
		resp->insertBoolean(canTreatConditions());
		break;
	case RPC_ISLISTENING__:
		resp->insertBoolean(isListening());
		break;
	case RPC_ISWATCHING__:
		resp->insertBoolean(isWatching());
		break;
	case RPC_DISMOUNT__:
		dismount();
		break;
	case RPC_CALCULATEBFRATIO__:
		resp->insertFloat(calculateBFRatio());
		break;
	case RPC_SETDIZZIEDSTATE__INT_:
		setDizziedState(inv->getSignedIntParameter());
		break;
	case RPC_SETRALLIEDSTATE__INT_:
		setRalliedState(inv->getSignedIntParameter());
		break;
	case RPC_SETAIMINGSTATE__INT_:
		setAimingState(inv->getSignedIntParameter());
		break;
	case RPC_SETCOVERSTATE__INT_:
		setCoverState(inv->getSignedIntParameter());
		break;
	case RPC_SETBERSERKEDSTATE__INT_:
		setBerserkedState(inv->getUnsignedIntParameter());
		break;
	case RPC_SETSTUNNEDSTATE__INT_:
		setStunnedState(inv->getSignedIntParameter());
		break;
	case RPC_SETBLINDEDSTATE__INT_:
		setBlindedState(inv->getSignedIntParameter());
		break;
	case RPC_SETINTIMIDATEDSTATE__INT_:
		setIntimidatedState(inv->getSignedIntParameter());
		break;
	case RPC_SETSNAREDSTATE__INT_:
		setSnaredState(inv->getSignedIntParameter());
		break;
	case RPC_SETROOTEDSTATE__INT_:
		setRootedState(inv->getSignedIntParameter());
		break;
	case RPC_SETNEXTATTACKDELAY__INT_:
		resp->insertBoolean(setNextAttackDelay(inv->getSignedIntParameter()));
		break;
	case RPC_SETMEDITATESTATE__:
		setMeditateState();
		break;
	case RPC_ACTIVATEHAMREGENERATION__:
		activateHAMRegeneration();
		break;
	case RPC_ACTIVATESTATERECOVERY__:
		activateStateRecovery();
		break;
	case RPC_UPDATETIMEOFDEATH__:
		updateTimeOfDeath();
		break;
	case RPC_HASATTACKDELAY__:
		resp->insertBoolean(hasAttackDelay());
		break;
	case RPC_REMOVEATTACKDELAY__:
		removeAttackDelay();
		break;
	case RPC_HASSPICE__:
		resp->insertBoolean(hasSpice());
		break;
	case RPC_UPDATELASTSUCCESSFULCOMBATACTION__:
		updateLastSuccessfulCombatAction();
		break;
	case RPC_UPDATEKNOCKDOWNRECOVERY__:
		updateKnockdownRecovery();
		break;
	case RPC_QUEUEDIZZYFALLEVENT__:
		queueDizzyFallEvent();
		break;
	case RPC_UPDATELASTKNOCKDOWN__:
		updateLastKnockdown();
		break;
	case RPC_CHECKKNOCKDOWNRECOVERY__:
		resp->insertBoolean(checkKnockdownRecovery());
		break;
	case RPC_CHECKLASTKNOCKDOWN__:
		resp->insertBoolean(checkLastKnockdown());
		break;
	case RPC_UPDATEPOSTUREDOWNRECOVERY__:
		updatePostureDownRecovery();
		break;
	case RPC_UPDATEPOSTUREUPRECOVERY__:
		updatePostureUpRecovery();
		break;
	case RPC_CHECKPOSTUREDOWNRECOVERY__:
		resp->insertBoolean(checkPostureDownRecovery());
		break;
	case RPC_CHECKPOSTUREUPRECOVERY__:
		resp->insertBoolean(checkPostureUpRecovery());
		break;
	case RPC_UPDATECOOLDOWNTIMER__STRING_INT_:
		updateCooldownTimer(inv->getAsciiParameter(_param0_updateCooldownTimer__String_int_), inv->getUnsignedIntParameter());
		break;
	case RPC_CHECKCOOLDOWNRECOVERY__STRING_:
		resp->insertBoolean(checkCooldownRecovery(inv->getAsciiParameter(_param0_checkCooldownRecovery__String_)));
		break;
	case RPC_ADDCOOLDOWN__STRING_INT_:
		addCooldown(inv->getAsciiParameter(_param0_addCooldown__String_int_), inv->getUnsignedIntParameter());
		break;
	case RPC_CANADDOBJECT__SCENEOBJECT_INT_STRING_:
		resp->insertSignedInt(canAddObject((SceneObject*) inv->getObjectParameter(), inv->getSignedIntParameter(), inv->getAsciiParameter(_param2_canAddObject__SceneObject_int_String_)));
		break;
	case RPC_DOANIMATION__STRING_:
		doAnimation(inv->getAsciiParameter(_param0_doAnimation__String_));
		break;
	case RPC_DOCOMBATANIMATION__CREATUREOBJECT_INT_BYTE_:
		doCombatAnimation((CreatureObject*) inv->getObjectParameter(), inv->getUnsignedIntParameter(), inv->getByteParameter());
		break;
	case RPC_PLAYEFFECT__STRING_STRING_:
		playEffect(inv->getAsciiParameter(_param0_playEffect__String_String_), inv->getAsciiParameter(_param1_playEffect__String_String_));
		break;
	case RPC_PLAYEFFECT__STRING_:
		playEffect(inv->getAsciiParameter(_param0_playEffect__String_));
		break;
	case RPC_SHOWFLYTEXT__STRING_STRING_BYTE_BYTE_BYTE_:
		showFlyText(inv->getAsciiParameter(_param0_showFlyText__String_String_byte_byte_byte_), inv->getAsciiParameter(_param1_showFlyText__String_String_byte_byte_byte_), inv->getByteParameter(), inv->getByteParameter(), inv->getByteParameter());
		break;
	case RPC_ACTIVATEQUEUEACTION__:
		activateQueueAction();
		break;
	case RPC_GETCREATURENAME__:
		resp->insertUnicode(getCreatureName());
		break;
	case RPC_ISGROUPED__:
		resp->insertBoolean(isGrouped());
		break;
	case RPC_GETBANKCREDITS__:
		resp->insertSignedInt(getBankCredits());
		break;
	case RPC_GETCASHCREDITS__:
		resp->insertSignedInt(getCashCredits());
		break;
	case RPC_GETBASEHAM__INT_:
		resp->insertSignedInt(getBaseHAM(inv->getSignedIntParameter()));
		break;
	case RPC_GETWOUNDS__INT_:
		resp->insertSignedInt(getWounds(inv->getSignedIntParameter()));
		break;
	case RPC_GETHAM__INT_:
		resp->insertSignedInt(getHAM(inv->getSignedIntParameter()));
		break;
	case RPC_GETMAXHAM__INT_:
		resp->insertSignedInt(getMaxHAM(inv->getSignedIntParameter()));
		break;
	case RPC_GETENCUMBRANCE__INT_:
		resp->insertSignedInt(getEncumbrance(inv->getSignedIntParameter()));
		break;
	case RPC_GETPOSTURE__:
		resp->insertByte(getPosture());
		break;
	case RPC_GETFACTIONRANK__:
		resp->insertByte(getFactionRank());
		break;
	case RPC_GETLINKEDCREATURE__:
		resp->insertLong(getLinkedCreature()->_getObjectID());
		break;
	case RPC_GETCREATURELINKID__:
		resp->insertLong(getCreatureLinkID());
		break;
	case RPC_GETSHOCKWOUNDS__:
		resp->insertFloat(getShockWounds());
		break;
	case RPC_GETWATCHTOID__:
		resp->insertLong(getWatchToID());
		break;
	case RPC_GETSTATEBITMASK__:
		resp->insertLong(getStateBitmask());
		break;
	case RPC_HASSTATE__LONG_:
		resp->insertBoolean(hasState(inv->getUnsignedLongParameter()));
		break;
	case RPC_HASSTATES__:
		resp->insertBoolean(hasStates());
		break;
	case RPC_GETLISTENID__:
		resp->insertLong(getListenID());
		break;
	case RPC_GETACCELERATIONMULTIPLIERBASE__:
		resp->insertFloat(getAccelerationMultiplierBase());
		break;
	case RPC_GETACCELERATIONMULTIPLIERMOD__:
		resp->insertFloat(getAccelerationMultiplierMod());
		break;
	case RPC_GETSPEEDMULTIPLIERBASE__:
		resp->insertFloat(getSpeedMultiplierBase());
		break;
	case RPC_GETSPEEDMULTIPLIERMOD__:
		resp->insertFloat(getSpeedMultiplierMod());
		break;
	case RPC_GETRUNSPEED__:
		resp->insertFloat(getRunSpeed());
		break;
	case RPC_GETWALKSPEED__:
		resp->insertFloat(getWalkSpeed());
		break;
	case RPC_GETTERRAINNEGOTIATION__:
		resp->insertFloat(getTerrainNegotiation());
		break;
	case RPC_GETRUNACCELERATION__:
		resp->insertFloat(getRunAcceleration());
		break;
	case RPC_GETWALKACCELERATION__:
		resp->insertFloat(getWalkAcceleration());
		break;
	case RPC_GETPERFORMANCEANIMATION__:
		resp->insertAscii(getPerformanceAnimation());
		break;
	case RPC_GETMOODSTRING__:
		resp->insertAscii(getMoodString());
		break;
	case RPC_GETWEAPONID__:
		resp->insertLong(getWeaponID());
		break;
	case RPC_GETWEAPON__:
		resp->insertLong(getWeapon()->_getObjectID());
		break;
	case RPC_GETGUILDOBJECT__:
		resp->insertLong(getGuildObject()->_getObjectID());
		break;
	case RPC_GETGUILDID__:
		resp->insertSignedInt(getGuildID());
		break;
	case RPC_ISINGUILD__:
		resp->insertBoolean(isInGuild());
		break;
	case RPC_SETGUILDOBJECT__GUILDOBJECT_:
		setGuildObject((GuildObject*) inv->getObjectParameter());
		break;
	case RPC_GETGROUPID__:
		resp->insertLong(getGroupID());
		break;
	case RPC_GETGROUPINVITERID__:
		resp->insertLong(getGroupInviterID());
		break;
	case RPC_GETGROUP__:
		resp->insertLong(getGroup()->_getObjectID());
		break;
	case RPC_GETGROUPINVITECOUNTER__:
		resp->insertLong(getGroupInviteCounter());
		break;
	case RPC_GETTARGETID__:
		resp->insertLong(getTargetID());
		break;
	case RPC_GETMOODID__:
		resp->insertByte(getMoodID());
		break;
	case RPC_GETSLOPEMODPERCENT__:
		resp->insertFloat(getSlopeModPercent());
		break;
	case RPC_GETPERFORMANCECOUNTER__:
		resp->insertSignedInt(getPerformanceCounter());
		break;
	case RPC_GETINSTRUMENTID__:
		resp->insertSignedInt(getInstrumentID());
		break;
	case RPC_GETFROZEN__:
		resp->insertByte(getFrozen());
		break;
	case RPC_GETHEIGHT__:
		resp->insertFloat(getHeight());
		break;
	case RPC_GETSPECIES__:
		resp->insertSignedInt(getSpecies());
		break;
	case RPC_GETSPECIESNAME__:
		resp->insertAscii(getSpeciesName());
		break;
	case RPC_GETGENDER__:
		resp->insertSignedInt(getGender());
		break;
	case RPC_GETSKILLMOD__STRING_:
		resp->insertSignedLong(getSkillMod(inv->getAsciiParameter(_param0_getSkillMod__String_)));
		break;
	case RPC_HASSKILLBOX__STRING_:
		resp->insertBoolean(hasSkillBox(inv->getAsciiParameter(_param0_hasSkillBox__String_)));
		break;
	case RPC_SETHEIGHT__FLOAT_:
		setHeight(inv->getFloatParameter());
		break;
	case RPC_SETWATCHTOID__LONG_:
		setWatchToID(inv->getUnsignedLongParameter());
		break;
	case RPC_ISCREATUREOBJECT__:
		resp->insertBoolean(isCreatureObject());
		break;
	case RPC_ISTRAINERCREATURE__:
		resp->insertBoolean(isTrainerCreature());
		break;
	case RPC_ISSWIMMING__:
		resp->insertBoolean(isSwimming());
		break;
	case RPC_ISRIDINGMOUNT__:
		resp->insertBoolean(isRidingMount());
		break;
	case RPC_GETCONTROLDEVICE__:
		resp->insertLong(getControlDevice()->_getObjectID());
		break;
	case RPC_GETSWIMHEIGHT__:
		resp->insertFloat(getSwimHeight());
		break;
	case RPC_ISINCAPACITATED__:
		resp->insertBoolean(isIncapacitated());
		break;
	case RPC_ISDEAD__:
		resp->insertBoolean(isDead());
		break;
	case RPC_ISKNOCKEDDOWN__:
		resp->insertBoolean(isKnockedDown());
		break;
	case RPC_ISKNEELING__:
		resp->insertBoolean(isKneeling());
		break;
	case RPC_ISPRONE__:
		resp->insertBoolean(isProne());
		break;
	case RPC_ISSTANDING__:
		resp->insertBoolean(isStanding());
		break;
	case RPC_ISSITTING__:
		resp->insertBoolean(isSitting());
		break;
	case RPC_ISSKILLANIMATING__:
		resp->insertBoolean(isSkillAnimating());
		break;
	case RPC_ISRALLIED__:
		resp->insertBoolean(isRallied());
		break;
	case RPC_ISINCOMBAT__:
		resp->insertBoolean(isInCombat());
		break;
	case RPC_ISDIZZIED__:
		resp->insertBoolean(isDizzied());
		break;
	case RPC_ISBERSERKED__:
		resp->insertBoolean(isBerserked());
		break;
	case RPC_ISSTUNNED__:
		resp->insertBoolean(isStunned());
		break;
	case RPC_ISBLINDED__:
		resp->insertBoolean(isBlinded());
		break;
	case RPC_ISINTIMIDATED__:
		resp->insertBoolean(isIntimidated());
		break;
	case RPC_ISSNARED__:
		resp->insertBoolean(isSnared());
		break;
	case RPC_ISROOTED__:
		resp->insertBoolean(isRooted());
		break;
	case RPC_ISDISEASED__:
		resp->insertBoolean(isDiseased());
		break;
	case RPC_ISPOISONED__:
		resp->insertBoolean(isPoisoned());
		break;
	case RPC_ISBLEEDING__:
		resp->insertBoolean(isBleeding());
		break;
	case RPC_ISONFIRE__:
		resp->insertBoolean(isOnFire());
		break;
	case RPC_ISMOUNTED__:
		resp->insertBoolean(isMounted());
		break;
	case RPC_ISRIDINGCREATURE__:
		resp->insertBoolean(isRidingCreature());
		break;
	case RPC_ISPEACED__:
		resp->insertBoolean(isPeaced());
		break;
	case RPC_ISMEDITATING__:
		resp->insertBoolean(isMeditating());
		break;
	case RPC_ISAIMING__:
		resp->insertBoolean(isAiming());
		break;
	case RPC_ISINCOVER__:
		resp->insertBoolean(isInCover());
		break;
	case RPC_ISNONPLAYERCREATURE__:
		resp->insertBoolean(isNonPlayerCreature());
		break;
	case RPC_ISCREATURE__:
		resp->insertBoolean(isCreature());
		break;
	case RPC_ISAIAGENT__:
		resp->insertBoolean(isAiAgent());
		break;
	case RPC_ISINFORMANTCREATURE__:
		resp->insertBoolean(isInformantCreature());
		break;
	case RPC_ISVENDORCREATURE__:
		resp->insertBoolean(isVendorCreature());
		break;
	default:
		return NULL;
	}

	return resp;
}

void CreatureObjectAdapter::initializeMembers() {
	((CreatureObjectImplementation*) impl)->initializeMembers();
}

void CreatureObjectAdapter::finalize() {
	((CreatureObjectImplementation*) impl)->finalize();
}

void CreatureObjectAdapter::initializeTransientMembers() {
	((CreatureObjectImplementation*) impl)->initializeTransientMembers();
}

void CreatureObjectAdapter::clearQueueAction(unsigned int actioncntr, float timer, unsigned int tab1, unsigned int tab2) {
	((CreatureObjectImplementation*) impl)->clearQueueAction(actioncntr, timer, tab1, tab2);
}

void CreatureObjectAdapter::sendBaselinesTo(SceneObject* player) {
	((CreatureObjectImplementation*) impl)->sendBaselinesTo(player);
}

void CreatureObjectAdapter::sendSystemMessage(const String& message) {
	((CreatureObjectImplementation*) impl)->sendSystemMessage(message);
}

void CreatureObjectAdapter::sendSystemMessage(UnicodeString& message) {
	((CreatureObjectImplementation*) impl)->sendSystemMessage(message);
}

void CreatureObjectAdapter::sendSystemMessage(const String& file, const String& stringid) {
	((CreatureObjectImplementation*) impl)->sendSystemMessage(file, stringid);
}

void CreatureObjectAdapter::sendSlottedObjectsTo(SceneObject* player) {
	((CreatureObjectImplementation*) impl)->sendSlottedObjectsTo(player);
}

void CreatureObjectAdapter::setCombatState() {
	((CreatureObjectImplementation*) impl)->setCombatState();
}

void CreatureObjectAdapter::clearCombatState(bool clearDefenders) {
	((CreatureObjectImplementation*) impl)->clearCombatState(clearDefenders);
}

void CreatureObjectAdapter::setPosture(int newPosture, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setPosture(newPosture, notifyClient);
}

void CreatureObjectAdapter::setAccelerationMultiplierBase(float newMultiplierBase, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setAccelerationMultiplierBase(newMultiplierBase, notifyClient);
}

void CreatureObjectAdapter::setAccelerationMultiplierMod(float newMultiplierMod, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setAccelerationMultiplierMod(newMultiplierMod, notifyClient);
}

void CreatureObjectAdapter::setSpeedMultiplierBase(float newMultiplierBase, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setSpeedMultiplierBase(newMultiplierBase, notifyClient);
}

void CreatureObjectAdapter::setSpeedMultiplierMod(float newMultiplierMod, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setSpeedMultiplierMod(newMultiplierMod, notifyClient);
}

void CreatureObjectAdapter::setRunSpeed(float newSpeed, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setRunSpeed(newSpeed, notifyClient);
}

void CreatureObjectAdapter::setHAM(int type, int value, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setHAM(type, value, notifyClient);
}

int CreatureObjectAdapter::inflictDamage(TangibleObject* attacker, int damageType, int damage, bool destroy, bool notifyClient) {
	return ((CreatureObjectImplementation*) impl)->inflictDamage(attacker, damageType, damage, destroy, notifyClient);
}

bool CreatureObjectAdapter::hasDamage(int attribute) {
	return ((CreatureObjectImplementation*) impl)->hasDamage(attribute);
}

int CreatureObjectAdapter::healDamage(TangibleObject* healer, int damageType, int damage, bool notifyClient) {
	return ((CreatureObjectImplementation*) impl)->healDamage(healer, damageType, damage, notifyClient);
}

void CreatureObjectAdapter::setBaseHAM(int type, int value, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setBaseHAM(type, value, notifyClient);
}

void CreatureObjectAdapter::setWounds(int type, int value, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setWounds(type, value, notifyClient);
}

int CreatureObjectAdapter::addWounds(int type, int value, bool notifyClient) {
	return ((CreatureObjectImplementation*) impl)->addWounds(type, value, notifyClient);
}

void CreatureObjectAdapter::setMaxHAM(int type, int value, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setMaxHAM(type, value, notifyClient);
}

void CreatureObjectAdapter::addMaxHAM(int type, int value, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->addMaxHAM(type, value, notifyClient);
}

void CreatureObjectAdapter::setEncumbrance(int type, int value, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setEncumbrance(type, value, notifyClient);
}

void CreatureObjectAdapter::addEncumbrance(int type, int value, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->addEncumbrance(type, value, notifyClient);
}

void CreatureObjectAdapter::setWeapon(WeaponObject* weao, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setWeapon(weao, notifyClient);
}

int CreatureObjectAdapter::notifyObjectInserted(SceneObject* object) {
	return ((CreatureObjectImplementation*) impl)->notifyObjectInserted(object);
}

int CreatureObjectAdapter::notifyObjectRemoved(SceneObject* object) {
	return ((CreatureObjectImplementation*) impl)->notifyObjectRemoved(object);
}

void CreatureObjectAdapter::setInstrumentID(int instrumentid, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setInstrumentID(instrumentid, notifyClient);
}

void CreatureObjectAdapter::setListenToID(unsigned long long id, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setListenToID(id, notifyClient);
}

void CreatureObjectAdapter::setPerformanceCounter(int counter, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setPerformanceCounter(counter, notifyClient);
}

void CreatureObjectAdapter::setPerformanceAnimation(const String& animation, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setPerformanceAnimation(animation, notifyClient);
}

void CreatureObjectAdapter::setShockWounds(int newShock, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setShockWounds(newShock, notifyClient);
}

void CreatureObjectAdapter::addShockWounds(int shockToAdd, bool notiyClient) {
	((CreatureObjectImplementation*) impl)->addShockWounds(shockToAdd, notiyClient);
}

void CreatureObjectAdapter::setTargetID(unsigned long long targetID, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setTargetID(targetID, notifyClient);
}

void CreatureObjectAdapter::setBankCredits(int credits, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setBankCredits(credits, notifyClient);
}

void CreatureObjectAdapter::addBuff(Buff* buff) {
	((CreatureObjectImplementation*) impl)->addBuff(buff);
}

void CreatureObjectAdapter::removeBuff(unsigned int buffcrc) {
	((CreatureObjectImplementation*) impl)->removeBuff(buffcrc);
}

void CreatureObjectAdapter::removeBuff(Buff* buff) {
	((CreatureObjectImplementation*) impl)->removeBuff(buff);
}

void CreatureObjectAdapter::clearBuffs(bool updateclient) {
	((CreatureObjectImplementation*) impl)->clearBuffs(updateclient);
}

Buff* CreatureObjectAdapter::getBuff(unsigned int buffcrc) {
	return ((CreatureObjectImplementation*) impl)->getBuff(buffcrc);
}

int CreatureObjectAdapter::addDotState(unsigned long long dotType, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense) {
	return ((CreatureObjectImplementation*) impl)->addDotState(dotType, strength, type, duration, potency, defense);
}

bool CreatureObjectAdapter::healDot(unsigned long long dotType, int reduction) {
	return ((CreatureObjectImplementation*) impl)->healDot(dotType, reduction);
}

void CreatureObjectAdapter::clearDots() {
	((CreatureObjectImplementation*) impl)->clearDots();
}

bool CreatureObjectAdapter::hasBuff(unsigned int buffcrc) {
	return ((CreatureObjectImplementation*) impl)->hasBuff(buffcrc);
}

void CreatureObjectAdapter::notifySelfPositionUpdate() {
	((CreatureObjectImplementation*) impl)->notifySelfPositionUpdate();
}

void CreatureObjectAdapter::notifyPostureChange(int newPosture) {
	((CreatureObjectImplementation*) impl)->notifyPostureChange(newPosture);
}

void CreatureObjectAdapter::updateToDatabaseAllObjects(bool startTask) {
	((CreatureObjectImplementation*) impl)->updateToDatabaseAllObjects(startTask);
}

bool CreatureObjectAdapter::isResuscitable() {
	return ((CreatureObjectImplementation*) impl)->isResuscitable();
}

void CreatureObjectAdapter::addBankCredits(int credits, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->addBankCredits(credits, notifyClient);
}

void CreatureObjectAdapter::addCashCredits(int credits, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->addCashCredits(credits, notifyClient);
}

void CreatureObjectAdapter::substractBankCredits(int credits) {
	((CreatureObjectImplementation*) impl)->substractBankCredits(credits);
}

void CreatureObjectAdapter::substractCashCredits(int credits) {
	((CreatureObjectImplementation*) impl)->substractCashCredits(credits);
}

bool CreatureObjectAdapter::verifyCashCredits(int credits) {
	return ((CreatureObjectImplementation*) impl)->verifyCashCredits(credits);
}

bool CreatureObjectAdapter::verifyBankCredits(int credits) {
	return ((CreatureObjectImplementation*) impl)->verifyBankCredits(credits);
}

bool CreatureObjectAdapter::isDancing() {
	return ((CreatureObjectImplementation*) impl)->isDancing();
}

bool CreatureObjectAdapter::isPlayingMusic() {
	return ((CreatureObjectImplementation*) impl)->isPlayingMusic();
}

void CreatureObjectAdapter::stopEntertaining() {
	((CreatureObjectImplementation*) impl)->stopEntertaining();
}

bool CreatureObjectAdapter::isEntertaining() {
	return ((CreatureObjectImplementation*) impl)->isEntertaining();
}

void CreatureObjectAdapter::setCashCredits(int credits, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setCashCredits(credits, notifyClient);
}

void CreatureObjectAdapter::setTerrainNegotiation(float value, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setTerrainNegotiation(value, notifyClient);
}

void CreatureObjectAdapter::addSkillBox(const String& skillBox, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->addSkillBox(skillBox, notifyClient);
}

void CreatureObjectAdapter::removeSkillBox(const String& skillBox, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->removeSkillBox(skillBox, notifyClient);
}

void CreatureObjectAdapter::addSkillMod(const String& skillMod, long long value, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->addSkillMod(skillMod, value, notifyClient);
}

void CreatureObjectAdapter::removeSkillMod(const String& skillMod, bool notifyCLient) {
	((CreatureObjectImplementation*) impl)->removeSkillMod(skillMod, notifyCLient);
}

void CreatureObjectAdapter::updateGroupInviterID(unsigned long long id, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->updateGroupInviterID(id, notifyClient);
}

void CreatureObjectAdapter::updateGroup(GroupObject* group, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->updateGroup(group, notifyClient);
}

void CreatureObjectAdapter::enqueueCommand(unsigned int actionCRC, unsigned int actionCount, unsigned long long targetID, const UnicodeString& arguments, int priority) {
	((CreatureObjectImplementation*) impl)->enqueueCommand(actionCRC, actionCount, targetID, arguments, priority);
}

void CreatureObjectAdapter::setMood(byte moodID, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setMood(moodID, notifyClient);
}

void CreatureObjectAdapter::setMoodString(const String& animation, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setMoodString(animation, notifyClient);
}

void CreatureObjectAdapter::deleteQueueAction(unsigned int actionCount) {
	((CreatureObjectImplementation*) impl)->deleteQueueAction(actionCount);
}

bool CreatureObjectAdapter::setState(unsigned long long state, bool notifyClient) {
	return ((CreatureObjectImplementation*) impl)->setState(state, notifyClient);
}

bool CreatureObjectAdapter::clearState(unsigned long long state, bool notifyClient) {
	return ((CreatureObjectImplementation*) impl)->clearState(state, notifyClient);
}

void CreatureObjectAdapter::setControlDevice(ControlDevice* device) {
	((CreatureObjectImplementation*) impl)->setControlDevice(device);
}

unsigned int CreatureObjectAdapter::getWearableMask() {
	return ((CreatureObjectImplementation*) impl)->getWearableMask();
}

void CreatureObjectAdapter::setCreatureLink(CreatureObject* object, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setCreatureLink(object, notifyClient);
}

void CreatureObjectAdapter::executeObjectControllerAction(unsigned int actionCRC) {
	((CreatureObjectImplementation*) impl)->executeObjectControllerAction(actionCRC);
}

void CreatureObjectAdapter::executeObjectControllerAction(unsigned int actionCRC, unsigned long long targetID, const UnicodeString& args) {
	((CreatureObjectImplementation*) impl)->executeObjectControllerAction(actionCRC, targetID, args);
}

bool CreatureObjectAdapter::isAttackableBy(CreatureObject* object) {
	return ((CreatureObjectImplementation*) impl)->isAttackableBy(object);
}

void CreatureObjectAdapter::sendConversationStartTo(SceneObject* player) {
	((CreatureObjectImplementation*) impl)->sendConversationStartTo(player);
}

void CreatureObjectAdapter::selectConversationOption(int option, SceneObject* obj) {
	((CreatureObjectImplementation*) impl)->selectConversationOption(option, obj);
}

bool CreatureObjectAdapter::canTreatInjuries() {
	return ((CreatureObjectImplementation*) impl)->canTreatInjuries();
}

bool CreatureObjectAdapter::canTreatStates() {
	return ((CreatureObjectImplementation*) impl)->canTreatStates();
}

bool CreatureObjectAdapter::canTreatWounds() {
	return ((CreatureObjectImplementation*) impl)->canTreatWounds();
}

bool CreatureObjectAdapter::canTreatConditions() {
	return ((CreatureObjectImplementation*) impl)->canTreatConditions();
}

bool CreatureObjectAdapter::isListening() {
	return ((CreatureObjectImplementation*) impl)->isListening();
}

bool CreatureObjectAdapter::isWatching() {
	return ((CreatureObjectImplementation*) impl)->isWatching();
}

void CreatureObjectAdapter::dismount() {
	((CreatureObjectImplementation*) impl)->dismount();
}

float CreatureObjectAdapter::calculateBFRatio() {
	return ((CreatureObjectImplementation*) impl)->calculateBFRatio();
}

void CreatureObjectAdapter::setDizziedState(int durationSeconds) {
	((CreatureObjectImplementation*) impl)->setDizziedState(durationSeconds);
}

void CreatureObjectAdapter::setRalliedState(int durationSeconds) {
	((CreatureObjectImplementation*) impl)->setRalliedState(durationSeconds);
}

void CreatureObjectAdapter::setAimingState(int durationSeconds) {
	((CreatureObjectImplementation*) impl)->setAimingState(durationSeconds);
}

void CreatureObjectAdapter::setCoverState(int durationSeconds) {
	((CreatureObjectImplementation*) impl)->setCoverState(durationSeconds);
}

void CreatureObjectAdapter::setBerserkedState(unsigned int duration) {
	((CreatureObjectImplementation*) impl)->setBerserkedState(duration);
}

void CreatureObjectAdapter::setStunnedState(int durationSeconds) {
	((CreatureObjectImplementation*) impl)->setStunnedState(durationSeconds);
}

void CreatureObjectAdapter::setBlindedState(int durationSeconds) {
	((CreatureObjectImplementation*) impl)->setBlindedState(durationSeconds);
}

void CreatureObjectAdapter::setIntimidatedState(int durationSeconds) {
	((CreatureObjectImplementation*) impl)->setIntimidatedState(durationSeconds);
}

void CreatureObjectAdapter::setSnaredState(int durationSeconds) {
	((CreatureObjectImplementation*) impl)->setSnaredState(durationSeconds);
}

void CreatureObjectAdapter::setRootedState(int durationSeconds) {
	((CreatureObjectImplementation*) impl)->setRootedState(durationSeconds);
}

bool CreatureObjectAdapter::setNextAttackDelay(int del) {
	return ((CreatureObjectImplementation*) impl)->setNextAttackDelay(del);
}

void CreatureObjectAdapter::setMeditateState() {
	((CreatureObjectImplementation*) impl)->setMeditateState();
}

void CreatureObjectAdapter::activateHAMRegeneration() {
	((CreatureObjectImplementation*) impl)->activateHAMRegeneration();
}

void CreatureObjectAdapter::activateStateRecovery() {
	((CreatureObjectImplementation*) impl)->activateStateRecovery();
}

void CreatureObjectAdapter::updateTimeOfDeath() {
	((CreatureObjectImplementation*) impl)->updateTimeOfDeath();
}

bool CreatureObjectAdapter::hasAttackDelay() {
	return ((CreatureObjectImplementation*) impl)->hasAttackDelay();
}

void CreatureObjectAdapter::removeAttackDelay() {
	((CreatureObjectImplementation*) impl)->removeAttackDelay();
}

bool CreatureObjectAdapter::hasSpice() {
	return ((CreatureObjectImplementation*) impl)->hasSpice();
}

void CreatureObjectAdapter::updateLastSuccessfulCombatAction() {
	((CreatureObjectImplementation*) impl)->updateLastSuccessfulCombatAction();
}

void CreatureObjectAdapter::updateKnockdownRecovery() {
	((CreatureObjectImplementation*) impl)->updateKnockdownRecovery();
}

void CreatureObjectAdapter::queueDizzyFallEvent() {
	((CreatureObjectImplementation*) impl)->queueDizzyFallEvent();
}

void CreatureObjectAdapter::updateLastKnockdown() {
	((CreatureObjectImplementation*) impl)->updateLastKnockdown();
}

bool CreatureObjectAdapter::checkKnockdownRecovery() {
	return ((CreatureObjectImplementation*) impl)->checkKnockdownRecovery();
}

bool CreatureObjectAdapter::checkLastKnockdown() {
	return ((CreatureObjectImplementation*) impl)->checkLastKnockdown();
}

void CreatureObjectAdapter::updatePostureDownRecovery() {
	((CreatureObjectImplementation*) impl)->updatePostureDownRecovery();
}

void CreatureObjectAdapter::updatePostureUpRecovery() {
	((CreatureObjectImplementation*) impl)->updatePostureUpRecovery();
}

bool CreatureObjectAdapter::checkPostureDownRecovery() {
	return ((CreatureObjectImplementation*) impl)->checkPostureDownRecovery();
}

bool CreatureObjectAdapter::checkPostureUpRecovery() {
	return ((CreatureObjectImplementation*) impl)->checkPostureUpRecovery();
}

void CreatureObjectAdapter::updateCooldownTimer(const String& coooldownTimer, unsigned int miliSecondsToAdd) {
	((CreatureObjectImplementation*) impl)->updateCooldownTimer(coooldownTimer, miliSecondsToAdd);
}

bool CreatureObjectAdapter::checkCooldownRecovery(const String& cooldown) {
	return ((CreatureObjectImplementation*) impl)->checkCooldownRecovery(cooldown);
}

void CreatureObjectAdapter::addCooldown(const String& name, unsigned int miliseconds) {
	((CreatureObjectImplementation*) impl)->addCooldown(name, miliseconds);
}

int CreatureObjectAdapter::canAddObject(SceneObject* object, int containmentType, String& errorDescription) {
	return ((CreatureObjectImplementation*) impl)->canAddObject(object, containmentType, errorDescription);
}

void CreatureObjectAdapter::doAnimation(const String& animation) {
	((CreatureObjectImplementation*) impl)->doAnimation(animation);
}

void CreatureObjectAdapter::doCombatAnimation(CreatureObject* defender, unsigned int animationCRC, byte hit) {
	((CreatureObjectImplementation*) impl)->doCombatAnimation(defender, animationCRC, hit);
}

void CreatureObjectAdapter::playEffect(const String& file, const String& aux) {
	((CreatureObjectImplementation*) impl)->playEffect(file, aux);
}

void CreatureObjectAdapter::playEffect(const String& file) {
	((CreatureObjectImplementation*) impl)->playEffect(file);
}

void CreatureObjectAdapter::showFlyText(const String& file, const String& uax, byte red, byte green, byte blue) {
	((CreatureObjectImplementation*) impl)->showFlyText(file, uax, red, green, blue);
}

void CreatureObjectAdapter::activateQueueAction() {
	((CreatureObjectImplementation*) impl)->activateQueueAction();
}

UnicodeString CreatureObjectAdapter::getCreatureName() {
	return ((CreatureObjectImplementation*) impl)->getCreatureName();
}

bool CreatureObjectAdapter::isGrouped() {
	return ((CreatureObjectImplementation*) impl)->isGrouped();
}

int CreatureObjectAdapter::getBankCredits() {
	return ((CreatureObjectImplementation*) impl)->getBankCredits();
}

int CreatureObjectAdapter::getCashCredits() {
	return ((CreatureObjectImplementation*) impl)->getCashCredits();
}

int CreatureObjectAdapter::getBaseHAM(int idx) {
	return ((CreatureObjectImplementation*) impl)->getBaseHAM(idx);
}

int CreatureObjectAdapter::getWounds(int idx) {
	return ((CreatureObjectImplementation*) impl)->getWounds(idx);
}

int CreatureObjectAdapter::getHAM(int idx) {
	return ((CreatureObjectImplementation*) impl)->getHAM(idx);
}

int CreatureObjectAdapter::getMaxHAM(int idx) {
	return ((CreatureObjectImplementation*) impl)->getMaxHAM(idx);
}

int CreatureObjectAdapter::getEncumbrance(int idx) {
	return ((CreatureObjectImplementation*) impl)->getEncumbrance(idx);
}

byte CreatureObjectAdapter::getPosture() {
	return ((CreatureObjectImplementation*) impl)->getPosture();
}

byte CreatureObjectAdapter::getFactionRank() {
	return ((CreatureObjectImplementation*) impl)->getFactionRank();
}

CreatureObject* CreatureObjectAdapter::getLinkedCreature() {
	return ((CreatureObjectImplementation*) impl)->getLinkedCreature();
}

unsigned long long CreatureObjectAdapter::getCreatureLinkID() {
	return ((CreatureObjectImplementation*) impl)->getCreatureLinkID();
}

float CreatureObjectAdapter::getShockWounds() {
	return ((CreatureObjectImplementation*) impl)->getShockWounds();
}

unsigned long long CreatureObjectAdapter::getWatchToID() {
	return ((CreatureObjectImplementation*) impl)->getWatchToID();
}

unsigned long long CreatureObjectAdapter::getStateBitmask() {
	return ((CreatureObjectImplementation*) impl)->getStateBitmask();
}

bool CreatureObjectAdapter::hasState(unsigned long long state) {
	return ((CreatureObjectImplementation*) impl)->hasState(state);
}

bool CreatureObjectAdapter::hasStates() {
	return ((CreatureObjectImplementation*) impl)->hasStates();
}

unsigned long long CreatureObjectAdapter::getListenID() {
	return ((CreatureObjectImplementation*) impl)->getListenID();
}

float CreatureObjectAdapter::getAccelerationMultiplierBase() {
	return ((CreatureObjectImplementation*) impl)->getAccelerationMultiplierBase();
}

float CreatureObjectAdapter::getAccelerationMultiplierMod() {
	return ((CreatureObjectImplementation*) impl)->getAccelerationMultiplierMod();
}

float CreatureObjectAdapter::getSpeedMultiplierBase() {
	return ((CreatureObjectImplementation*) impl)->getSpeedMultiplierBase();
}

float CreatureObjectAdapter::getSpeedMultiplierMod() {
	return ((CreatureObjectImplementation*) impl)->getSpeedMultiplierMod();
}

float CreatureObjectAdapter::getRunSpeed() {
	return ((CreatureObjectImplementation*) impl)->getRunSpeed();
}

float CreatureObjectAdapter::getWalkSpeed() {
	return ((CreatureObjectImplementation*) impl)->getWalkSpeed();
}

float CreatureObjectAdapter::getTerrainNegotiation() {
	return ((CreatureObjectImplementation*) impl)->getTerrainNegotiation();
}

float CreatureObjectAdapter::getRunAcceleration() {
	return ((CreatureObjectImplementation*) impl)->getRunAcceleration();
}

float CreatureObjectAdapter::getWalkAcceleration() {
	return ((CreatureObjectImplementation*) impl)->getWalkAcceleration();
}

String CreatureObjectAdapter::getPerformanceAnimation() {
	return ((CreatureObjectImplementation*) impl)->getPerformanceAnimation();
}

String CreatureObjectAdapter::getMoodString() {
	return ((CreatureObjectImplementation*) impl)->getMoodString();
}

unsigned long long CreatureObjectAdapter::getWeaponID() {
	return ((CreatureObjectImplementation*) impl)->getWeaponID();
}

WeaponObject* CreatureObjectAdapter::getWeapon() {
	return ((CreatureObjectImplementation*) impl)->getWeapon();
}

GuildObject* CreatureObjectAdapter::getGuildObject() {
	return ((CreatureObjectImplementation*) impl)->getGuildObject();
}

int CreatureObjectAdapter::getGuildID() {
	return ((CreatureObjectImplementation*) impl)->getGuildID();
}

bool CreatureObjectAdapter::isInGuild() {
	return ((CreatureObjectImplementation*) impl)->isInGuild();
}

void CreatureObjectAdapter::setGuildObject(GuildObject* guildobj) {
	((CreatureObjectImplementation*) impl)->setGuildObject(guildobj);
}

unsigned long long CreatureObjectAdapter::getGroupID() {
	return ((CreatureObjectImplementation*) impl)->getGroupID();
}

unsigned long long CreatureObjectAdapter::getGroupInviterID() {
	return ((CreatureObjectImplementation*) impl)->getGroupInviterID();
}

GroupObject* CreatureObjectAdapter::getGroup() {
	return ((CreatureObjectImplementation*) impl)->getGroup();
}

unsigned long long CreatureObjectAdapter::getGroupInviteCounter() {
	return ((CreatureObjectImplementation*) impl)->getGroupInviteCounter();
}

unsigned long long CreatureObjectAdapter::getTargetID() {
	return ((CreatureObjectImplementation*) impl)->getTargetID();
}

byte CreatureObjectAdapter::getMoodID() {
	return ((CreatureObjectImplementation*) impl)->getMoodID();
}

float CreatureObjectAdapter::getSlopeModPercent() {
	return ((CreatureObjectImplementation*) impl)->getSlopeModPercent();
}

int CreatureObjectAdapter::getPerformanceCounter() {
	return ((CreatureObjectImplementation*) impl)->getPerformanceCounter();
}

int CreatureObjectAdapter::getInstrumentID() {
	return ((CreatureObjectImplementation*) impl)->getInstrumentID();
}

byte CreatureObjectAdapter::getFrozen() {
	return ((CreatureObjectImplementation*) impl)->getFrozen();
}

float CreatureObjectAdapter::getHeight() {
	return ((CreatureObjectImplementation*) impl)->getHeight();
}

int CreatureObjectAdapter::getSpecies() {
	return ((CreatureObjectImplementation*) impl)->getSpecies();
}

String CreatureObjectAdapter::getSpeciesName() {
	return ((CreatureObjectImplementation*) impl)->getSpeciesName();
}

int CreatureObjectAdapter::getGender() {
	return ((CreatureObjectImplementation*) impl)->getGender();
}

long long CreatureObjectAdapter::getSkillMod(const String& skillmod) {
	return ((CreatureObjectImplementation*) impl)->getSkillMod(skillmod);
}

bool CreatureObjectAdapter::hasSkillBox(const String& skillBox) {
	return ((CreatureObjectImplementation*) impl)->hasSkillBox(skillBox);
}

void CreatureObjectAdapter::setHeight(float heigh) {
	((CreatureObjectImplementation*) impl)->setHeight(heigh);
}

void CreatureObjectAdapter::setWatchToID(unsigned long long id) {
	((CreatureObjectImplementation*) impl)->setWatchToID(id);
}

bool CreatureObjectAdapter::isCreatureObject() {
	return ((CreatureObjectImplementation*) impl)->isCreatureObject();
}

bool CreatureObjectAdapter::isTrainerCreature() {
	return ((CreatureObjectImplementation*) impl)->isTrainerCreature();
}

bool CreatureObjectAdapter::isSwimming() {
	return ((CreatureObjectImplementation*) impl)->isSwimming();
}

bool CreatureObjectAdapter::isRidingMount() {
	return ((CreatureObjectImplementation*) impl)->isRidingMount();
}

ControlDevice* CreatureObjectAdapter::getControlDevice() {
	return ((CreatureObjectImplementation*) impl)->getControlDevice();
}

float CreatureObjectAdapter::getSwimHeight() {
	return ((CreatureObjectImplementation*) impl)->getSwimHeight();
}

bool CreatureObjectAdapter::isIncapacitated() {
	return ((CreatureObjectImplementation*) impl)->isIncapacitated();
}

bool CreatureObjectAdapter::isDead() {
	return ((CreatureObjectImplementation*) impl)->isDead();
}

bool CreatureObjectAdapter::isKnockedDown() {
	return ((CreatureObjectImplementation*) impl)->isKnockedDown();
}

bool CreatureObjectAdapter::isKneeling() {
	return ((CreatureObjectImplementation*) impl)->isKneeling();
}

bool CreatureObjectAdapter::isProne() {
	return ((CreatureObjectImplementation*) impl)->isProne();
}

bool CreatureObjectAdapter::isStanding() {
	return ((CreatureObjectImplementation*) impl)->isStanding();
}

bool CreatureObjectAdapter::isSitting() {
	return ((CreatureObjectImplementation*) impl)->isSitting();
}

bool CreatureObjectAdapter::isSkillAnimating() {
	return ((CreatureObjectImplementation*) impl)->isSkillAnimating();
}

bool CreatureObjectAdapter::isRallied() {
	return ((CreatureObjectImplementation*) impl)->isRallied();
}

bool CreatureObjectAdapter::isInCombat() {
	return ((CreatureObjectImplementation*) impl)->isInCombat();
}

bool CreatureObjectAdapter::isDizzied() {
	return ((CreatureObjectImplementation*) impl)->isDizzied();
}

bool CreatureObjectAdapter::isBerserked() {
	return ((CreatureObjectImplementation*) impl)->isBerserked();
}

bool CreatureObjectAdapter::isStunned() {
	return ((CreatureObjectImplementation*) impl)->isStunned();
}

bool CreatureObjectAdapter::isBlinded() {
	return ((CreatureObjectImplementation*) impl)->isBlinded();
}

bool CreatureObjectAdapter::isIntimidated() {
	return ((CreatureObjectImplementation*) impl)->isIntimidated();
}

bool CreatureObjectAdapter::isSnared() {
	return ((CreatureObjectImplementation*) impl)->isSnared();
}

bool CreatureObjectAdapter::isRooted() {
	return ((CreatureObjectImplementation*) impl)->isRooted();
}

bool CreatureObjectAdapter::isDiseased() {
	return ((CreatureObjectImplementation*) impl)->isDiseased();
}

bool CreatureObjectAdapter::isPoisoned() {
	return ((CreatureObjectImplementation*) impl)->isPoisoned();
}

bool CreatureObjectAdapter::isBleeding() {
	return ((CreatureObjectImplementation*) impl)->isBleeding();
}

bool CreatureObjectAdapter::isOnFire() {
	return ((CreatureObjectImplementation*) impl)->isOnFire();
}

bool CreatureObjectAdapter::isMounted() {
	return ((CreatureObjectImplementation*) impl)->isMounted();
}

bool CreatureObjectAdapter::isRidingCreature() {
	return ((CreatureObjectImplementation*) impl)->isRidingCreature();
}

bool CreatureObjectAdapter::isPeaced() {
	return ((CreatureObjectImplementation*) impl)->isPeaced();
}

bool CreatureObjectAdapter::isMeditating() {
	return ((CreatureObjectImplementation*) impl)->isMeditating();
}

bool CreatureObjectAdapter::isAiming() {
	return ((CreatureObjectImplementation*) impl)->isAiming();
}

bool CreatureObjectAdapter::isInCover() {
	return ((CreatureObjectImplementation*) impl)->isInCover();
}

bool CreatureObjectAdapter::isNonPlayerCreature() {
	return ((CreatureObjectImplementation*) impl)->isNonPlayerCreature();
}

bool CreatureObjectAdapter::isCreature() {
	return ((CreatureObjectImplementation*) impl)->isCreature();
}

bool CreatureObjectAdapter::isAiAgent() {
	return ((CreatureObjectImplementation*) impl)->isAiAgent();
}

bool CreatureObjectAdapter::isInformantCreature() {
	return ((CreatureObjectImplementation*) impl)->isInformantCreature();
}

bool CreatureObjectAdapter::isVendorCreature() {
	return ((CreatureObjectImplementation*) impl)->isVendorCreature();
}

/*
 *	CreatureObjectHelper
 */

CreatureObjectHelper* CreatureObjectHelper::staticInitializer = CreatureObjectHelper::instance();

CreatureObjectHelper::CreatureObjectHelper() {
	className = "CreatureObject";

	Core::getObjectBroker()->registerClass(className, this);
}

void CreatureObjectHelper::finalizeHelper() {
	CreatureObjectHelper::finalize();
}

DistributedObject* CreatureObjectHelper::instantiateObject() {
	return new CreatureObject(DummyConstructorParameter::instance());
}

DistributedObjectServant* CreatureObjectHelper::instantiateServant() {
	return new CreatureObjectImplementation(DummyConstructorParameter::instance());
}

DistributedObjectAdapter* CreatureObjectHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new CreatureObjectAdapter((CreatureObjectImplementation*) obj->_getImplementation());

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

