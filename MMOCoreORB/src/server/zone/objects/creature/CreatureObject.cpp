/*
 *	server/zone/objects/creature/CreatureObject.cpp generated by engine3 IDL compiler 0.60
 */

#include "CreatureObject.h"

#include "server/zone/objects/scene/variables/ParameterizedStringId.h"

#include "server/zone/objects/creature/professions/SkillBox.h"

#include "server/zone/objects/group/GroupObject.h"

#include "server/zone/objects/tangible/weapon/WeaponObject.h"

#include "server/zone/managers/objectcontroller/ObjectController.h"

#include "server/zone/objects/player/PlayerCreature.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/objects/intangible/ControlDevice.h"

#include "server/zone/Zone.h"

#include "server/zone/templates/SharedObjectTemplate.h"

#include "server/zone/objects/creature/buffs/Buff.h"

#include "server/zone/objects/tangible/weapon/WeaponObject.h"

/*
 *	CreatureObjectStub
 */

CreatureObject::CreatureObject() : TangibleObject(DummyConstructorParameter::instance()) {
	_impl = new CreatureObjectImplementation();
	_impl->_setStub(this);
}

CreatureObject::CreatureObject(DummyConstructorParameter* param) : TangibleObject(param) {
}

CreatureObject::~CreatureObject() {
}


void CreatureObject::loadTemplateData(SharedObjectTemplate* templateData) {
	if (_impl == NULL) {
		throw ObjectNotLocalException(this);

	} else
		((CreatureObjectImplementation*) _impl)->loadTemplateData(templateData);
}

void CreatureObject::initializeTransientMembers() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 6);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->initializeTransientMembers();
}

void CreatureObject::clearQueueAction(unsigned int actioncntr, float timer, unsigned int tab1, unsigned int tab2) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 7);
		method.addUnsignedIntParameter(actioncntr);
		method.addFloatParameter(timer);
		method.addUnsignedIntParameter(tab1);
		method.addUnsignedIntParameter(tab2);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->clearQueueAction(actioncntr, timer, tab1, tab2);
}

void CreatureObject::sendBaselinesTo(SceneObject* player) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 8);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->sendBaselinesTo(player);
}

void CreatureObject::sendSystemMessage(const String& message) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 9);
		method.addAsciiParameter(message);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->sendSystemMessage(message);
}

void CreatureObject::sendSystemMessage(UnicodeString& message) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 10);
		method.addUnicodeParameter(message);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->sendSystemMessage(message);
}

void CreatureObject::sendSystemMessage(const String& file, const String& stringid) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 11);
		method.addAsciiParameter(file);
		method.addAsciiParameter(stringid);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->sendSystemMessage(file, stringid);
}

void CreatureObject::sendSystemMessage(ParameterizedStringId& stringid) {
	if (_impl == NULL) {
		throw ObjectNotLocalException(this);

	} else
		((CreatureObjectImplementation*) _impl)->sendSystemMessage(stringid);
}

void CreatureObject::sendSlottedObjectsTo(SceneObject* player) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 12);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->sendSlottedObjectsTo(player);
}

void CreatureObject::setCombatState() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 13);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setCombatState();
}

void CreatureObject::clearCombatState(bool clearDefenders) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 14);
		method.addBooleanParameter(clearDefenders);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->clearCombatState(clearDefenders);
}

void CreatureObject::setPosture(int newPosture, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 15);
		method.addSignedIntParameter(newPosture);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setPosture(newPosture, notifyClient);
}

void CreatureObject::setRunSpeed(float newSpeed, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 16);
		method.addFloatParameter(newSpeed);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setRunSpeed(newSpeed, notifyClient);
}

void CreatureObject::setHAM(int type, int value, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 17);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setHAM(type, value, notifyClient);
}

int CreatureObject::inflictDamage(TangibleObject* attacker, int damageType, int damage, bool destroy, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 18);
		method.addObjectParameter(attacker);
		method.addSignedIntParameter(damageType);
		method.addSignedIntParameter(damage);
		method.addBooleanParameter(destroy);
		method.addBooleanParameter(notifyClient);

		return method.executeWithSignedIntReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->inflictDamage(attacker, damageType, damage, destroy, notifyClient);
}

int CreatureObject::healDamage(TangibleObject* healer, int damageType, int damage, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 19);
		method.addObjectParameter(healer);
		method.addSignedIntParameter(damageType);
		method.addSignedIntParameter(damage);
		method.addBooleanParameter(notifyClient);

		return method.executeWithSignedIntReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->healDamage(healer, damageType, damage, notifyClient);
}

void CreatureObject::setBaseHAM(int type, int value, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 20);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setBaseHAM(type, value, notifyClient);
}

void CreatureObject::setWounds(int type, int value, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 21);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setWounds(type, value, notifyClient);
}

void CreatureObject::addWounds(int type, int value, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 22);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->addWounds(type, value, notifyClient);
}

void CreatureObject::setMaxHAM(int type, int value, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 23);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setMaxHAM(type, value, notifyClient);
}

void CreatureObject::addMaxHAM(int type, int value, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 24);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->addMaxHAM(type, value, notifyClient);
}

void CreatureObject::setEncumbrance(int type, int value, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 25);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setEncumbrance(type, value, notifyClient);
}

void CreatureObject::addEncumbrance(int type, int value, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 26);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->addEncumbrance(type, value, notifyClient);
}

void CreatureObject::setWeapon(WeaponObject* weao, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 27);
		method.addObjectParameter(weao);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setWeapon(weao, notifyClient);
}

int CreatureObject::notifyObjectInserted(SceneObject* object) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 28);
		method.addObjectParameter(object);

		return method.executeWithSignedIntReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->notifyObjectInserted(object);
}

void CreatureObject::setInstrumentID(int instrumentid, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 29);
		method.addSignedIntParameter(instrumentid);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setInstrumentID(instrumentid, notifyClient);
}

void CreatureObject::setShockWounds(int newShock, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 30);
		method.addSignedIntParameter(newShock);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setShockWounds(newShock, notifyClient);
}

void CreatureObject::addShockWounds(int shockToAdd, bool notiyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 31);
		method.addSignedIntParameter(shockToAdd);
		method.addBooleanParameter(notiyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->addShockWounds(shockToAdd, notiyClient);
}

void CreatureObject::setTargetID(unsigned long long targetID, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 32);
		method.addUnsignedLongParameter(targetID);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setTargetID(targetID, notifyClient);
}

void CreatureObject::setBankCredits(int credits, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 33);
		method.addSignedIntParameter(credits);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setBankCredits(credits, notifyClient);
}

void CreatureObject::addBuff(Buff* buff) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 34);
		method.addObjectParameter(buff);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->addBuff(buff);
}

void CreatureObject::removeBuff(unsigned int buffcrc) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 35);
		method.addUnsignedIntParameter(buffcrc);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->removeBuff(buffcrc);
}

void CreatureObject::removeBuff(Buff* buff) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 36);
		method.addObjectParameter(buff);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->removeBuff(buff);
}

void CreatureObject::clearBuffs(bool updateclient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 37);
		method.addBooleanParameter(updateclient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->clearBuffs(updateclient);
}

int CreatureObject::addDotState(unsigned long long dotType, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 38);
		method.addUnsignedLongParameter(dotType);
		method.addUnsignedIntParameter(strength);
		method.addByteParameter(type);
		method.addUnsignedIntParameter(duration);
		method.addFloatParameter(potency);
		method.addUnsignedIntParameter(defense);

		return method.executeWithSignedIntReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->addDotState(dotType, strength, type, duration, potency, defense);
}

bool CreatureObject::healDot(unsigned long long dotType, int reduction) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 39);
		method.addUnsignedLongParameter(dotType);
		method.addSignedIntParameter(reduction);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->healDot(dotType, reduction);
}

bool CreatureObject::hasBuff(unsigned int buffcrc) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 40);
		method.addUnsignedIntParameter(buffcrc);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->hasBuff(buffcrc);
}

void CreatureObject::notifySelfPositionUpdate() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 41);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->notifySelfPositionUpdate();
}

void CreatureObject::notifyPostureChange(int newPosture) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 42);
		method.addSignedIntParameter(newPosture);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->notifyPostureChange(newPosture);
}

void CreatureObject::updateToDatabaseAllObjects(bool startTask) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 43);
		method.addBooleanParameter(startTask);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->updateToDatabaseAllObjects(startTask);
}

void CreatureObject::addBankCredits(int credits, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 44);
		method.addSignedIntParameter(credits);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->addBankCredits(credits, notifyClient);
}

void CreatureObject::addCashCredits(int credits, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 45);
		method.addSignedIntParameter(credits);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->addCashCredits(credits, notifyClient);
}

void CreatureObject::substractBankCredits(int credits) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 46);
		method.addSignedIntParameter(credits);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->substractBankCredits(credits);
}

void CreatureObject::substractCashCredits(int credits) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 47);
		method.addSignedIntParameter(credits);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->substractCashCredits(credits);
}

bool CreatureObject::verifyCashCredits(int credits) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 48);
		method.addSignedIntParameter(credits);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->verifyCashCredits(credits);
}

bool CreatureObject::verifyBankCredits(int credits) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 49);
		method.addSignedIntParameter(credits);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->verifyBankCredits(credits);
}

void CreatureObject::setCashCredits(int credits, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 50);
		method.addSignedIntParameter(credits);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setCashCredits(credits, notifyClient);
}

void CreatureObject::addSkillBox(SkillBox* skillBox, bool notifyClient) {
	if (_impl == NULL) {
		throw ObjectNotLocalException(this);

	} else
		((CreatureObjectImplementation*) _impl)->addSkillBox(skillBox, notifyClient);
}

void CreatureObject::addSkillBox(const String& skillBox, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 51);
		method.addAsciiParameter(skillBox);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->addSkillBox(skillBox, notifyClient);
}

void CreatureObject::removeSkillBox(SkillBox* skillBox, bool notifyClient) {
	if (_impl == NULL) {
		throw ObjectNotLocalException(this);

	} else
		((CreatureObjectImplementation*) _impl)->removeSkillBox(skillBox, notifyClient);
}

void CreatureObject::removeSkillBox(const String& skillBox, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 52);
		method.addAsciiParameter(skillBox);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->removeSkillBox(skillBox, notifyClient);
}

void CreatureObject::addSkillMod(const String& skillMod, long long value, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 53);
		method.addAsciiParameter(skillMod);
		method.addSignedLongParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->addSkillMod(skillMod, value, notifyClient);
}

void CreatureObject::removeSkillMod(const String& skillMod, bool notifyCLient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 54);
		method.addAsciiParameter(skillMod);
		method.addBooleanParameter(notifyCLient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->removeSkillMod(skillMod, notifyCLient);
}

void CreatureObject::updateGroupInviterID(unsigned long long id, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 55);
		method.addUnsignedLongParameter(id);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->updateGroupInviterID(id, notifyClient);
}

void CreatureObject::updateGroup(GroupObject* group, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 56);
		method.addObjectParameter(group);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->updateGroup(group, notifyClient);
}

void CreatureObject::enqueueCommand(unsigned int actionCRC, unsigned int actionCount, unsigned long long targetID, const UnicodeString& arguments) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 57);
		method.addUnsignedIntParameter(actionCRC);
		method.addUnsignedIntParameter(actionCount);
		method.addUnsignedLongParameter(targetID);
		method.addUnicodeParameter(arguments);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->enqueueCommand(actionCRC, actionCount, targetID, arguments);
}

void CreatureObject::setMood(byte moodID, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 58);
		method.addByteParameter(moodID);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setMood(moodID, notifyClient);
}

void CreatureObject::setMoodString(const String& animation, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 59);
		method.addAsciiParameter(animation);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setMoodString(animation, notifyClient);
}

void CreatureObject::deleteQueueAction(unsigned int actionCount) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 60);
		method.addUnsignedIntParameter(actionCount);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->deleteQueueAction(actionCount);
}

bool CreatureObject::setState(unsigned long long state, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 61);
		method.addUnsignedLongParameter(state);
		method.addBooleanParameter(notifyClient);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->setState(state, notifyClient);
}

void CreatureObject::clearState(unsigned long long state, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 62);
		method.addUnsignedLongParameter(state);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->clearState(state, notifyClient);
}

void CreatureObject::setControlDevice(ControlDevice* device) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 63);
		method.addObjectParameter(device);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setControlDevice(device);
}

unsigned int CreatureObject::getWearableMask() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 64);

		return method.executeWithUnsignedIntReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getWearableMask();
}

void CreatureObject::setCreatureLink(CreatureObject* object, bool notifyClient) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 65);
		method.addObjectParameter(object);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setCreatureLink(object, notifyClient);
}

void CreatureObject::executeObjectControllerAction(unsigned int actionCRC) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 66);
		method.addUnsignedIntParameter(actionCRC);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->executeObjectControllerAction(actionCRC);
}

void CreatureObject::executeObjectControllerAction(unsigned int actionCRC, unsigned long long targetID, const UnicodeString& args) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 67);
		method.addUnsignedIntParameter(actionCRC);
		method.addUnsignedLongParameter(targetID);
		method.addUnicodeParameter(args);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->executeObjectControllerAction(actionCRC, targetID, args);
}

bool CreatureObject::isAttackableBy(CreatureObject* object) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 68);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isAttackableBy(object);
}

void CreatureObject::sendConversationStartTo(SceneObject* player) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 69);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->sendConversationStartTo(player);
}

void CreatureObject::selectConversationOption(int option, SceneObject* obj) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 70);
		method.addSignedIntParameter(option);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->selectConversationOption(option, obj);
}

void CreatureObject::dismount() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 71);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->dismount();
}

float CreatureObject::calculateBFRatio() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 72);

		return method.executeWithFloatReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->calculateBFRatio();
}

void CreatureObject::setDizziedState(int durationSeconds) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 73);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setDizziedState(durationSeconds);
}

void CreatureObject::setAimingState(int durationSeconds) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 74);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setAimingState(durationSeconds);
}

void CreatureObject::setCoverState() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 75);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setCoverState();
}

void CreatureObject::setBerserkedState(unsigned int duration) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 76);
		method.addUnsignedIntParameter(duration);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setBerserkedState(duration);
}

void CreatureObject::setStunnedState(int durationSeconds) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 77);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setStunnedState(durationSeconds);
}

void CreatureObject::setBlindedState(int durationSeconds) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 78);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setBlindedState(durationSeconds);
}

void CreatureObject::setIntimidatedState(int durationSeconds) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 79);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setIntimidatedState(durationSeconds);
}

void CreatureObject::setSnaredState(int durationSeconds) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 80);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setSnaredState(durationSeconds);
}

void CreatureObject::setRootedState(int durationSeconds) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 81);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setRootedState(durationSeconds);
}

bool CreatureObject::setNextAttackDelay(int del) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 82);
		method.addSignedIntParameter(del);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->setNextAttackDelay(del);
}

void CreatureObject::setMeditateState() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 83);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setMeditateState();
}

void CreatureObject::activateHAMRegeneration() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 84);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->activateHAMRegeneration();
}

void CreatureObject::activateStateRecovery() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 85);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->activateStateRecovery();
}

bool CreatureObject::hasAttackDelay() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 86);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->hasAttackDelay();
}

void CreatureObject::updateLastSuccessfulCombatAction() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 87);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->updateLastSuccessfulCombatAction();
}

void CreatureObject::updateKnockdownRecovery() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 88);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->updateKnockdownRecovery();
}

void CreatureObject::queueDizzyFallEvent() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 89);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->queueDizzyFallEvent();
}

void CreatureObject::updateLastKnockdown() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 90);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->updateLastKnockdown();
}

bool CreatureObject::checkKnockdownRecovery() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 91);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->checkKnockdownRecovery();
}

bool CreatureObject::checkLastKnockdown() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 92);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->checkLastKnockdown();
}

void CreatureObject::updatePostureDownRecovery() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 93);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->updatePostureDownRecovery();
}

void CreatureObject::updatePostureUpRecovery() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 94);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->updatePostureUpRecovery();
}

bool CreatureObject::checkPostureDownRecovery() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 95);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->checkPostureDownRecovery();
}

bool CreatureObject::checkPostureUpRecovery() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 96);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->checkPostureUpRecovery();
}

void CreatureObject::updateCooldownTimer(const String& coooldownTimer, unsigned int miliSecondsToAdd) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 97);
		method.addAsciiParameter(coooldownTimer);
		method.addUnsignedIntParameter(miliSecondsToAdd);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->updateCooldownTimer(coooldownTimer, miliSecondsToAdd);
}

bool CreatureObject::checkCooldownRecovery(const String& cooldown) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 98);
		method.addAsciiParameter(cooldown);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->checkCooldownRecovery(cooldown);
}

int CreatureObject::canAddObject(SceneObject* object, String& errorDescription) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 99);
		method.addObjectParameter(object);
		method.addAsciiParameter(errorDescription);

		return method.executeWithSignedIntReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->canAddObject(object, errorDescription);
}

void CreatureObject::doAnimation(const String& animation) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 100);
		method.addAsciiParameter(animation);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->doAnimation(animation);
}

void CreatureObject::doCombatAnimation(CreatureObject* defender, unsigned int animationCRC, byte hit) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 101);
		method.addObjectParameter(defender);
		method.addUnsignedIntParameter(animationCRC);
		method.addByteParameter(hit);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->doCombatAnimation(defender, animationCRC, hit);
}

void CreatureObject::playEffect(const String& file, const String& aux) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 102);
		method.addAsciiParameter(file);
		method.addAsciiParameter(aux);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->playEffect(file, aux);
}

void CreatureObject::playEffect(const String& file) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 103);
		method.addAsciiParameter(file);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->playEffect(file);
}

void CreatureObject::showFlyText(const String& file, const String& uax, byte red, byte green, byte blue) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 104);
		method.addAsciiParameter(file);
		method.addAsciiParameter(uax);
		method.addByteParameter(red);
		method.addByteParameter(green);
		method.addByteParameter(blue);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->showFlyText(file, uax, red, green, blue);
}

void CreatureObject::activateQueueAction() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 105);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->activateQueueAction();
}

UnicodeString CreatureObject::getCreatureName() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 106);

		method.executeWithUnicodeReturn(_return_getCreatureName);
		return _return_getCreatureName;
	} else
		return ((CreatureObjectImplementation*) _impl)->getCreatureName();
}

bool CreatureObject::isGroupped() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 107);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isGroupped();
}

int CreatureObject::getBankCredits() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 108);

		return method.executeWithSignedIntReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getBankCredits();
}

int CreatureObject::getCashCredits() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 109);

		return method.executeWithSignedIntReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getCashCredits();
}

int CreatureObject::getBaseHAM(int idx) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 110);
		method.addSignedIntParameter(idx);

		return method.executeWithSignedIntReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getBaseHAM(idx);
}

int CreatureObject::getWounds(int idx) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 111);
		method.addSignedIntParameter(idx);

		return method.executeWithSignedIntReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getWounds(idx);
}

DeltaVector<int>* CreatureObject::getWounds() {
	if (_impl == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return ((CreatureObjectImplementation*) _impl)->getWounds();
}

int CreatureObject::getHAM(int idx) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 112);
		method.addSignedIntParameter(idx);

		return method.executeWithSignedIntReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getHAM(idx);
}

DeltaVector<int>* CreatureObject::getHAM() {
	if (_impl == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return ((CreatureObjectImplementation*) _impl)->getHAM();
}

int CreatureObject::getMaxHAM(int idx) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 113);
		method.addSignedIntParameter(idx);

		return method.executeWithSignedIntReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getMaxHAM(idx);
}

DeltaVector<int>* CreatureObject::getMaxHAM() {
	if (_impl == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return ((CreatureObjectImplementation*) _impl)->getMaxHAM();
}

int CreatureObject::getEncumbrance(int idx) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 114);
		method.addSignedIntParameter(idx);

		return method.executeWithSignedIntReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getEncumbrance(idx);
}

DeltaVector<int>* CreatureObject::getEncumbrances() {
	if (_impl == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return ((CreatureObjectImplementation*) _impl)->getEncumbrances();
}

byte CreatureObject::getPosture() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 115);

		return method.executeWithByteReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getPosture();
}

byte CreatureObject::getFactionRank() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 116);

		return method.executeWithByteReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getFactionRank();
}

CreatureObject* CreatureObject::getLinkedCreature() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 117);

		return (CreatureObject*) method.executeWithObjectReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getLinkedCreature();
}

unsigned long long CreatureObject::getCreatureLinkID() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 118);

		return method.executeWithUnsignedLongReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getCreatureLinkID();
}

float CreatureObject::getShockWounds() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 119);

		return method.executeWithFloatReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getShockWounds();
}

unsigned long long CreatureObject::getStateBitmask() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 120);

		return method.executeWithUnsignedLongReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getStateBitmask();
}

bool CreatureObject::hasState(unsigned long long state) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 121);
		method.addUnsignedLongParameter(state);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->hasState(state);
}

bool CreatureObject::hasStates() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 122);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->hasStates();
}

unsigned long long CreatureObject::getListenID() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 123);

		return method.executeWithUnsignedLongReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getListenID();
}

float CreatureObject::getRunSpeed() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 124);

		return method.executeWithFloatReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getRunSpeed();
}

float CreatureObject::getWalkSpeed() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 125);

		return method.executeWithFloatReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getWalkSpeed();
}

float CreatureObject::getTerrainNegotiation() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 126);

		return method.executeWithFloatReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getTerrainNegotiation();
}

float CreatureObject::getRunAcceleration() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 127);

		return method.executeWithFloatReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getRunAcceleration();
}

float CreatureObject::getWalkAcceleration() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 128);

		return method.executeWithFloatReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getWalkAcceleration();
}

String CreatureObject::getPerformanceAnimation() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 129);

		method.executeWithAsciiReturn(_return_getPerformanceAnimation);
		return _return_getPerformanceAnimation;
	} else
		return ((CreatureObjectImplementation*) _impl)->getPerformanceAnimation();
}

String CreatureObject::getMoodString() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 130);

		method.executeWithAsciiReturn(_return_getMoodString);
		return _return_getMoodString;
	} else
		return ((CreatureObjectImplementation*) _impl)->getMoodString();
}

unsigned long long CreatureObject::getWeaponID() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 131);

		return method.executeWithUnsignedLongReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getWeaponID();
}

WeaponObject* CreatureObject::getWeapon() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 132);

		return (WeaponObject*) method.executeWithObjectReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getWeapon();
}

unsigned long long CreatureObject::getGroupID() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 133);

		return method.executeWithUnsignedLongReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getGroupID();
}

unsigned long long CreatureObject::getGroupInviterID() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 134);

		return method.executeWithUnsignedLongReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getGroupInviterID();
}

GroupObject* CreatureObject::getGroup() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 135);

		return (GroupObject*) method.executeWithObjectReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getGroup();
}

unsigned long long CreatureObject::getGroupInviteCounter() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 136);

		return method.executeWithUnsignedLongReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getGroupInviteCounter();
}

int CreatureObject::getGuildID() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 137);

		return method.executeWithSignedIntReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getGuildID();
}

unsigned long long CreatureObject::getTargetID() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 138);

		return method.executeWithUnsignedLongReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getTargetID();
}

byte CreatureObject::getMoodID() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 139);

		return method.executeWithByteReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getMoodID();
}

float CreatureObject::getSlopeModPercent() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 140);

		return method.executeWithFloatReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getSlopeModPercent();
}

int CreatureObject::getPerformanceCounter() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 141);

		return method.executeWithSignedIntReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getPerformanceCounter();
}

int CreatureObject::getInstrumentID() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 142);

		return method.executeWithSignedIntReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getInstrumentID();
}

byte CreatureObject::getFrozen() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 143);

		return method.executeWithByteReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getFrozen();
}

float CreatureObject::getHeight() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 144);

		return method.executeWithFloatReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getHeight();
}

int CreatureObject::getSpecies() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 145);

		return method.executeWithSignedIntReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getSpecies();
}

DeltaVector<int>* CreatureObject::getBaseHAM() {
	if (_impl == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return ((CreatureObjectImplementation*) _impl)->getBaseHAM();
}

SkillBoxList* CreatureObject::getSkillBoxList() {
	if (_impl == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return ((CreatureObjectImplementation*) _impl)->getSkillBoxList();
}

long long CreatureObject::getSkillMod(const String& skillmod) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 146);
		method.addAsciiParameter(skillmod);

		return method.executeWithSignedLongReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getSkillMod(skillmod);
}

bool CreatureObject::hasSkillBox(const String& skillBox) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 147);
		method.addAsciiParameter(skillBox);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->hasSkillBox(skillBox);
}

DeltaVectorMap<String, long long>* CreatureObject::getSkillModList() {
	if (_impl == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return ((CreatureObjectImplementation*) _impl)->getSkillModList();
}

void CreatureObject::setHeight(float heigh) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 148);
		method.addFloatParameter(heigh);

		method.executeWithVoidReturn();
	} else
		((CreatureObjectImplementation*) _impl)->setHeight(heigh);
}

bool CreatureObject::isCreatureObject() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 149);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isCreatureObject();
}

bool CreatureObject::isTrainerCreature() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 150);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isTrainerCreature();
}

bool CreatureObject::isSwimming() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 151);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isSwimming();
}

bool CreatureObject::isRidingMount() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 152);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isRidingMount();
}

ControlDevice* CreatureObject::getControlDevice() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 153);

		return (ControlDevice*) method.executeWithObjectReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getControlDevice();
}

float CreatureObject::getSwimHeight() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 154);

		return method.executeWithFloatReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->getSwimHeight();
}

bool CreatureObject::isIncapacitated() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 155);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isIncapacitated();
}

bool CreatureObject::isDead() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 156);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isDead();
}

bool CreatureObject::isKnockedDown() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 157);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isKnockedDown();
}

bool CreatureObject::isKneeling() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 158);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isKneeling();
}

bool CreatureObject::isProne() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 159);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isProne();
}

bool CreatureObject::isStanding() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 160);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isStanding();
}

bool CreatureObject::isSitting() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 161);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isSitting();
}

bool CreatureObject::isSkillAnimating() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 162);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isSkillAnimating();
}

bool CreatureObject::isInCombat() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 163);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isInCombat();
}

bool CreatureObject::isDizzied() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 164);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isDizzied();
}

bool CreatureObject::isBerserked() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 165);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isBerserked();
}

bool CreatureObject::isStunned() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 166);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isStunned();
}

bool CreatureObject::isBlinded() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 167);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isBlinded();
}

bool CreatureObject::isIntimidated() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 168);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isIntimidated();
}

bool CreatureObject::isSnared() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 169);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isSnared();
}

bool CreatureObject::isRooted() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 170);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isRooted();
}

bool CreatureObject::isDiseased() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 171);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isDiseased();
}

bool CreatureObject::isPoisoned() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 172);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isPoisoned();
}

bool CreatureObject::isBleeding() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 173);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isBleeding();
}

bool CreatureObject::isOnFire() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 174);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isOnFire();
}

bool CreatureObject::isMounted() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 175);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isMounted();
}

bool CreatureObject::isRidingCreature() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 176);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isRidingCreature();
}

bool CreatureObject::isPeaced() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 177);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isPeaced();
}

bool CreatureObject::isMeditating() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 178);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isMeditating();
}

bool CreatureObject::isAiming() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 179);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isAiming();
}

bool CreatureObject::isInCover() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 180);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isInCover();
}

bool CreatureObject::isShuttleCreature() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 181);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isShuttleCreature();
}

bool CreatureObject::isNonPlayerCreature() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 182);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isNonPlayerCreature();
}

bool CreatureObject::isCreature() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 183);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isCreature();
}

bool CreatureObject::isAiAgent() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 184);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureObjectImplementation*) _impl)->isAiAgent();
}

/*
 *	CreatureObjectImplementation
 */

CreatureObjectImplementation::CreatureObjectImplementation(DummyConstructorParameter* param) : TangibleObjectImplementation(param) {
	_initializeImplementation();
}

CreatureObjectImplementation::~CreatureObjectImplementation() {
	CreatureObjectImplementation::finalize();
}


void CreatureObjectImplementation::_initializeImplementation() {
	_setClassHelper(CreatureObjectHelper::instance());

	_serializationHelperMethod();
}

void CreatureObjectImplementation::_setStub(DistributedObjectStub* stub) {
	_this = (CreatureObject*) stub;
	TangibleObjectImplementation::_setStub(stub);
}

DistributedObjectStub* CreatureObjectImplementation::_getStub() {
	return _this;
}

CreatureObjectImplementation::operator const CreatureObject*() {
	return _this;
}

void CreatureObjectImplementation::lock(bool doLock) {
	_this->lock(doLock);
}

void CreatureObjectImplementation::lock(ManagedObject* obj) {
	_this->lock(obj);
}

void CreatureObjectImplementation::rlock(bool doLock) {
	_this->rlock(doLock);
}

void CreatureObjectImplementation::wlock(bool doLock) {
	_this->wlock(doLock);
}

void CreatureObjectImplementation::wlock(ManagedObject* obj) {
	_this->wlock(obj);
}

void CreatureObjectImplementation::unlock(bool doLock) {
	_this->unlock(doLock);
}

void CreatureObjectImplementation::runlock(bool doLock) {
	_this->runlock(doLock);
}

void CreatureObjectImplementation::_serializationHelperMethod() {
	TangibleObjectImplementation::_serializationHelperMethod();

	_setClassName("CreatureObject");

	addSerializableVariable("bankCredits", &bankCredits);
	addSerializableVariable("cashCredits", &cashCredits);
	addSerializableVariable("gender", &gender);
	addSerializableVariable("species", &species);
	addSerializableVariable("baseHAM", &baseHAM);
	addSerializableVariable("posture", &posture);
	addSerializableVariable("factionRank", &factionRank);
	addSerializableVariable("linkedCreature", &linkedCreature);
	addSerializableVariable("controlDevice", &controlDevice);
	addSerializableVariable("shockWounds", &shockWounds);
	addSerializableVariable("wounds", &wounds);
	addSerializableVariable("stateBitmask", &stateBitmask);
	addSerializableVariable("encumbrances", &encumbrances);
	addSerializableVariable("runSpeed", &runSpeed);
	addSerializableVariable("walkSpeed", &walkSpeed);
	addSerializableVariable("terrainNegotiation", &terrainNegotiation);
	addSerializableVariable("runAcceleration", &runAcceleration);
	addSerializableVariable("walkAcceleration", &walkAcceleration);
	addSerializableVariable("height", &height);
	addSerializableVariable("swimHeight", &swimHeight);
	addSerializableVariable("slopeModPercent", &slopeModPercent);
	addSerializableVariable("slopeModAngle", &slopeModAngle);
	addSerializableVariable("listenToID", &listenToID);
	addSerializableVariable("performanceAnimation", &performanceAnimation);
	addSerializableVariable("moodString", &moodString);
	addSerializableVariable("weapon", &weapon);
	addSerializableVariable("group", &group);
	addSerializableVariable("groupInviterID", &groupInviterID);
	addSerializableVariable("groupInviteCounter", &groupInviteCounter);
	addSerializableVariable("guildID", &guildID);
	addSerializableVariable("targetID", &targetID);
	addSerializableVariable("moodID", &moodID);
	addSerializableVariable("performanceCounter", &performanceCounter);
	addSerializableVariable("instrumentID", &instrumentID);
	addSerializableVariable("hamList", &hamList);
	addSerializableVariable("maxHamList", &maxHamList);
	addSerializableVariable("frozen", &frozen);
	addSerializableVariable("templateString", &templateString);
	addSerializableVariable("skillBoxList", &skillBoxList);
	addSerializableVariable("skillModList", &skillModList);
	addSerializableVariable("commandQueue", &commandQueue);
	addSerializableVariable("nextAction", &nextAction);
	addSerializableVariable("cooldownTimerMap", &cooldownTimerMap);
	addSerializableVariable("creatureBuffs", &creatureBuffs);
	addSerializableVariable("damageOverTimeList", &damageOverTimeList);
	addSerializableVariable("lastSuccessfulCombatAction", &lastSuccessfulCombatAction);
}

CreatureObjectImplementation::CreatureObjectImplementation() {
	_initializeImplementation();
	// server/zone/objects/creature/CreatureObject.idl(191):  		Logger.setLoggingName("CreatureObject");
	Logger::setLoggingName("CreatureObject");
	// server/zone/objects/creature/CreatureObject.idl(193):  		linkedCreature = null;
	linkedCreature = NULL;
	// server/zone/objects/creature/CreatureObject.idl(194):  		controlDevice = null;
	controlDevice = NULL;
	// server/zone/objects/creature/CreatureObject.idl(196):  		skillModList.setNullValue(0);
	(&skillModList)->setNullValue(0);
}

void CreatureObjectImplementation::addShockWounds(int shockToAdd, bool notiyClient) {
	// server/zone/objects/creature/CreatureObject.idl(412):  		shockWounds = shockWounds + shockToAdd;
	shockWounds = shockWounds + shockToAdd;
	// server/zone/objects/creature/CreatureObject.idl(414):  
	if (shockWounds < 0)	// server/zone/objects/creature/CreatureObject.idl(415):  			shockWounds = 0;
	shockWounds = 0;

	else 	// server/zone/objects/creature/CreatureObject.idl(416):  	}
	if (shockWounds > 1000)	// server/zone/objects/creature/CreatureObject.idl(417):  			shockWounds = 1000;
	shockWounds = 1000;
}

int CreatureObjectImplementation::addDotState(unsigned long long dotType, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense) {
	// server/zone/objects/creature/CreatureObject.idl(463):  		return damageOverTimeList.addDot(this, duration, dotType, type, strength, potency, defense);
	return (&damageOverTimeList)->addDot(_this, duration, dotType, type, strength, potency, defense);
}

bool CreatureObjectImplementation::healDot(unsigned long long dotType, int reduction) {
	// server/zone/objects/creature/CreatureObject.idl(467):  		return damageOverTimeList.healState(this, dotType, reduction);
	return (&damageOverTimeList)->healState(_this, dotType, reduction);
}

bool CreatureObjectImplementation::hasBuff(unsigned int buffcrc) {
	// server/zone/objects/creature/CreatureObject.idl(471):  		return creatureBuffs.hasBuff(buffcrc);
	return (&creatureBuffs)->hasBuff(buffcrc);
}

void CreatureObjectImplementation::addBankCredits(int credits, bool notifyClient) {
	// server/zone/objects/creature/CreatureObject.idl(480):  		int newCredits = bankCredits + credits;
	int newCredits = bankCredits + credits;
	// server/zone/objects/creature/CreatureObject.idl(481):  		setBankCredits(newCredits);
	setBankCredits(newCredits);
}

void CreatureObjectImplementation::addCashCredits(int credits, bool notifyClient) {
	// server/zone/objects/creature/CreatureObject.idl(485):  		int newCredits = cashCredits + credits;
	int newCredits = cashCredits + credits;
	// server/zone/objects/creature/CreatureObject.idl(486):  		setCashCredits(newCredits);
	setCashCredits(newCredits);
}

void CreatureObjectImplementation::substractBankCredits(int credits) {
	// server/zone/objects/creature/CreatureObject.idl(490):  		int newCredits = bankCredits - credits;
	int newCredits = bankCredits - credits;
	// server/zone/objects/creature/CreatureObject.idl(491):  		setBankCredits(newCredits);
	setBankCredits(newCredits);
}

void CreatureObjectImplementation::substractCashCredits(int credits) {
	// server/zone/objects/creature/CreatureObject.idl(495):  		int newCredits = cashCredits - credits;
	int newCredits = cashCredits - credits;
	// server/zone/objects/creature/CreatureObject.idl(496):  		setCashCredits(newCredits);
	setCashCredits(newCredits);
}

bool CreatureObjectImplementation::verifyCashCredits(int credits) {
	// server/zone/objects/creature/CreatureObject.idl(500):  		if 
	if (credits < 0)	// server/zone/objects/creature/CreatureObject.idl(501):  			return false;
	return false;
	// server/zone/objects/creature/CreatureObject.idl(503):  		return 
	if (cashCredits < credits)	// server/zone/objects/creature/CreatureObject.idl(504):  			return false;
	return false;
	// server/zone/objects/creature/CreatureObject.idl(506):  true;
	return true;
}

bool CreatureObjectImplementation::verifyBankCredits(int credits) {
	// server/zone/objects/creature/CreatureObject.idl(510):  		if 
	if (credits < 0)	// server/zone/objects/creature/CreatureObject.idl(511):  			return false;
	return false;
	// server/zone/objects/creature/CreatureObject.idl(513):  		return 
	if (bankCredits < credits)	// server/zone/objects/creature/CreatureObject.idl(514):  			return false;
	return false;
	// server/zone/objects/creature/CreatureObject.idl(516):  true;
	return true;
}

void CreatureObjectImplementation::setControlDevice(ControlDevice* device) {
	// server/zone/objects/creature/CreatureObject.idl(655):  		controlDevice = device;
	controlDevice = device;
}

bool CreatureObjectImplementation::isAttackableBy(CreatureObject* object) {
	// server/zone/objects/creature/CreatureObject.idl(686):  		return false;
	return false;
}

void CreatureObjectImplementation::sendConversationStartTo(SceneObject* player) {
}

void CreatureObjectImplementation::selectConversationOption(int option, SceneObject* obj) {
}

bool CreatureObjectImplementation::hasAttackDelay() {
	// server/zone/objects/creature/CreatureObject.idl(736):  		return !cooldownTimerMap.isPast("nextAttackDelay");
	return !(&cooldownTimerMap)->isPast("nextAttackDelay");
}

void CreatureObjectImplementation::updateLastSuccessfulCombatAction() {
	// server/zone/objects/creature/CreatureObject.idl(740):  		lastSuccessfulCombatAction.updateToCurrentTime();
	(&lastSuccessfulCombatAction)->updateToCurrentTime();
}

void CreatureObjectImplementation::updateKnockdownRecovery() {
	// server/zone/objects/creature/CreatureObject.idl(744):  		cooldownTimerMap.updateToCurrentAndAddMili("knockdownRecovery", 30000);
	(&cooldownTimerMap)->updateToCurrentAndAddMili("knockdownRecovery", 30000);
}

void CreatureObjectImplementation::updateLastKnockdown() {
	// server/zone/objects/creature/CreatureObject.idl(751):  		cooldownTimerMap.updateToCurrentAndAddMili("lastKnockdown", 60000);
	(&cooldownTimerMap)->updateToCurrentAndAddMili("lastKnockdown", 60000);
}

bool CreatureObjectImplementation::checkKnockdownRecovery() {
	// server/zone/objects/creature/CreatureObject.idl(755):  		return cooldownTimerMap.isPast("knockdownRecovery");
	return (&cooldownTimerMap)->isPast("knockdownRecovery");
}

bool CreatureObjectImplementation::checkLastKnockdown() {
	// server/zone/objects/creature/CreatureObject.idl(759):  		return cooldownTimerMap.isPast("lastKnockdown");
	return (&cooldownTimerMap)->isPast("lastKnockdown");
}

void CreatureObjectImplementation::updatePostureDownRecovery() {
	// server/zone/objects/creature/CreatureObject.idl(763):  		cooldownTimerMap.updateToCurrentAndAddMili("postureDownRecovery", 30000);
	(&cooldownTimerMap)->updateToCurrentAndAddMili("postureDownRecovery", 30000);
}

void CreatureObjectImplementation::updatePostureUpRecovery() {
	// server/zone/objects/creature/CreatureObject.idl(767):  		cooldownTimerMap.updateToCurrentAndAddMili("postureUpRecovery", 30000);
	(&cooldownTimerMap)->updateToCurrentAndAddMili("postureUpRecovery", 30000);
}

bool CreatureObjectImplementation::checkPostureDownRecovery() {
	// server/zone/objects/creature/CreatureObject.idl(771):  		return cooldownTimerMap.isPast("postureDownRecovery");
	return (&cooldownTimerMap)->isPast("postureDownRecovery");
}

bool CreatureObjectImplementation::checkPostureUpRecovery() {
	// server/zone/objects/creature/CreatureObject.idl(775):  		return cooldownTimerMap.isPast("postureUpRecovery");
	return (&cooldownTimerMap)->isPast("postureUpRecovery");
}

void CreatureObjectImplementation::updateCooldownTimer(const String& coooldownTimer, unsigned int miliSecondsToAdd) {
	// server/zone/objects/creature/CreatureObject.idl(779):  
	if (miliSecondsToAdd != 0){
	// server/zone/objects/creature/CreatureObject.idl(780):  			cooldownTimerMap.updateToCurrentAndAddMili(coooldownTimer, miliSecondsToAdd);
	(&cooldownTimerMap)->updateToCurrentAndAddMili(coooldownTimer, miliSecondsToAdd);
}

	else {
	// server/zone/objects/creature/CreatureObject.idl(782):  			cooldownTimerMap.updateToCurrentTime(coooldownTimer);
	(&cooldownTimerMap)->updateToCurrentTime(coooldownTimer);
}
}

bool CreatureObjectImplementation::checkCooldownRecovery(const String& cooldown) {
	// server/zone/objects/creature/CreatureObject.idl(787):  		return cooldownTimerMap.isPast(cooldown);
	return (&cooldownTimerMap)->isPast(cooldown);
}

void CreatureObjectImplementation::playEffect(const String& file) {
	// server/zone/objects/creature/CreatureObject.idl(798):  		playEffect(file, "");
	playEffect(file, "");
}

bool CreatureObjectImplementation::isGroupped() {
	// server/zone/objects/creature/CreatureObject.idl(808):  		return group != null;
	return group != NULL;
}

int CreatureObjectImplementation::getBankCredits() {
	// server/zone/objects/creature/CreatureObject.idl(812):  		return bankCredits;
	return bankCredits;
}

int CreatureObjectImplementation::getCashCredits() {
	// server/zone/objects/creature/CreatureObject.idl(816):  		return cashCredits;
	return cashCredits;
}

int CreatureObjectImplementation::getBaseHAM(int idx) {
	// server/zone/objects/creature/CreatureObject.idl(820):  		return baseHAM.get(idx);
	return (&baseHAM)->get(idx);
}

int CreatureObjectImplementation::getWounds(int idx) {
	// server/zone/objects/creature/CreatureObject.idl(824):  		return wounds.get(idx);
	return (&wounds)->get(idx);
}

DeltaVector<int>* CreatureObjectImplementation::getWounds() {
	// server/zone/objects/creature/CreatureObject.idl(829):  		return wounds;
	return (&wounds);
}

int CreatureObjectImplementation::getHAM(int idx) {
	// server/zone/objects/creature/CreatureObject.idl(833):  		return hamList.get(idx);
	return (&hamList)->get(idx);
}

DeltaVector<int>* CreatureObjectImplementation::getHAM() {
	// server/zone/objects/creature/CreatureObject.idl(838):  		return hamList;
	return (&hamList);
}

int CreatureObjectImplementation::getMaxHAM(int idx) {
	// server/zone/objects/creature/CreatureObject.idl(842):  		return maxHamList.get(idx);
	return (&maxHamList)->get(idx);
}

DeltaVector<int>* CreatureObjectImplementation::getMaxHAM() {
	// server/zone/objects/creature/CreatureObject.idl(847):  		return maxHamList;
	return (&maxHamList);
}

int CreatureObjectImplementation::getEncumbrance(int idx) {
	// server/zone/objects/creature/CreatureObject.idl(851):  		return encumbrances.get(idx);
	return (&encumbrances)->get(idx);
}

DeltaVector<int>* CreatureObjectImplementation::getEncumbrances() {
	// server/zone/objects/creature/CreatureObject.idl(856):  		return encumbrances;
	return (&encumbrances);
}

byte CreatureObjectImplementation::getPosture() {
	// server/zone/objects/creature/CreatureObject.idl(860):  		return posture;
	return posture;
}

byte CreatureObjectImplementation::getFactionRank() {
	// server/zone/objects/creature/CreatureObject.idl(864):  		return factionRank;
	return factionRank;
}

CreatureObject* CreatureObjectImplementation::getLinkedCreature() {
	// server/zone/objects/creature/CreatureObject.idl(868):  		return linkedCreature;
	return linkedCreature;
}

unsigned long long CreatureObjectImplementation::getCreatureLinkID() {
	// server/zone/objects/creature/CreatureObject.idl(872):  
	if (linkedCreature != NULL)	// server/zone/objects/creature/CreatureObject.idl(873):  			return linkedCreature.getObjectID();
	return linkedCreature->getObjectID();

	else 	// server/zone/objects/creature/CreatureObject.idl(875):  			return 0;
	return 0;
}

float CreatureObjectImplementation::getShockWounds() {
	// server/zone/objects/creature/CreatureObject.idl(879):  		return shockWounds;
	return shockWounds;
}

unsigned long long CreatureObjectImplementation::getStateBitmask() {
	// server/zone/objects/creature/CreatureObject.idl(883):  		return stateBitmask;
	return stateBitmask;
}

bool CreatureObjectImplementation::hasState(unsigned long long state) {
	// server/zone/objects/creature/CreatureObject.idl(887):  		return stateBitmask & state;
	return stateBitmask & state;
}

bool CreatureObjectImplementation::hasStates() {
	// server/zone/objects/creature/CreatureObject.idl(891):  		return stateBitmask != 0;
	return stateBitmask != 0;
}

unsigned long long CreatureObjectImplementation::getListenID() {
	// server/zone/objects/creature/CreatureObject.idl(895):  		return listenToID;
	return listenToID;
}

float CreatureObjectImplementation::getRunSpeed() {
	// server/zone/objects/creature/CreatureObject.idl(899):  		return runSpeed;
	return runSpeed;
}

float CreatureObjectImplementation::getWalkSpeed() {
	// server/zone/objects/creature/CreatureObject.idl(903):  		return walkSpeed;
	return walkSpeed;
}

float CreatureObjectImplementation::getTerrainNegotiation() {
	// server/zone/objects/creature/CreatureObject.idl(907):  		return terrainNegotiation;
	return terrainNegotiation;
}

float CreatureObjectImplementation::getRunAcceleration() {
	// server/zone/objects/creature/CreatureObject.idl(911):  		return runAcceleration;
	return runAcceleration;
}

float CreatureObjectImplementation::getWalkAcceleration() {
	// server/zone/objects/creature/CreatureObject.idl(915):  		return walkAcceleration;
	return walkAcceleration;
}

String CreatureObjectImplementation::getPerformanceAnimation() {
	// server/zone/objects/creature/CreatureObject.idl(919):  		return performanceAnimation;
	return performanceAnimation;
}

String CreatureObjectImplementation::getMoodString() {
	// server/zone/objects/creature/CreatureObject.idl(923):  		return moodString;
	return moodString;
}

unsigned long long CreatureObjectImplementation::getWeaponID() {
	// server/zone/objects/creature/CreatureObject.idl(927):  
	if (weapon == NULL)	// server/zone/objects/creature/CreatureObject.idl(928):  			return 0;
	return 0;

	else 	// server/zone/objects/creature/CreatureObject.idl(930):  			return weapon.getObjectID();
	return weapon->getObjectID();
}

WeaponObject* CreatureObjectImplementation::getWeapon() {
	// server/zone/objects/creature/CreatureObject.idl(934):  
	if (weapon == NULL){
	// server/zone/objects/creature/CreatureObject.idl(935):  			return (WeaponObject) super.getSlottedObject("default_weapon");
	return (WeaponObject*) TangibleObjectImplementation::getSlottedObject("default_weapon");
}

	else 	// server/zone/objects/creature/CreatureObject.idl(937):  			return weapon;
	return weapon;
}

unsigned long long CreatureObjectImplementation::getGroupID() {
	// server/zone/objects/creature/CreatureObject.idl(941):  
	if (group != NULL)	// server/zone/objects/creature/CreatureObject.idl(942):  			return group.getObjectID();
	return group->getObjectID();

	else 	// server/zone/objects/creature/CreatureObject.idl(944):  			return 0;
	return 0;
}

unsigned long long CreatureObjectImplementation::getGroupInviterID() {
	// server/zone/objects/creature/CreatureObject.idl(948):  		return groupInviterID;
	return groupInviterID;
}

GroupObject* CreatureObjectImplementation::getGroup() {
	// server/zone/objects/creature/CreatureObject.idl(952):  		return group;
	return group;
}

unsigned long long CreatureObjectImplementation::getGroupInviteCounter() {
	// server/zone/objects/creature/CreatureObject.idl(956):  		return groupInviteCounter;
	return groupInviteCounter;
}

int CreatureObjectImplementation::getGuildID() {
	// server/zone/objects/creature/CreatureObject.idl(960):  		return guildID;
	return guildID;
}

unsigned long long CreatureObjectImplementation::getTargetID() {
	// server/zone/objects/creature/CreatureObject.idl(964):  		return targetID;
	return targetID;
}

byte CreatureObjectImplementation::getMoodID() {
	// server/zone/objects/creature/CreatureObject.idl(968):  		return moodID;
	return moodID;
}

float CreatureObjectImplementation::getSlopeModPercent() {
	// server/zone/objects/creature/CreatureObject.idl(972):  		return slopeModPercent;
	return slopeModPercent;
}

int CreatureObjectImplementation::getPerformanceCounter() {
	// server/zone/objects/creature/CreatureObject.idl(976):  		return performanceCounter;
	return performanceCounter;
}

int CreatureObjectImplementation::getInstrumentID() {
	// server/zone/objects/creature/CreatureObject.idl(980):  		return instrumentID;
	return instrumentID;
}

byte CreatureObjectImplementation::getFrozen() {
	// server/zone/objects/creature/CreatureObject.idl(984):  		return frozen;
	return frozen;
}

float CreatureObjectImplementation::getHeight() {
	// server/zone/objects/creature/CreatureObject.idl(988):  		return height;
	return height;
}

int CreatureObjectImplementation::getSpecies() {
	// server/zone/objects/creature/CreatureObject.idl(992):  		return species;
	return species;
}

DeltaVector<int>* CreatureObjectImplementation::getBaseHAM() {
	// server/zone/objects/creature/CreatureObject.idl(997):  		return baseHAM;
	return (&baseHAM);
}

SkillBoxList* CreatureObjectImplementation::getSkillBoxList() {
	// server/zone/objects/creature/CreatureObject.idl(1002):  		return skillBoxList;
	return (&skillBoxList);
}

long long CreatureObjectImplementation::getSkillMod(const String& skillmod) {
	// server/zone/objects/creature/CreatureObject.idl(1006):  		return skillModList.get(skillmod);
	return (&skillModList)->get(skillmod);
}

bool CreatureObjectImplementation::hasSkillBox(const String& skillBox) {
	// server/zone/objects/creature/CreatureObject.idl(1010):  		return skillBoxList.containsSkillBox(skillBox);
	return (&skillBoxList)->containsSkillBox(skillBox);
}

DeltaVectorMap<String, long long>* CreatureObjectImplementation::getSkillModList() {
	// server/zone/objects/creature/CreatureObject.idl(1015):  		return skillModList;
	return (&skillModList);
}

void CreatureObjectImplementation::setHeight(float heigh) {
	// server/zone/objects/creature/CreatureObject.idl(1019):  		height = heigh;
	height = heigh;
}

bool CreatureObjectImplementation::isCreatureObject() {
	// server/zone/objects/creature/CreatureObject.idl(1023):  		return true;
	return true;
}

bool CreatureObjectImplementation::isTrainerCreature() {
	// server/zone/objects/creature/CreatureObject.idl(1027):  		return false;
	return false;
}

bool CreatureObjectImplementation::isSwimming() {
	// server/zone/objects/creature/CreatureObject.idl(1031):  		return stateBitmask & CreatureState.SWIMMING;
	return stateBitmask & CreatureState::SWIMMING;
}

bool CreatureObjectImplementation::isRidingMount() {
	// server/zone/objects/creature/CreatureObject.idl(1035):  		return stateBitmask & CreatureState.RIDINGMOUNT;
	return stateBitmask & CreatureState::RIDINGMOUNT;
}

ControlDevice* CreatureObjectImplementation::getControlDevice() {
	// server/zone/objects/creature/CreatureObject.idl(1039):  		return controlDevice;
	return controlDevice;
}

float CreatureObjectImplementation::getSwimHeight() {
	// server/zone/objects/creature/CreatureObject.idl(1043):  		return swimHeight;
	return swimHeight;
}

bool CreatureObjectImplementation::isIncapacitated() {
	// server/zone/objects/creature/CreatureObject.idl(1047):  		return posture == CreaturePosture.INCAPACITATED;
	return posture == CreaturePosture::INCAPACITATED;
}

bool CreatureObjectImplementation::isDead() {
	// server/zone/objects/creature/CreatureObject.idl(1051):  		return posture == CreaturePosture.DEAD;
	return posture == CreaturePosture::DEAD;
}

bool CreatureObjectImplementation::isKnockedDown() {
	// server/zone/objects/creature/CreatureObject.idl(1055):  		return posture == CreaturePosture.KNOCKEDDOWN;
	return posture == CreaturePosture::KNOCKEDDOWN;
}

bool CreatureObjectImplementation::isKneeling() {
	// server/zone/objects/creature/CreatureObject.idl(1059):  		return posture == CreaturePosture.CROUCHED;
	return posture == CreaturePosture::CROUCHED;
}

bool CreatureObjectImplementation::isProne() {
	// server/zone/objects/creature/CreatureObject.idl(1063):  		return posture == CreaturePosture.PRONE;
	return posture == CreaturePosture::PRONE;
}

bool CreatureObjectImplementation::isStanding() {
	// server/zone/objects/creature/CreatureObject.idl(1067):  		return posture == CreaturePosture.UPRIGHT;
	return posture == CreaturePosture::UPRIGHT;
}

bool CreatureObjectImplementation::isSitting() {
	// server/zone/objects/creature/CreatureObject.idl(1071):  		return posture == CreaturePosture.SITTING;
	return posture == CreaturePosture::SITTING;
}

bool CreatureObjectImplementation::isSkillAnimating() {
	// server/zone/objects/creature/CreatureObject.idl(1075):  		return posture == CreaturePosture.SKILLANIMATING;
	return posture == CreaturePosture::SKILLANIMATING;
}

bool CreatureObjectImplementation::isInCombat() {
	// server/zone/objects/creature/CreatureObject.idl(1079):  		return stateBitmask & CreatureState.COMBAT;
	return stateBitmask & CreatureState::COMBAT;
}

bool CreatureObjectImplementation::isDizzied() {
	// server/zone/objects/creature/CreatureObject.idl(1083):  		return stateBitmask & CreatureState.DIZZY;
	return stateBitmask & CreatureState::DIZZY;
}

bool CreatureObjectImplementation::isBerserked() {
	// server/zone/objects/creature/CreatureObject.idl(1087):  		return stateBitmask & CreatureState.BERSERK;
	return stateBitmask & CreatureState::BERSERK;
}

bool CreatureObjectImplementation::isStunned() {
	// server/zone/objects/creature/CreatureObject.idl(1091):  		return stateBitmask & CreatureState.STUNNED;
	return stateBitmask & CreatureState::STUNNED;
}

bool CreatureObjectImplementation::isBlinded() {
	// server/zone/objects/creature/CreatureObject.idl(1095):  		return stateBitmask & CreatureState.BLINDED;
	return stateBitmask & CreatureState::BLINDED;
}

bool CreatureObjectImplementation::isIntimidated() {
	// server/zone/objects/creature/CreatureObject.idl(1099):  		return stateBitmask & CreatureState.INTIMIDATED;
	return stateBitmask & CreatureState::INTIMIDATED;
}

bool CreatureObjectImplementation::isSnared() {
	// server/zone/objects/creature/CreatureObject.idl(1103):  		return stateBitmask & CreatureState.SNARED;
	return stateBitmask & CreatureState::SNARED;
}

bool CreatureObjectImplementation::isRooted() {
	// server/zone/objects/creature/CreatureObject.idl(1107):  		return stateBitmask & CreatureState.ROOTED;
	return stateBitmask & CreatureState::ROOTED;
}

bool CreatureObjectImplementation::isDiseased() {
	// server/zone/objects/creature/CreatureObject.idl(1111):  		return stateBitmask & CreatureState.DISEASED;
	return stateBitmask & CreatureState::DISEASED;
}

bool CreatureObjectImplementation::isPoisoned() {
	// server/zone/objects/creature/CreatureObject.idl(1115):  		return stateBitmask & CreatureState.POISONED;
	return stateBitmask & CreatureState::POISONED;
}

bool CreatureObjectImplementation::isBleeding() {
	// server/zone/objects/creature/CreatureObject.idl(1119):  		return stateBitmask & CreatureState.BLEEDING;
	return stateBitmask & CreatureState::BLEEDING;
}

bool CreatureObjectImplementation::isOnFire() {
	// server/zone/objects/creature/CreatureObject.idl(1123):  		return stateBitmask & CreatureState.ONFIRE;
	return stateBitmask & CreatureState::ONFIRE;
}

bool CreatureObjectImplementation::isMounted() {
	// server/zone/objects/creature/CreatureObject.idl(1127):  		return stateBitmask & CreatureState.RIDINGMOUNT;
	return stateBitmask & CreatureState::RIDINGMOUNT;
}

bool CreatureObjectImplementation::isRidingCreature() {
	// server/zone/objects/creature/CreatureObject.idl(1131):  		return stateBitmask & CreatureState.MOUNTEDCREATURE;
	return stateBitmask & CreatureState::MOUNTEDCREATURE;
}

bool CreatureObjectImplementation::isPeaced() {
	// server/zone/objects/creature/CreatureObject.idl(1135):  		return stateBitmask & CreatureState.PEACE;
	return stateBitmask & CreatureState::PEACE;
}

bool CreatureObjectImplementation::isMeditating() {
	// server/zone/objects/creature/CreatureObject.idl(1139):  		return stateBitmask & CreatureState.ALERT;
	return stateBitmask & CreatureState::ALERT;
}

bool CreatureObjectImplementation::isAiming() {
	// server/zone/objects/creature/CreatureObject.idl(1143):  		return stateBitmask & CreatureState.AIMING;
	return stateBitmask & CreatureState::AIMING;
}

bool CreatureObjectImplementation::isInCover() {
	// server/zone/objects/creature/CreatureObject.idl(1147):  		return stateBitmask & CreatureState.COVER;
	return stateBitmask & CreatureState::COVER;
}

bool CreatureObjectImplementation::isShuttleCreature() {
	// server/zone/objects/creature/CreatureObject.idl(1151):  		return false;
	return false;
}

bool CreatureObjectImplementation::isNonPlayerCreature() {
	// server/zone/objects/creature/CreatureObject.idl(1155):  		return false;
	return false;
}

bool CreatureObjectImplementation::isCreature() {
	// server/zone/objects/creature/CreatureObject.idl(1159):  		return false;
	return false;
}

bool CreatureObjectImplementation::isAiAgent() {
	// server/zone/objects/creature/CreatureObject.idl(1163):  		return false;
	return false;
}

/*
 *	CreatureObjectAdapter
 */

CreatureObjectAdapter::CreatureObjectAdapter(CreatureObjectImplementation* obj) : TangibleObjectAdapter(obj) {
}

Packet* CreatureObjectAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	Packet* resp = new MethodReturnMessage(0);

	switch (methid) {
	case 6:
		finalize();
		break;
	case 7:
		initializeTransientMembers();
		break;
	case 8:
		clearQueueAction(inv->getUnsignedIntParameter(), inv->getFloatParameter(), inv->getUnsignedIntParameter(), inv->getUnsignedIntParameter());
		break;
	case 9:
		sendBaselinesTo((SceneObject*) inv->getObjectParameter());
		break;
	case 10:
		sendSystemMessage(inv->getAsciiParameter(_param0_sendSystemMessage__String_));
		break;
	case 11:
		sendSystemMessage(inv->getUnicodeParameter(_param0_sendSystemMessage__UnicodeString_));
		break;
	case 12:
		sendSystemMessage(inv->getAsciiParameter(_param0_sendSystemMessage__String_String_), inv->getAsciiParameter(_param1_sendSystemMessage__String_String_));
		break;
	case 13:
		sendSlottedObjectsTo((SceneObject*) inv->getObjectParameter());
		break;
	case 14:
		setCombatState();
		break;
	case 15:
		clearCombatState(inv->getBooleanParameter());
		break;
	case 16:
		setPosture(inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case 17:
		setRunSpeed(inv->getFloatParameter(), inv->getBooleanParameter());
		break;
	case 18:
		setHAM(inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case 19:
		resp->insertSignedInt(inflictDamage((TangibleObject*) inv->getObjectParameter(), inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter(), inv->getBooleanParameter()));
		break;
	case 20:
		resp->insertSignedInt(healDamage((TangibleObject*) inv->getObjectParameter(), inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter()));
		break;
	case 21:
		setBaseHAM(inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case 22:
		setWounds(inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case 23:
		addWounds(inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case 24:
		setMaxHAM(inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case 25:
		addMaxHAM(inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case 26:
		setEncumbrance(inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case 27:
		addEncumbrance(inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case 28:
		setWeapon((WeaponObject*) inv->getObjectParameter(), inv->getBooleanParameter());
		break;
	case 29:
		resp->insertSignedInt(notifyObjectInserted((SceneObject*) inv->getObjectParameter()));
		break;
	case 30:
		setInstrumentID(inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case 31:
		setShockWounds(inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case 32:
		addShockWounds(inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case 33:
		setTargetID(inv->getUnsignedLongParameter(), inv->getBooleanParameter());
		break;
	case 34:
		setBankCredits(inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case 35:
		addBuff((Buff*) inv->getObjectParameter());
		break;
	case 36:
		removeBuff(inv->getUnsignedIntParameter());
		break;
	case 37:
		removeBuff((Buff*) inv->getObjectParameter());
		break;
	case 38:
		clearBuffs(inv->getBooleanParameter());
		break;
	case 39:
		resp->insertSignedInt(addDotState(inv->getUnsignedLongParameter(), inv->getUnsignedIntParameter(), inv->getByteParameter(), inv->getUnsignedIntParameter(), inv->getFloatParameter(), inv->getUnsignedIntParameter()));
		break;
	case 40:
		resp->insertBoolean(healDot(inv->getUnsignedLongParameter(), inv->getSignedIntParameter()));
		break;
	case 41:
		resp->insertBoolean(hasBuff(inv->getUnsignedIntParameter()));
		break;
	case 42:
		notifySelfPositionUpdate();
		break;
	case 43:
		notifyPostureChange(inv->getSignedIntParameter());
		break;
	case 44:
		updateToDatabaseAllObjects(inv->getBooleanParameter());
		break;
	case 45:
		addBankCredits(inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case 46:
		addCashCredits(inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case 47:
		substractBankCredits(inv->getSignedIntParameter());
		break;
	case 48:
		substractCashCredits(inv->getSignedIntParameter());
		break;
	case 49:
		resp->insertBoolean(verifyCashCredits(inv->getSignedIntParameter()));
		break;
	case 50:
		resp->insertBoolean(verifyBankCredits(inv->getSignedIntParameter()));
		break;
	case 51:
		setCashCredits(inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case 52:
		addSkillBox(inv->getAsciiParameter(_param0_addSkillBox__String_bool_), inv->getBooleanParameter());
		break;
	case 53:
		removeSkillBox(inv->getAsciiParameter(_param0_removeSkillBox__String_bool_), inv->getBooleanParameter());
		break;
	case 54:
		addSkillMod(inv->getAsciiParameter(_param0_addSkillMod__String_long_bool_), inv->getSignedLongParameter(), inv->getBooleanParameter());
		break;
	case 55:
		removeSkillMod(inv->getAsciiParameter(_param0_removeSkillMod__String_bool_), inv->getBooleanParameter());
		break;
	case 56:
		updateGroupInviterID(inv->getUnsignedLongParameter(), inv->getBooleanParameter());
		break;
	case 57:
		updateGroup((GroupObject*) inv->getObjectParameter(), inv->getBooleanParameter());
		break;
	case 58:
		enqueueCommand(inv->getUnsignedIntParameter(), inv->getUnsignedIntParameter(), inv->getUnsignedLongParameter(), inv->getUnicodeParameter(_param3_enqueueCommand__int_int_long_UnicodeString_));
		break;
	case 59:
		setMood(inv->getByteParameter(), inv->getBooleanParameter());
		break;
	case 60:
		setMoodString(inv->getAsciiParameter(_param0_setMoodString__String_bool_), inv->getBooleanParameter());
		break;
	case 61:
		deleteQueueAction(inv->getUnsignedIntParameter());
		break;
	case 62:
		resp->insertBoolean(setState(inv->getUnsignedLongParameter(), inv->getBooleanParameter()));
		break;
	case 63:
		clearState(inv->getUnsignedLongParameter(), inv->getBooleanParameter());
		break;
	case 64:
		setControlDevice((ControlDevice*) inv->getObjectParameter());
		break;
	case 65:
		resp->insertInt(getWearableMask());
		break;
	case 66:
		setCreatureLink((CreatureObject*) inv->getObjectParameter(), inv->getBooleanParameter());
		break;
	case 67:
		executeObjectControllerAction(inv->getUnsignedIntParameter());
		break;
	case 68:
		executeObjectControllerAction(inv->getUnsignedIntParameter(), inv->getUnsignedLongParameter(), inv->getUnicodeParameter(_param2_executeObjectControllerAction__int_long_UnicodeString_));
		break;
	case 69:
		resp->insertBoolean(isAttackableBy((CreatureObject*) inv->getObjectParameter()));
		break;
	case 70:
		sendConversationStartTo((SceneObject*) inv->getObjectParameter());
		break;
	case 71:
		selectConversationOption(inv->getSignedIntParameter(), (SceneObject*) inv->getObjectParameter());
		break;
	case 72:
		dismount();
		break;
	case 73:
		resp->insertFloat(calculateBFRatio());
		break;
	case 74:
		setDizziedState(inv->getSignedIntParameter());
		break;
	case 75:
		setAimingState(inv->getSignedIntParameter());
		break;
	case 76:
		setCoverState();
		break;
	case 77:
		setBerserkedState(inv->getUnsignedIntParameter());
		break;
	case 78:
		setStunnedState(inv->getSignedIntParameter());
		break;
	case 79:
		setBlindedState(inv->getSignedIntParameter());
		break;
	case 80:
		setIntimidatedState(inv->getSignedIntParameter());
		break;
	case 81:
		setSnaredState(inv->getSignedIntParameter());
		break;
	case 82:
		setRootedState(inv->getSignedIntParameter());
		break;
	case 83:
		resp->insertBoolean(setNextAttackDelay(inv->getSignedIntParameter()));
		break;
	case 84:
		setMeditateState();
		break;
	case 85:
		activateHAMRegeneration();
		break;
	case 86:
		activateStateRecovery();
		break;
	case 87:
		resp->insertBoolean(hasAttackDelay());
		break;
	case 88:
		updateLastSuccessfulCombatAction();
		break;
	case 89:
		updateKnockdownRecovery();
		break;
	case 90:
		queueDizzyFallEvent();
		break;
	case 91:
		updateLastKnockdown();
		break;
	case 92:
		resp->insertBoolean(checkKnockdownRecovery());
		break;
	case 93:
		resp->insertBoolean(checkLastKnockdown());
		break;
	case 94:
		updatePostureDownRecovery();
		break;
	case 95:
		updatePostureUpRecovery();
		break;
	case 96:
		resp->insertBoolean(checkPostureDownRecovery());
		break;
	case 97:
		resp->insertBoolean(checkPostureUpRecovery());
		break;
	case 98:
		updateCooldownTimer(inv->getAsciiParameter(_param0_updateCooldownTimer__String_int_), inv->getUnsignedIntParameter());
		break;
	case 99:
		resp->insertBoolean(checkCooldownRecovery(inv->getAsciiParameter(_param0_checkCooldownRecovery__String_)));
		break;
	case 100:
		resp->insertSignedInt(canAddObject((SceneObject*) inv->getObjectParameter(), inv->getAsciiParameter(_param1_canAddObject__SceneObject_String_)));
		break;
	case 101:
		doAnimation(inv->getAsciiParameter(_param0_doAnimation__String_));
		break;
	case 102:
		doCombatAnimation((CreatureObject*) inv->getObjectParameter(), inv->getUnsignedIntParameter(), inv->getByteParameter());
		break;
	case 103:
		playEffect(inv->getAsciiParameter(_param0_playEffect__String_String_), inv->getAsciiParameter(_param1_playEffect__String_String_));
		break;
	case 104:
		playEffect(inv->getAsciiParameter(_param0_playEffect__String_));
		break;
	case 105:
		showFlyText(inv->getAsciiParameter(_param0_showFlyText__String_String_byte_byte_byte_), inv->getAsciiParameter(_param1_showFlyText__String_String_byte_byte_byte_), inv->getByteParameter(), inv->getByteParameter(), inv->getByteParameter());
		break;
	case 106:
		activateQueueAction();
		break;
	case 107:
		resp->insertUnicode(getCreatureName());
		break;
	case 108:
		resp->insertBoolean(isGroupped());
		break;
	case 109:
		resp->insertSignedInt(getBankCredits());
		break;
	case 110:
		resp->insertSignedInt(getCashCredits());
		break;
	case 111:
		resp->insertSignedInt(getBaseHAM(inv->getSignedIntParameter()));
		break;
	case 112:
		resp->insertSignedInt(getWounds(inv->getSignedIntParameter()));
		break;
	case 113:
		resp->insertSignedInt(getHAM(inv->getSignedIntParameter()));
		break;
	case 114:
		resp->insertSignedInt(getMaxHAM(inv->getSignedIntParameter()));
		break;
	case 115:
		resp->insertSignedInt(getEncumbrance(inv->getSignedIntParameter()));
		break;
	case 116:
		resp->insertByte(getPosture());
		break;
	case 117:
		resp->insertByte(getFactionRank());
		break;
	case 118:
		resp->insertLong(getLinkedCreature()->_getObjectID());
		break;
	case 119:
		resp->insertLong(getCreatureLinkID());
		break;
	case 120:
		resp->insertFloat(getShockWounds());
		break;
	case 121:
		resp->insertLong(getStateBitmask());
		break;
	case 122:
		resp->insertBoolean(hasState(inv->getUnsignedLongParameter()));
		break;
	case 123:
		resp->insertBoolean(hasStates());
		break;
	case 124:
		resp->insertLong(getListenID());
		break;
	case 125:
		resp->insertFloat(getRunSpeed());
		break;
	case 126:
		resp->insertFloat(getWalkSpeed());
		break;
	case 127:
		resp->insertFloat(getTerrainNegotiation());
		break;
	case 128:
		resp->insertFloat(getRunAcceleration());
		break;
	case 129:
		resp->insertFloat(getWalkAcceleration());
		break;
	case 130:
		resp->insertAscii(getPerformanceAnimation());
		break;
	case 131:
		resp->insertAscii(getMoodString());
		break;
	case 132:
		resp->insertLong(getWeaponID());
		break;
	case 133:
		resp->insertLong(getWeapon()->_getObjectID());
		break;
	case 134:
		resp->insertLong(getGroupID());
		break;
	case 135:
		resp->insertLong(getGroupInviterID());
		break;
	case 136:
		resp->insertLong(getGroup()->_getObjectID());
		break;
	case 137:
		resp->insertLong(getGroupInviteCounter());
		break;
	case 138:
		resp->insertSignedInt(getGuildID());
		break;
	case 139:
		resp->insertLong(getTargetID());
		break;
	case 140:
		resp->insertByte(getMoodID());
		break;
	case 141:
		resp->insertFloat(getSlopeModPercent());
		break;
	case 142:
		resp->insertSignedInt(getPerformanceCounter());
		break;
	case 143:
		resp->insertSignedInt(getInstrumentID());
		break;
	case 144:
		resp->insertByte(getFrozen());
		break;
	case 145:
		resp->insertFloat(getHeight());
		break;
	case 146:
		resp->insertSignedInt(getSpecies());
		break;
	case 147:
		resp->insertSignedLong(getSkillMod(inv->getAsciiParameter(_param0_getSkillMod__String_)));
		break;
	case 148:
		resp->insertBoolean(hasSkillBox(inv->getAsciiParameter(_param0_hasSkillBox__String_)));
		break;
	case 149:
		setHeight(inv->getFloatParameter());
		break;
	case 150:
		resp->insertBoolean(isCreatureObject());
		break;
	case 151:
		resp->insertBoolean(isTrainerCreature());
		break;
	case 152:
		resp->insertBoolean(isSwimming());
		break;
	case 153:
		resp->insertBoolean(isRidingMount());
		break;
	case 154:
		resp->insertLong(getControlDevice()->_getObjectID());
		break;
	case 155:
		resp->insertFloat(getSwimHeight());
		break;
	case 156:
		resp->insertBoolean(isIncapacitated());
		break;
	case 157:
		resp->insertBoolean(isDead());
		break;
	case 158:
		resp->insertBoolean(isKnockedDown());
		break;
	case 159:
		resp->insertBoolean(isKneeling());
		break;
	case 160:
		resp->insertBoolean(isProne());
		break;
	case 161:
		resp->insertBoolean(isStanding());
		break;
	case 162:
		resp->insertBoolean(isSitting());
		break;
	case 163:
		resp->insertBoolean(isSkillAnimating());
		break;
	case 164:
		resp->insertBoolean(isInCombat());
		break;
	case 165:
		resp->insertBoolean(isDizzied());
		break;
	case 166:
		resp->insertBoolean(isBerserked());
		break;
	case 167:
		resp->insertBoolean(isStunned());
		break;
	case 168:
		resp->insertBoolean(isBlinded());
		break;
	case 169:
		resp->insertBoolean(isIntimidated());
		break;
	case 170:
		resp->insertBoolean(isSnared());
		break;
	case 171:
		resp->insertBoolean(isRooted());
		break;
	case 172:
		resp->insertBoolean(isDiseased());
		break;
	case 173:
		resp->insertBoolean(isPoisoned());
		break;
	case 174:
		resp->insertBoolean(isBleeding());
		break;
	case 175:
		resp->insertBoolean(isOnFire());
		break;
	case 176:
		resp->insertBoolean(isMounted());
		break;
	case 177:
		resp->insertBoolean(isRidingCreature());
		break;
	case 178:
		resp->insertBoolean(isPeaced());
		break;
	case 179:
		resp->insertBoolean(isMeditating());
		break;
	case 180:
		resp->insertBoolean(isAiming());
		break;
	case 181:
		resp->insertBoolean(isInCover());
		break;
	case 182:
		resp->insertBoolean(isShuttleCreature());
		break;
	case 183:
		resp->insertBoolean(isNonPlayerCreature());
		break;
	case 184:
		resp->insertBoolean(isCreature());
		break;
	case 185:
		resp->insertBoolean(isAiAgent());
		break;
	default:
		return NULL;
	}

	return resp;
}

void CreatureObjectAdapter::finalize() {
	((CreatureObjectImplementation*) impl)->finalize();
}

void CreatureObjectAdapter::initializeTransientMembers() {
	((CreatureObjectImplementation*) impl)->initializeTransientMembers();
}

void CreatureObjectAdapter::clearQueueAction(unsigned int actioncntr, float timer, unsigned int tab1, unsigned int tab2) {
	((CreatureObjectImplementation*) impl)->clearQueueAction(actioncntr, timer, tab1, tab2);
}

void CreatureObjectAdapter::sendBaselinesTo(SceneObject* player) {
	((CreatureObjectImplementation*) impl)->sendBaselinesTo(player);
}

void CreatureObjectAdapter::sendSystemMessage(const String& message) {
	((CreatureObjectImplementation*) impl)->sendSystemMessage(message);
}

void CreatureObjectAdapter::sendSystemMessage(UnicodeString& message) {
	((CreatureObjectImplementation*) impl)->sendSystemMessage(message);
}

void CreatureObjectAdapter::sendSystemMessage(const String& file, const String& stringid) {
	((CreatureObjectImplementation*) impl)->sendSystemMessage(file, stringid);
}

void CreatureObjectAdapter::sendSlottedObjectsTo(SceneObject* player) {
	((CreatureObjectImplementation*) impl)->sendSlottedObjectsTo(player);
}

void CreatureObjectAdapter::setCombatState() {
	((CreatureObjectImplementation*) impl)->setCombatState();
}

void CreatureObjectAdapter::clearCombatState(bool clearDefenders) {
	((CreatureObjectImplementation*) impl)->clearCombatState(clearDefenders);
}

void CreatureObjectAdapter::setPosture(int newPosture, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setPosture(newPosture, notifyClient);
}

void CreatureObjectAdapter::setRunSpeed(float newSpeed, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setRunSpeed(newSpeed, notifyClient);
}

void CreatureObjectAdapter::setHAM(int type, int value, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setHAM(type, value, notifyClient);
}

int CreatureObjectAdapter::inflictDamage(TangibleObject* attacker, int damageType, int damage, bool destroy, bool notifyClient) {
	return ((CreatureObjectImplementation*) impl)->inflictDamage(attacker, damageType, damage, destroy, notifyClient);
}

int CreatureObjectAdapter::healDamage(TangibleObject* healer, int damageType, int damage, bool notifyClient) {
	return ((CreatureObjectImplementation*) impl)->healDamage(healer, damageType, damage, notifyClient);
}

void CreatureObjectAdapter::setBaseHAM(int type, int value, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setBaseHAM(type, value, notifyClient);
}

void CreatureObjectAdapter::setWounds(int type, int value, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setWounds(type, value, notifyClient);
}

void CreatureObjectAdapter::addWounds(int type, int value, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->addWounds(type, value, notifyClient);
}

void CreatureObjectAdapter::setMaxHAM(int type, int value, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setMaxHAM(type, value, notifyClient);
}

void CreatureObjectAdapter::addMaxHAM(int type, int value, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->addMaxHAM(type, value, notifyClient);
}

void CreatureObjectAdapter::setEncumbrance(int type, int value, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setEncumbrance(type, value, notifyClient);
}

void CreatureObjectAdapter::addEncumbrance(int type, int value, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->addEncumbrance(type, value, notifyClient);
}

void CreatureObjectAdapter::setWeapon(WeaponObject* weao, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setWeapon(weao, notifyClient);
}

int CreatureObjectAdapter::notifyObjectInserted(SceneObject* object) {
	return ((CreatureObjectImplementation*) impl)->notifyObjectInserted(object);
}

void CreatureObjectAdapter::setInstrumentID(int instrumentid, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setInstrumentID(instrumentid, notifyClient);
}

void CreatureObjectAdapter::setShockWounds(int newShock, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setShockWounds(newShock, notifyClient);
}

void CreatureObjectAdapter::addShockWounds(int shockToAdd, bool notiyClient) {
	((CreatureObjectImplementation*) impl)->addShockWounds(shockToAdd, notiyClient);
}

void CreatureObjectAdapter::setTargetID(unsigned long long targetID, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setTargetID(targetID, notifyClient);
}

void CreatureObjectAdapter::setBankCredits(int credits, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setBankCredits(credits, notifyClient);
}

void CreatureObjectAdapter::addBuff(Buff* buff) {
	((CreatureObjectImplementation*) impl)->addBuff(buff);
}

void CreatureObjectAdapter::removeBuff(unsigned int buffcrc) {
	((CreatureObjectImplementation*) impl)->removeBuff(buffcrc);
}

void CreatureObjectAdapter::removeBuff(Buff* buff) {
	((CreatureObjectImplementation*) impl)->removeBuff(buff);
}

void CreatureObjectAdapter::clearBuffs(bool updateclient) {
	((CreatureObjectImplementation*) impl)->clearBuffs(updateclient);
}

int CreatureObjectAdapter::addDotState(unsigned long long dotType, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense) {
	return ((CreatureObjectImplementation*) impl)->addDotState(dotType, strength, type, duration, potency, defense);
}

bool CreatureObjectAdapter::healDot(unsigned long long dotType, int reduction) {
	return ((CreatureObjectImplementation*) impl)->healDot(dotType, reduction);
}

bool CreatureObjectAdapter::hasBuff(unsigned int buffcrc) {
	return ((CreatureObjectImplementation*) impl)->hasBuff(buffcrc);
}

void CreatureObjectAdapter::notifySelfPositionUpdate() {
	((CreatureObjectImplementation*) impl)->notifySelfPositionUpdate();
}

void CreatureObjectAdapter::notifyPostureChange(int newPosture) {
	((CreatureObjectImplementation*) impl)->notifyPostureChange(newPosture);
}

void CreatureObjectAdapter::updateToDatabaseAllObjects(bool startTask) {
	((CreatureObjectImplementation*) impl)->updateToDatabaseAllObjects(startTask);
}

void CreatureObjectAdapter::addBankCredits(int credits, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->addBankCredits(credits, notifyClient);
}

void CreatureObjectAdapter::addCashCredits(int credits, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->addCashCredits(credits, notifyClient);
}

void CreatureObjectAdapter::substractBankCredits(int credits) {
	((CreatureObjectImplementation*) impl)->substractBankCredits(credits);
}

void CreatureObjectAdapter::substractCashCredits(int credits) {
	((CreatureObjectImplementation*) impl)->substractCashCredits(credits);
}

bool CreatureObjectAdapter::verifyCashCredits(int credits) {
	return ((CreatureObjectImplementation*) impl)->verifyCashCredits(credits);
}

bool CreatureObjectAdapter::verifyBankCredits(int credits) {
	return ((CreatureObjectImplementation*) impl)->verifyBankCredits(credits);
}

void CreatureObjectAdapter::setCashCredits(int credits, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setCashCredits(credits, notifyClient);
}

void CreatureObjectAdapter::addSkillBox(const String& skillBox, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->addSkillBox(skillBox, notifyClient);
}

void CreatureObjectAdapter::removeSkillBox(const String& skillBox, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->removeSkillBox(skillBox, notifyClient);
}

void CreatureObjectAdapter::addSkillMod(const String& skillMod, long long value, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->addSkillMod(skillMod, value, notifyClient);
}

void CreatureObjectAdapter::removeSkillMod(const String& skillMod, bool notifyCLient) {
	((CreatureObjectImplementation*) impl)->removeSkillMod(skillMod, notifyCLient);
}

void CreatureObjectAdapter::updateGroupInviterID(unsigned long long id, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->updateGroupInviterID(id, notifyClient);
}

void CreatureObjectAdapter::updateGroup(GroupObject* group, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->updateGroup(group, notifyClient);
}

void CreatureObjectAdapter::enqueueCommand(unsigned int actionCRC, unsigned int actionCount, unsigned long long targetID, const UnicodeString& arguments) {
	((CreatureObjectImplementation*) impl)->enqueueCommand(actionCRC, actionCount, targetID, arguments);
}

void CreatureObjectAdapter::setMood(byte moodID, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setMood(moodID, notifyClient);
}

void CreatureObjectAdapter::setMoodString(const String& animation, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setMoodString(animation, notifyClient);
}

void CreatureObjectAdapter::deleteQueueAction(unsigned int actionCount) {
	((CreatureObjectImplementation*) impl)->deleteQueueAction(actionCount);
}

bool CreatureObjectAdapter::setState(unsigned long long state, bool notifyClient) {
	return ((CreatureObjectImplementation*) impl)->setState(state, notifyClient);
}

void CreatureObjectAdapter::clearState(unsigned long long state, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->clearState(state, notifyClient);
}

void CreatureObjectAdapter::setControlDevice(ControlDevice* device) {
	((CreatureObjectImplementation*) impl)->setControlDevice(device);
}

unsigned int CreatureObjectAdapter::getWearableMask() {
	return ((CreatureObjectImplementation*) impl)->getWearableMask();
}

void CreatureObjectAdapter::setCreatureLink(CreatureObject* object, bool notifyClient) {
	((CreatureObjectImplementation*) impl)->setCreatureLink(object, notifyClient);
}

void CreatureObjectAdapter::executeObjectControllerAction(unsigned int actionCRC) {
	((CreatureObjectImplementation*) impl)->executeObjectControllerAction(actionCRC);
}

void CreatureObjectAdapter::executeObjectControllerAction(unsigned int actionCRC, unsigned long long targetID, const UnicodeString& args) {
	((CreatureObjectImplementation*) impl)->executeObjectControllerAction(actionCRC, targetID, args);
}

bool CreatureObjectAdapter::isAttackableBy(CreatureObject* object) {
	return ((CreatureObjectImplementation*) impl)->isAttackableBy(object);
}

void CreatureObjectAdapter::sendConversationStartTo(SceneObject* player) {
	((CreatureObjectImplementation*) impl)->sendConversationStartTo(player);
}

void CreatureObjectAdapter::selectConversationOption(int option, SceneObject* obj) {
	((CreatureObjectImplementation*) impl)->selectConversationOption(option, obj);
}

void CreatureObjectAdapter::dismount() {
	((CreatureObjectImplementation*) impl)->dismount();
}

float CreatureObjectAdapter::calculateBFRatio() {
	return ((CreatureObjectImplementation*) impl)->calculateBFRatio();
}

void CreatureObjectAdapter::setDizziedState(int durationSeconds) {
	((CreatureObjectImplementation*) impl)->setDizziedState(durationSeconds);
}

void CreatureObjectAdapter::setAimingState(int durationSeconds) {
	((CreatureObjectImplementation*) impl)->setAimingState(durationSeconds);
}

void CreatureObjectAdapter::setCoverState() {
	((CreatureObjectImplementation*) impl)->setCoverState();
}

void CreatureObjectAdapter::setBerserkedState(unsigned int duration) {
	((CreatureObjectImplementation*) impl)->setBerserkedState(duration);
}

void CreatureObjectAdapter::setStunnedState(int durationSeconds) {
	((CreatureObjectImplementation*) impl)->setStunnedState(durationSeconds);
}

void CreatureObjectAdapter::setBlindedState(int durationSeconds) {
	((CreatureObjectImplementation*) impl)->setBlindedState(durationSeconds);
}

void CreatureObjectAdapter::setIntimidatedState(int durationSeconds) {
	((CreatureObjectImplementation*) impl)->setIntimidatedState(durationSeconds);
}

void CreatureObjectAdapter::setSnaredState(int durationSeconds) {
	((CreatureObjectImplementation*) impl)->setSnaredState(durationSeconds);
}

void CreatureObjectAdapter::setRootedState(int durationSeconds) {
	((CreatureObjectImplementation*) impl)->setRootedState(durationSeconds);
}

bool CreatureObjectAdapter::setNextAttackDelay(int del) {
	return ((CreatureObjectImplementation*) impl)->setNextAttackDelay(del);
}

void CreatureObjectAdapter::setMeditateState() {
	((CreatureObjectImplementation*) impl)->setMeditateState();
}

void CreatureObjectAdapter::activateHAMRegeneration() {
	((CreatureObjectImplementation*) impl)->activateHAMRegeneration();
}

void CreatureObjectAdapter::activateStateRecovery() {
	((CreatureObjectImplementation*) impl)->activateStateRecovery();
}

bool CreatureObjectAdapter::hasAttackDelay() {
	return ((CreatureObjectImplementation*) impl)->hasAttackDelay();
}

void CreatureObjectAdapter::updateLastSuccessfulCombatAction() {
	((CreatureObjectImplementation*) impl)->updateLastSuccessfulCombatAction();
}

void CreatureObjectAdapter::updateKnockdownRecovery() {
	((CreatureObjectImplementation*) impl)->updateKnockdownRecovery();
}

void CreatureObjectAdapter::queueDizzyFallEvent() {
	((CreatureObjectImplementation*) impl)->queueDizzyFallEvent();
}

void CreatureObjectAdapter::updateLastKnockdown() {
	((CreatureObjectImplementation*) impl)->updateLastKnockdown();
}

bool CreatureObjectAdapter::checkKnockdownRecovery() {
	return ((CreatureObjectImplementation*) impl)->checkKnockdownRecovery();
}

bool CreatureObjectAdapter::checkLastKnockdown() {
	return ((CreatureObjectImplementation*) impl)->checkLastKnockdown();
}

void CreatureObjectAdapter::updatePostureDownRecovery() {
	((CreatureObjectImplementation*) impl)->updatePostureDownRecovery();
}

void CreatureObjectAdapter::updatePostureUpRecovery() {
	((CreatureObjectImplementation*) impl)->updatePostureUpRecovery();
}

bool CreatureObjectAdapter::checkPostureDownRecovery() {
	return ((CreatureObjectImplementation*) impl)->checkPostureDownRecovery();
}

bool CreatureObjectAdapter::checkPostureUpRecovery() {
	return ((CreatureObjectImplementation*) impl)->checkPostureUpRecovery();
}

void CreatureObjectAdapter::updateCooldownTimer(const String& coooldownTimer, unsigned int miliSecondsToAdd) {
	((CreatureObjectImplementation*) impl)->updateCooldownTimer(coooldownTimer, miliSecondsToAdd);
}

bool CreatureObjectAdapter::checkCooldownRecovery(const String& cooldown) {
	return ((CreatureObjectImplementation*) impl)->checkCooldownRecovery(cooldown);
}

int CreatureObjectAdapter::canAddObject(SceneObject* object, String& errorDescription) {
	return ((CreatureObjectImplementation*) impl)->canAddObject(object, errorDescription);
}

void CreatureObjectAdapter::doAnimation(const String& animation) {
	((CreatureObjectImplementation*) impl)->doAnimation(animation);
}

void CreatureObjectAdapter::doCombatAnimation(CreatureObject* defender, unsigned int animationCRC, byte hit) {
	((CreatureObjectImplementation*) impl)->doCombatAnimation(defender, animationCRC, hit);
}

void CreatureObjectAdapter::playEffect(const String& file, const String& aux) {
	((CreatureObjectImplementation*) impl)->playEffect(file, aux);
}

void CreatureObjectAdapter::playEffect(const String& file) {
	((CreatureObjectImplementation*) impl)->playEffect(file);
}

void CreatureObjectAdapter::showFlyText(const String& file, const String& uax, byte red, byte green, byte blue) {
	((CreatureObjectImplementation*) impl)->showFlyText(file, uax, red, green, blue);
}

void CreatureObjectAdapter::activateQueueAction() {
	((CreatureObjectImplementation*) impl)->activateQueueAction();
}

UnicodeString CreatureObjectAdapter::getCreatureName() {
	return ((CreatureObjectImplementation*) impl)->getCreatureName();
}

bool CreatureObjectAdapter::isGroupped() {
	return ((CreatureObjectImplementation*) impl)->isGroupped();
}

int CreatureObjectAdapter::getBankCredits() {
	return ((CreatureObjectImplementation*) impl)->getBankCredits();
}

int CreatureObjectAdapter::getCashCredits() {
	return ((CreatureObjectImplementation*) impl)->getCashCredits();
}

int CreatureObjectAdapter::getBaseHAM(int idx) {
	return ((CreatureObjectImplementation*) impl)->getBaseHAM(idx);
}

int CreatureObjectAdapter::getWounds(int idx) {
	return ((CreatureObjectImplementation*) impl)->getWounds(idx);
}

int CreatureObjectAdapter::getHAM(int idx) {
	return ((CreatureObjectImplementation*) impl)->getHAM(idx);
}

int CreatureObjectAdapter::getMaxHAM(int idx) {
	return ((CreatureObjectImplementation*) impl)->getMaxHAM(idx);
}

int CreatureObjectAdapter::getEncumbrance(int idx) {
	return ((CreatureObjectImplementation*) impl)->getEncumbrance(idx);
}

byte CreatureObjectAdapter::getPosture() {
	return ((CreatureObjectImplementation*) impl)->getPosture();
}

byte CreatureObjectAdapter::getFactionRank() {
	return ((CreatureObjectImplementation*) impl)->getFactionRank();
}

CreatureObject* CreatureObjectAdapter::getLinkedCreature() {
	return ((CreatureObjectImplementation*) impl)->getLinkedCreature();
}

unsigned long long CreatureObjectAdapter::getCreatureLinkID() {
	return ((CreatureObjectImplementation*) impl)->getCreatureLinkID();
}

float CreatureObjectAdapter::getShockWounds() {
	return ((CreatureObjectImplementation*) impl)->getShockWounds();
}

unsigned long long CreatureObjectAdapter::getStateBitmask() {
	return ((CreatureObjectImplementation*) impl)->getStateBitmask();
}

bool CreatureObjectAdapter::hasState(unsigned long long state) {
	return ((CreatureObjectImplementation*) impl)->hasState(state);
}

bool CreatureObjectAdapter::hasStates() {
	return ((CreatureObjectImplementation*) impl)->hasStates();
}

unsigned long long CreatureObjectAdapter::getListenID() {
	return ((CreatureObjectImplementation*) impl)->getListenID();
}

float CreatureObjectAdapter::getRunSpeed() {
	return ((CreatureObjectImplementation*) impl)->getRunSpeed();
}

float CreatureObjectAdapter::getWalkSpeed() {
	return ((CreatureObjectImplementation*) impl)->getWalkSpeed();
}

float CreatureObjectAdapter::getTerrainNegotiation() {
	return ((CreatureObjectImplementation*) impl)->getTerrainNegotiation();
}

float CreatureObjectAdapter::getRunAcceleration() {
	return ((CreatureObjectImplementation*) impl)->getRunAcceleration();
}

float CreatureObjectAdapter::getWalkAcceleration() {
	return ((CreatureObjectImplementation*) impl)->getWalkAcceleration();
}

String CreatureObjectAdapter::getPerformanceAnimation() {
	return ((CreatureObjectImplementation*) impl)->getPerformanceAnimation();
}

String CreatureObjectAdapter::getMoodString() {
	return ((CreatureObjectImplementation*) impl)->getMoodString();
}

unsigned long long CreatureObjectAdapter::getWeaponID() {
	return ((CreatureObjectImplementation*) impl)->getWeaponID();
}

WeaponObject* CreatureObjectAdapter::getWeapon() {
	return ((CreatureObjectImplementation*) impl)->getWeapon();
}

unsigned long long CreatureObjectAdapter::getGroupID() {
	return ((CreatureObjectImplementation*) impl)->getGroupID();
}

unsigned long long CreatureObjectAdapter::getGroupInviterID() {
	return ((CreatureObjectImplementation*) impl)->getGroupInviterID();
}

GroupObject* CreatureObjectAdapter::getGroup() {
	return ((CreatureObjectImplementation*) impl)->getGroup();
}

unsigned long long CreatureObjectAdapter::getGroupInviteCounter() {
	return ((CreatureObjectImplementation*) impl)->getGroupInviteCounter();
}

int CreatureObjectAdapter::getGuildID() {
	return ((CreatureObjectImplementation*) impl)->getGuildID();
}

unsigned long long CreatureObjectAdapter::getTargetID() {
	return ((CreatureObjectImplementation*) impl)->getTargetID();
}

byte CreatureObjectAdapter::getMoodID() {
	return ((CreatureObjectImplementation*) impl)->getMoodID();
}

float CreatureObjectAdapter::getSlopeModPercent() {
	return ((CreatureObjectImplementation*) impl)->getSlopeModPercent();
}

int CreatureObjectAdapter::getPerformanceCounter() {
	return ((CreatureObjectImplementation*) impl)->getPerformanceCounter();
}

int CreatureObjectAdapter::getInstrumentID() {
	return ((CreatureObjectImplementation*) impl)->getInstrumentID();
}

byte CreatureObjectAdapter::getFrozen() {
	return ((CreatureObjectImplementation*) impl)->getFrozen();
}

float CreatureObjectAdapter::getHeight() {
	return ((CreatureObjectImplementation*) impl)->getHeight();
}

int CreatureObjectAdapter::getSpecies() {
	return ((CreatureObjectImplementation*) impl)->getSpecies();
}

long long CreatureObjectAdapter::getSkillMod(const String& skillmod) {
	return ((CreatureObjectImplementation*) impl)->getSkillMod(skillmod);
}

bool CreatureObjectAdapter::hasSkillBox(const String& skillBox) {
	return ((CreatureObjectImplementation*) impl)->hasSkillBox(skillBox);
}

void CreatureObjectAdapter::setHeight(float heigh) {
	((CreatureObjectImplementation*) impl)->setHeight(heigh);
}

bool CreatureObjectAdapter::isCreatureObject() {
	return ((CreatureObjectImplementation*) impl)->isCreatureObject();
}

bool CreatureObjectAdapter::isTrainerCreature() {
	return ((CreatureObjectImplementation*) impl)->isTrainerCreature();
}

bool CreatureObjectAdapter::isSwimming() {
	return ((CreatureObjectImplementation*) impl)->isSwimming();
}

bool CreatureObjectAdapter::isRidingMount() {
	return ((CreatureObjectImplementation*) impl)->isRidingMount();
}

ControlDevice* CreatureObjectAdapter::getControlDevice() {
	return ((CreatureObjectImplementation*) impl)->getControlDevice();
}

float CreatureObjectAdapter::getSwimHeight() {
	return ((CreatureObjectImplementation*) impl)->getSwimHeight();
}

bool CreatureObjectAdapter::isIncapacitated() {
	return ((CreatureObjectImplementation*) impl)->isIncapacitated();
}

bool CreatureObjectAdapter::isDead() {
	return ((CreatureObjectImplementation*) impl)->isDead();
}

bool CreatureObjectAdapter::isKnockedDown() {
	return ((CreatureObjectImplementation*) impl)->isKnockedDown();
}

bool CreatureObjectAdapter::isKneeling() {
	return ((CreatureObjectImplementation*) impl)->isKneeling();
}

bool CreatureObjectAdapter::isProne() {
	return ((CreatureObjectImplementation*) impl)->isProne();
}

bool CreatureObjectAdapter::isStanding() {
	return ((CreatureObjectImplementation*) impl)->isStanding();
}

bool CreatureObjectAdapter::isSitting() {
	return ((CreatureObjectImplementation*) impl)->isSitting();
}

bool CreatureObjectAdapter::isSkillAnimating() {
	return ((CreatureObjectImplementation*) impl)->isSkillAnimating();
}

bool CreatureObjectAdapter::isInCombat() {
	return ((CreatureObjectImplementation*) impl)->isInCombat();
}

bool CreatureObjectAdapter::isDizzied() {
	return ((CreatureObjectImplementation*) impl)->isDizzied();
}

bool CreatureObjectAdapter::isBerserked() {
	return ((CreatureObjectImplementation*) impl)->isBerserked();
}

bool CreatureObjectAdapter::isStunned() {
	return ((CreatureObjectImplementation*) impl)->isStunned();
}

bool CreatureObjectAdapter::isBlinded() {
	return ((CreatureObjectImplementation*) impl)->isBlinded();
}

bool CreatureObjectAdapter::isIntimidated() {
	return ((CreatureObjectImplementation*) impl)->isIntimidated();
}

bool CreatureObjectAdapter::isSnared() {
	return ((CreatureObjectImplementation*) impl)->isSnared();
}

bool CreatureObjectAdapter::isRooted() {
	return ((CreatureObjectImplementation*) impl)->isRooted();
}

bool CreatureObjectAdapter::isDiseased() {
	return ((CreatureObjectImplementation*) impl)->isDiseased();
}

bool CreatureObjectAdapter::isPoisoned() {
	return ((CreatureObjectImplementation*) impl)->isPoisoned();
}

bool CreatureObjectAdapter::isBleeding() {
	return ((CreatureObjectImplementation*) impl)->isBleeding();
}

bool CreatureObjectAdapter::isOnFire() {
	return ((CreatureObjectImplementation*) impl)->isOnFire();
}

bool CreatureObjectAdapter::isMounted() {
	return ((CreatureObjectImplementation*) impl)->isMounted();
}

bool CreatureObjectAdapter::isRidingCreature() {
	return ((CreatureObjectImplementation*) impl)->isRidingCreature();
}

bool CreatureObjectAdapter::isPeaced() {
	return ((CreatureObjectImplementation*) impl)->isPeaced();
}

bool CreatureObjectAdapter::isMeditating() {
	return ((CreatureObjectImplementation*) impl)->isMeditating();
}

bool CreatureObjectAdapter::isAiming() {
	return ((CreatureObjectImplementation*) impl)->isAiming();
}

bool CreatureObjectAdapter::isInCover() {
	return ((CreatureObjectImplementation*) impl)->isInCover();
}

bool CreatureObjectAdapter::isShuttleCreature() {
	return ((CreatureObjectImplementation*) impl)->isShuttleCreature();
}

bool CreatureObjectAdapter::isNonPlayerCreature() {
	return ((CreatureObjectImplementation*) impl)->isNonPlayerCreature();
}

bool CreatureObjectAdapter::isCreature() {
	return ((CreatureObjectImplementation*) impl)->isCreature();
}

bool CreatureObjectAdapter::isAiAgent() {
	return ((CreatureObjectImplementation*) impl)->isAiAgent();
}

/*
 *	CreatureObjectHelper
 */

CreatureObjectHelper* CreatureObjectHelper::staticInitializer = CreatureObjectHelper::instance();

CreatureObjectHelper::CreatureObjectHelper() {
	className = "CreatureObject";

	DistributedObjectBroker::instance()->registerClass(className, this);
}

void CreatureObjectHelper::finalizeHelper() {
	CreatureObjectHelper::finalize();
}

DistributedObject* CreatureObjectHelper::instantiateObject() {
	return new CreatureObject(DummyConstructorParameter::instance());
}

DistributedObjectServant* CreatureObjectHelper::instantiateServant() {
	return new CreatureObjectImplementation(DummyConstructorParameter::instance());
}

DistributedObjectAdapter* CreatureObjectHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new CreatureObjectAdapter((CreatureObjectImplementation*) obj->_getImplementation());

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

