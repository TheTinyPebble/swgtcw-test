/*
 *	server/zone/objects/creature/Creature.cpp generated by engine3 IDL compiler 0.55
 */

#include "Creature.h"

#include "CreatureImplementation.h"

#include "../../managers/creature/CreatureManagerImplementation.h"

#include "../../Zone.h"

#include "../player/Player.h"

#include "../tangible/wearables/Armor.h"

#include "../tangible/lair/LairObject.h"

#include "CreatureObject.h"

#include "CreatureGroup.h"

/*
 *	CreatureStub
 */

Creature::Creature(unsigned long long oid, CreatureGroup* group) : CreatureObject(DummyConstructorParameter::instance()) {
	_impl = new CreatureImplementation(oid, group);
	_impl->_setStub(this);
}

Creature::Creature(DummyConstructorParameter* param) : CreatureObject(param) {
}

Creature::~Creature() {
}

void Creature::init() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 6);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->init();
}

void Creature::unload() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 7);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->unload();
}

void Creature::loadItems() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 8);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->loadItems();
}

void Creature::scheduleDespawnCreature(int time) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 9);
		method.addSignedIntParameter(time);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->scheduleDespawnCreature(time);
}

bool Creature::activate() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 10);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureImplementation*) _impl)->activate();
}

bool Creature::isActive() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 11);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureImplementation*) _impl)->isActive();
}

void Creature::removeFromQueue() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 12);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->removeFromQueue();
}

bool Creature::doMovement() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 13);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureImplementation*) _impl)->doMovement();
}

void Creature::doStandUp() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 14);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->doStandUp();
}

void Creature::setArmor(unsigned int ar) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 15);
		method.addUnsignedIntParameter(ar);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->setArmor(ar);
}

unsigned int Creature::getArmor() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 16);

		return method.executeWithUnsignedIntReturn();
	} else
		return ((CreatureImplementation*) _impl)->getArmor();
}

float Creature::getArmorResist(int resistType) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 17);
		method.addSignedIntParameter(resistType);

		return method.executeWithFloatReturn();
	} else
		return ((CreatureImplementation*) _impl)->getArmorResist(resistType);
}

void Creature::setKinetic(float kin) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 18);
		method.addFloatParameter(kin);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->setKinetic(kin);
}

void Creature::setEnergy(float ene) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 19);
		method.addFloatParameter(ene);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->setEnergy(ene);
}

void Creature::setElectricity(float ele) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 20);
		method.addFloatParameter(ele);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->setElectricity(ele);
}

void Creature::setStun(float stu) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 21);
		method.addFloatParameter(stu);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->setStun(stu);
}

void Creature::setBlast(float bla) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 22);
		method.addFloatParameter(bla);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->setBlast(bla);
}

void Creature::setHeat(float hea) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 23);
		method.addFloatParameter(hea);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->setHeat(hea);
}

void Creature::setCold(float col) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 24);
		method.addFloatParameter(col);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->setCold(col);
}

void Creature::setAcid(float aci) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 25);
		method.addFloatParameter(aci);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->setAcid(aci);
}

void Creature::setLightSaber(float lig) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 26);
		method.addFloatParameter(lig);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->setLightSaber(lig);
}

void Creature::doAttack(CreatureObject* target, int damage) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 27);
		method.addObjectParameter(target);
		method.addSignedIntParameter(damage);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->doAttack(target, damage);
}

bool Creature::attack(CreatureObject* target) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 28);
		method.addObjectParameter(target);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureImplementation*) _impl)->attack(target);
}

void Creature::deaggro() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 29);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->deaggro();
}

void Creature::activateRecovery() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 30);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->activateRecovery();
}

bool Creature::doRecovery() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 31);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureImplementation*) _impl)->doRecovery();
}

void Creature::doStatesRecovery() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 32);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->doStatesRecovery();
}

void Creature::queueRespawn() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 33);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->queueRespawn();
}

void Creature::setNextMovementPosition(float x, float y, bool doLock) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 34);
		method.addFloatParameter(x);
		method.addFloatParameter(y);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->setNextMovementPosition(x, y, doLock);
}

void Creature::clearPatrolPoints(bool doLock) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 35);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->clearPatrolPoints(doLock);
}

void Creature::addPatrolPoint(float positionX, float positionY, bool doLock) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 36);
		method.addFloatParameter(positionX);
		method.addFloatParameter(positionY);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->addPatrolPoint(positionX, positionY, doLock);
}

void Creature::startPatrol(bool doLock) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 37);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->startPatrol(doLock);
}

void Creature::stopPatrol(bool doLock) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 38);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->stopPatrol(doLock);
}

void Creature::setSpawnPosition(float posX, float posZ, float posY, unsigned long long cellid) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 39);
		method.addFloatParameter(posX);
		method.addFloatParameter(posZ);
		method.addFloatParameter(posY);
		method.addUnsignedLongParameter(cellid);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->setSpawnPosition(posX, posZ, posY, cellid);
}

int Creature::compareTo(Creature* creature) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 40);
		method.addObjectParameter(creature);

		return method.executeWithSignedIntReturn();
	} else
		return ((CreatureImplementation*) _impl)->compareTo(creature);
}

int Creature::getType() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 41);

		return method.executeWithSignedIntReturn();
	} else
		return ((CreatureImplementation*) _impl)->getType();
}

bool Creature::isTrainer() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 42);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureImplementation*) _impl)->isTrainer();
}

bool Creature::isRecruiter() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 43);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureImplementation*) _impl)->isRecruiter();
}

String& Creature::getName() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 44);

		method.executeWithAsciiReturn(_return_getName);
		return _return_getName;
	} else
		return ((CreatureImplementation*) _impl)->getName();
}

int Creature::getZoneIndex() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 45);

		return method.executeWithSignedIntReturn();
	} else
		return ((CreatureImplementation*) _impl)->getZoneIndex();
}

Zone* Creature::getZone() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 46);

		return (Zone*) method.executeWithObjectReturn();
	} else
		return ((CreatureImplementation*) _impl)->getZone();
}

CreatureObject* Creature::getAggroedCreature() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 47);

		return (CreatureObject*) method.executeWithObjectReturn();
	} else
		return ((CreatureImplementation*) _impl)->getAggroedCreature();
}

unsigned long long Creature::getNewItemID() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 48);

		return method.executeWithUnsignedLongReturn();
	} else
		return ((CreatureImplementation*) _impl)->getNewItemID();
}

unsigned int Creature::getRespawnTimer() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 49);

		return method.executeWithUnsignedIntReturn();
	} else
		return ((CreatureImplementation*) _impl)->getRespawnTimer();
}

LairObject* Creature::getLair() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 50);

		return (LairObject*) method.executeWithObjectReturn();
	} else
		return ((CreatureImplementation*) _impl)->getLair();
}

bool Creature::hasLootCreated() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 51);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureImplementation*) _impl)->hasLootCreated();
}

void Creature::setCreatureManager(CreatureManagerImplementation* manager) {
	if (_impl == NULL) {
		throw ObjectNotLocalException(this);

	} else
		((CreatureImplementation*) _impl)->setCreatureManager(manager);
}

void Creature::setLair(LairObject* Lair) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 52);
		method.addObjectParameter(Lair);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->setLair(Lair);
}

void Creature::setCreatureGroup(CreatureGroup* group) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 53);
		method.addObjectParameter(group);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->setCreatureGroup(group);
}

void Creature::setObjectFileName(const String& name) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 54);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->setObjectFileName(name);
}

String& Creature::getObjectFileName() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 55);

		method.executeWithAsciiReturn(_return_getObjectFileName);
		return _return_getObjectFileName;
	} else
		return ((CreatureImplementation*) _impl)->getObjectFileName();
}

void Creature::setType(int tp) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 56);
		method.addSignedIntParameter(tp);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->setType(tp);
}

void Creature::setRespawnTimer(unsigned int seconds) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 57);
		method.addUnsignedIntParameter(seconds);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->setRespawnTimer(seconds);
}

void Creature::removePlayerFromHarvestList(String& firstName) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 58);
		method.addAsciiParameter(firstName);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->removePlayerFromHarvestList(firstName);
}

bool Creature::canHarvest(String& firstName) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 59);
		method.addAsciiParameter(firstName);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureImplementation*) _impl)->canHarvest(firstName);
}

bool Creature::beenLooted() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 60);

		return method.executeWithBooleanReturn();
	} else
		return ((CreatureImplementation*) _impl)->beenLooted();
}

void Creature::wasLooted() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 61);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->wasLooted();
}

void Creature::setLootCreated(bool value) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 62);
		method.addBooleanParameter(value);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->setLootCreated(value);
}

void Creature::setRandomMovement(bool value) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 63);
		method.addBooleanParameter(value);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->setRandomMovement(value);
}

unsigned int Creature::getFPValue() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 64);

		return method.executeWithUnsignedIntReturn();
	} else
		return ((CreatureImplementation*) _impl)->getFPValue();
}

void Creature::setFPValue(unsigned int value) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 65);
		method.addUnsignedIntParameter(value);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->setFPValue(value);
}

void Creature::onIncapacitateTarget(CreatureObject* victim) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 66);
		method.addObjectParameter(victim);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->onIncapacitateTarget(victim);
}

void Creature::onKilled(CreatureObject* killer) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 67);
		method.addObjectParameter(killer);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->onKilled(killer);
}

void Creature::onDeath() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 68);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->onDeath();
}

void Creature::initAI() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 69);

		method.executeWithVoidReturn();
	} else
		((CreatureImplementation*) _impl)->initAI();
}

/*
 *	CreatureAdapter
 */

CreatureAdapter::CreatureAdapter(CreatureImplementation* obj) : CreatureObjectAdapter(obj) {
}

Packet* CreatureAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	Packet* resp = new MethodReturnMessage(0);

	switch (methid) {
	case 6:
		init();
		break;
	case 7:
		unload();
		break;
	case 8:
		loadItems();
		break;
	case 9:
		scheduleDespawnCreature(inv->getSignedIntParameter());
		break;
	case 10:
		resp->insertBoolean(activate());
		break;
	case 11:
		resp->insertBoolean(isActive());
		break;
	case 12:
		removeFromQueue();
		break;
	case 13:
		resp->insertBoolean(doMovement());
		break;
	case 14:
		doStandUp();
		break;
	case 15:
		setArmor(inv->getUnsignedIntParameter());
		break;
	case 16:
		resp->insertInt(getArmor());
		break;
	case 17:
		resp->insertFloat(getArmorResist(inv->getSignedIntParameter()));
		break;
	case 18:
		setKinetic(inv->getFloatParameter());
		break;
	case 19:
		setEnergy(inv->getFloatParameter());
		break;
	case 20:
		setElectricity(inv->getFloatParameter());
		break;
	case 21:
		setStun(inv->getFloatParameter());
		break;
	case 22:
		setBlast(inv->getFloatParameter());
		break;
	case 23:
		setHeat(inv->getFloatParameter());
		break;
	case 24:
		setCold(inv->getFloatParameter());
		break;
	case 25:
		setAcid(inv->getFloatParameter());
		break;
	case 26:
		setLightSaber(inv->getFloatParameter());
		break;
	case 27:
		doAttack((CreatureObject*) inv->getObjectParameter(), inv->getSignedIntParameter());
		break;
	case 28:
		resp->insertBoolean(attack((CreatureObject*) inv->getObjectParameter()));
		break;
	case 29:
		deaggro();
		break;
	case 30:
		activateRecovery();
		break;
	case 31:
		resp->insertBoolean(doRecovery());
		break;
	case 32:
		doStatesRecovery();
		break;
	case 33:
		queueRespawn();
		break;
	case 34:
		setNextMovementPosition(inv->getFloatParameter(), inv->getFloatParameter(), inv->getBooleanParameter());
		break;
	case 35:
		clearPatrolPoints(inv->getBooleanParameter());
		break;
	case 36:
		addPatrolPoint(inv->getFloatParameter(), inv->getFloatParameter(), inv->getBooleanParameter());
		break;
	case 37:
		startPatrol(inv->getBooleanParameter());
		break;
	case 38:
		stopPatrol(inv->getBooleanParameter());
		break;
	case 39:
		setSpawnPosition(inv->getFloatParameter(), inv->getFloatParameter(), inv->getFloatParameter(), inv->getUnsignedLongParameter());
		break;
	case 40:
		resp->insertSignedInt(compareTo((Creature*) inv->getObjectParameter()));
		break;
	case 41:
		resp->insertSignedInt(getType());
		break;
	case 42:
		resp->insertBoolean(isTrainer());
		break;
	case 43:
		resp->insertBoolean(isRecruiter());
		break;
	case 44:
		resp->insertAscii(getName());
		break;
	case 45:
		resp->insertSignedInt(getZoneIndex());
		break;
	case 46:
		resp->insertLong(getZone()->_getObjectID());
		break;
	case 47:
		resp->insertLong(getAggroedCreature()->_getObjectID());
		break;
	case 48:
		resp->insertLong(getNewItemID());
		break;
	case 49:
		resp->insertInt(getRespawnTimer());
		break;
	case 50:
		resp->insertLong(getLair()->_getObjectID());
		break;
	case 51:
		resp->insertBoolean(hasLootCreated());
		break;
	case 52:
		setLair((LairObject*) inv->getObjectParameter());
		break;
	case 53:
		setCreatureGroup((CreatureGroup*) inv->getObjectParameter());
		break;
	case 54:
		setObjectFileName(inv->getAsciiParameter(_param0_setObjectFileName__String_));
		break;
	case 55:
		resp->insertAscii(getObjectFileName());
		break;
	case 56:
		setType(inv->getSignedIntParameter());
		break;
	case 57:
		setRespawnTimer(inv->getUnsignedIntParameter());
		break;
	case 58:
		removePlayerFromHarvestList(inv->getAsciiParameter(_param0_removePlayerFromHarvestList__String_));
		break;
	case 59:
		resp->insertBoolean(canHarvest(inv->getAsciiParameter(_param0_canHarvest__String_)));
		break;
	case 60:
		resp->insertBoolean(beenLooted());
		break;
	case 61:
		wasLooted();
		break;
	case 62:
		setLootCreated(inv->getBooleanParameter());
		break;
	case 63:
		setRandomMovement(inv->getBooleanParameter());
		break;
	case 64:
		resp->insertInt(getFPValue());
		break;
	case 65:
		setFPValue(inv->getUnsignedIntParameter());
		break;
	case 66:
		onIncapacitateTarget((CreatureObject*) inv->getObjectParameter());
		break;
	case 67:
		onKilled((CreatureObject*) inv->getObjectParameter());
		break;
	case 68:
		onDeath();
		break;
	case 69:
		initAI();
		break;
	default:
		return NULL;
	}

	return resp;
}

void CreatureAdapter::init() {
	return ((CreatureImplementation*) impl)->init();
}

void CreatureAdapter::unload() {
	return ((CreatureImplementation*) impl)->unload();
}

void CreatureAdapter::loadItems() {
	return ((CreatureImplementation*) impl)->loadItems();
}

void CreatureAdapter::scheduleDespawnCreature(int time) {
	return ((CreatureImplementation*) impl)->scheduleDespawnCreature(time);
}

bool CreatureAdapter::activate() {
	return ((CreatureImplementation*) impl)->activate();
}

bool CreatureAdapter::isActive() {
	return ((CreatureImplementation*) impl)->isActive();
}

void CreatureAdapter::removeFromQueue() {
	return ((CreatureImplementation*) impl)->removeFromQueue();
}

bool CreatureAdapter::doMovement() {
	return ((CreatureImplementation*) impl)->doMovement();
}

void CreatureAdapter::doStandUp() {
	return ((CreatureImplementation*) impl)->doStandUp();
}

void CreatureAdapter::setArmor(unsigned int ar) {
	return ((CreatureImplementation*) impl)->setArmor(ar);
}

unsigned int CreatureAdapter::getArmor() {
	return ((CreatureImplementation*) impl)->getArmor();
}

float CreatureAdapter::getArmorResist(int resistType) {
	return ((CreatureImplementation*) impl)->getArmorResist(resistType);
}

void CreatureAdapter::setKinetic(float kin) {
	return ((CreatureImplementation*) impl)->setKinetic(kin);
}

void CreatureAdapter::setEnergy(float ene) {
	return ((CreatureImplementation*) impl)->setEnergy(ene);
}

void CreatureAdapter::setElectricity(float ele) {
	return ((CreatureImplementation*) impl)->setElectricity(ele);
}

void CreatureAdapter::setStun(float stu) {
	return ((CreatureImplementation*) impl)->setStun(stu);
}

void CreatureAdapter::setBlast(float bla) {
	return ((CreatureImplementation*) impl)->setBlast(bla);
}

void CreatureAdapter::setHeat(float hea) {
	return ((CreatureImplementation*) impl)->setHeat(hea);
}

void CreatureAdapter::setCold(float col) {
	return ((CreatureImplementation*) impl)->setCold(col);
}

void CreatureAdapter::setAcid(float aci) {
	return ((CreatureImplementation*) impl)->setAcid(aci);
}

void CreatureAdapter::setLightSaber(float lig) {
	return ((CreatureImplementation*) impl)->setLightSaber(lig);
}

void CreatureAdapter::doAttack(CreatureObject* target, int damage) {
	return ((CreatureImplementation*) impl)->doAttack(target, damage);
}

bool CreatureAdapter::attack(CreatureObject* target) {
	return ((CreatureImplementation*) impl)->attack(target);
}

void CreatureAdapter::deaggro() {
	return ((CreatureImplementation*) impl)->deaggro();
}

void CreatureAdapter::activateRecovery() {
	return ((CreatureImplementation*) impl)->activateRecovery();
}

bool CreatureAdapter::doRecovery() {
	return ((CreatureImplementation*) impl)->doRecovery();
}

void CreatureAdapter::doStatesRecovery() {
	return ((CreatureImplementation*) impl)->doStatesRecovery();
}

void CreatureAdapter::queueRespawn() {
	return ((CreatureImplementation*) impl)->queueRespawn();
}

void CreatureAdapter::setNextMovementPosition(float x, float y, bool doLock) {
	return ((CreatureImplementation*) impl)->setNextMovementPosition(x, y, doLock);
}

void CreatureAdapter::clearPatrolPoints(bool doLock) {
	return ((CreatureImplementation*) impl)->clearPatrolPoints(doLock);
}

void CreatureAdapter::addPatrolPoint(float positionX, float positionY, bool doLock) {
	return ((CreatureImplementation*) impl)->addPatrolPoint(positionX, positionY, doLock);
}

void CreatureAdapter::startPatrol(bool doLock) {
	return ((CreatureImplementation*) impl)->startPatrol(doLock);
}

void CreatureAdapter::stopPatrol(bool doLock) {
	return ((CreatureImplementation*) impl)->stopPatrol(doLock);
}

void CreatureAdapter::setSpawnPosition(float posX, float posZ, float posY, unsigned long long cellid) {
	return ((CreatureImplementation*) impl)->setSpawnPosition(posX, posZ, posY, cellid);
}

int CreatureAdapter::compareTo(Creature* creature) {
	return ((CreatureImplementation*) impl)->compareTo(creature);
}

int CreatureAdapter::getType() {
	return ((CreatureImplementation*) impl)->getType();
}

bool CreatureAdapter::isTrainer() {
	return ((CreatureImplementation*) impl)->isTrainer();
}

bool CreatureAdapter::isRecruiter() {
	return ((CreatureImplementation*) impl)->isRecruiter();
}

String& CreatureAdapter::getName() {
	return ((CreatureImplementation*) impl)->getName();
}

int CreatureAdapter::getZoneIndex() {
	return ((CreatureImplementation*) impl)->getZoneIndex();
}

Zone* CreatureAdapter::getZone() {
	return ((CreatureImplementation*) impl)->getZone();
}

CreatureObject* CreatureAdapter::getAggroedCreature() {
	return ((CreatureImplementation*) impl)->getAggroedCreature();
}

unsigned long long CreatureAdapter::getNewItemID() {
	return ((CreatureImplementation*) impl)->getNewItemID();
}

unsigned int CreatureAdapter::getRespawnTimer() {
	return ((CreatureImplementation*) impl)->getRespawnTimer();
}

LairObject* CreatureAdapter::getLair() {
	return ((CreatureImplementation*) impl)->getLair();
}

bool CreatureAdapter::hasLootCreated() {
	return ((CreatureImplementation*) impl)->hasLootCreated();
}

void CreatureAdapter::setLair(LairObject* Lair) {
	return ((CreatureImplementation*) impl)->setLair(Lair);
}

void CreatureAdapter::setCreatureGroup(CreatureGroup* group) {
	return ((CreatureImplementation*) impl)->setCreatureGroup(group);
}

void CreatureAdapter::setObjectFileName(const String& name) {
	return ((CreatureImplementation*) impl)->setObjectFileName(name);
}

String& CreatureAdapter::getObjectFileName() {
	return ((CreatureImplementation*) impl)->getObjectFileName();
}

void CreatureAdapter::setType(int tp) {
	return ((CreatureImplementation*) impl)->setType(tp);
}

void CreatureAdapter::setRespawnTimer(unsigned int seconds) {
	return ((CreatureImplementation*) impl)->setRespawnTimer(seconds);
}

void CreatureAdapter::removePlayerFromHarvestList(String& firstName) {
	return ((CreatureImplementation*) impl)->removePlayerFromHarvestList(firstName);
}

bool CreatureAdapter::canHarvest(String& firstName) {
	return ((CreatureImplementation*) impl)->canHarvest(firstName);
}

bool CreatureAdapter::beenLooted() {
	return ((CreatureImplementation*) impl)->beenLooted();
}

void CreatureAdapter::wasLooted() {
	return ((CreatureImplementation*) impl)->wasLooted();
}

void CreatureAdapter::setLootCreated(bool value) {
	return ((CreatureImplementation*) impl)->setLootCreated(value);
}

void CreatureAdapter::setRandomMovement(bool value) {
	return ((CreatureImplementation*) impl)->setRandomMovement(value);
}

unsigned int CreatureAdapter::getFPValue() {
	return ((CreatureImplementation*) impl)->getFPValue();
}

void CreatureAdapter::setFPValue(unsigned int value) {
	return ((CreatureImplementation*) impl)->setFPValue(value);
}

void CreatureAdapter::onIncapacitateTarget(CreatureObject* victim) {
	return ((CreatureImplementation*) impl)->onIncapacitateTarget(victim);
}

void CreatureAdapter::onKilled(CreatureObject* killer) {
	return ((CreatureImplementation*) impl)->onKilled(killer);
}

void CreatureAdapter::onDeath() {
	return ((CreatureImplementation*) impl)->onDeath();
}

void CreatureAdapter::initAI() {
	return ((CreatureImplementation*) impl)->initAI();
}

/*
 *	CreatureHelper
 */

CreatureHelper* CreatureHelper::staticInitializer = CreatureHelper::instance();

CreatureHelper::CreatureHelper() {
	className = "Creature";

	DistributedObjectBroker::instance()->registerClass(className, this);
}

void CreatureHelper::finalizeHelper() {
	CreatureHelper::finalize();
}

DistributedObject* CreatureHelper::instantiateObject() {
	return new Creature(DummyConstructorParameter::instance());
}

DistributedObjectAdapter* CreatureHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new CreatureAdapter((CreatureImplementation*) obj->_getImplementation());

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	CreatureServant
 */

CreatureServant::CreatureServant(unsigned long long oid) : CreatureObjectImplementation(oid) {
	_classHelper = CreatureHelper::instance();
}

CreatureServant::~CreatureServant() {
}

void CreatureServant::_setStub(DistributedObjectStub* stub) {
	_this = (Creature*) stub;
	CreatureObjectServant::_setStub(stub);
}

DistributedObjectStub* CreatureServant::_getStub() {
	return _this;
}

