/*
 *	server/zone/objects/creature/CreatureObject.h generated by engine3 IDL compiler 0.60
 */

#ifndef CREATUREOBJECT_H_
#define CREATUREOBJECT_H_

#include "engine/core/Core.h"

#include "engine/core/ManagedReference.h"

#include "engine/core/ManagedWeakReference.h"

namespace server {
namespace chat {

class StringIdChatParameter;

} // namespace chat
} // namespace server

using namespace server::chat;

namespace server {
namespace zone {
namespace objects {
namespace group {

class GroupObject;

} // namespace group
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::group;

namespace server {
namespace zone {
namespace objects {
namespace guild {

class GuildObject;

} // namespace guild
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::guild;

namespace server {
namespace zone {
namespace objects {
namespace tangible {
namespace weapon {

class WeaponObject;

} // namespace weapon
} // namespace tangible
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::tangible::weapon;

namespace server {
namespace zone {
namespace managers {
namespace objectcontroller {

class ObjectController;

} // namespace objectcontroller
} // namespace managers
} // namespace zone
} // namespace server

using namespace server::zone::managers::objectcontroller;

namespace server {
namespace zone {
namespace objects {
namespace creature {

class CreatureObject;

} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace ai {

class AiActor;

} // namespace ai
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::ai;

namespace server {
namespace zone {
namespace objects {
namespace player {

class PlayerObject;

} // namespace player
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::player;

namespace server {
namespace zone {
namespace objects {
namespace scene {

class SceneObject;

} // namespace scene
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::scene;

namespace server {
namespace zone {
namespace objects {
namespace intangible {

class ControlDevice;

} // namespace intangible
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::intangible;

namespace server {
namespace zone {
namespace objects {
namespace area {

class ActiveArea;

} // namespace area
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::area;

namespace server {
namespace zone {
namespace objects {
namespace area {

class CampSiteActiveArea;

} // namespace area
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::area;

namespace server {
namespace zone {

class Zone;

} // namespace zone
} // namespace server

using namespace server::zone;

namespace server {
namespace zone {
namespace templates {

class SharedObjectTemplate;

} // namespace templates
} // namespace zone
} // namespace server

using namespace server::zone::templates;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace buffs {

class Buff;

} // namespace buffs
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::buffs;

namespace server {
namespace zone {
namespace objects {
namespace tangible {
namespace weapon {

class WeaponObject;

} // namespace weapon
} // namespace tangible
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::tangible::weapon;

namespace server {
namespace zone {

class ZoneClientSession;

} // namespace zone
} // namespace server

using namespace server::zone;

namespace server {
namespace zone {
namespace packets {
namespace scene {

class AttributeListMessage;

} // namespace scene
} // namespace packets
} // namespace zone
} // namespace server

using namespace server::zone::packets::scene;

#include "gmock/gmock.h"

#include "server/zone/objects/creature/variables/CooldownTimerMap.h"

#include "server/zone/objects/creature/buffs/BuffList.h"

#include "server/zone/objects/creature/damageovertime/DamageOverTimeList.h"

#include "server/zone/objects/scene/variables/DeltaVector.h"

#include "server/zone/objects/creature/variables/CommandQueueActionVector.h"

#include "server/zone/objects/scene/variables/DeltaVectorMap.h"

#include "server/zone/objects/creature/variables/SkillList.h"

#include "server/zone/objects/creature/variables/SkillModList.h"

#include "server/zone/objects/creature/variables/SkillModEntry.h"

#include "server/zone/objects/creature/variables/CommandQueueAction.h"

#include "server/zone/objects/creature/CreaturePosture.h"

#include "server/zone/objects/creature/CreatureState.h"

#include "server/zone/objects/creature/SpeedMultiplierModChanges.h"

#include "server/zone/objects/creature/variables/Skill.h"

#include "server/zone/objects/creature/variables/WearablesDeltaVector.h"

#include "server/zone/objects/tangible/TangibleObject.h"

#include "engine/core/ManagedObject.h"

#include "engine/lua/LuaObject.h"

#include "system/util/Vector.h"

#include "system/util/VectorMap.h"

#include "system/lang/Time.h"

#include "system/util/SortedVector.h"

#include "system/lang/Long.h"

#include "engine/service/proto/BasePacket.h"

#include "system/thread/Mutex.h"

namespace server {
namespace zone {
namespace objects {
namespace creature {

class CreatureObject : public TangibleObject {
public:
	static const int HUMAN = 0;

	static const int RODIAN = 1;

	static const int TRANDOSHAN = 2;

	static const int MONCAL = 3;

	static const int WOOKIE = 4;

	static const int BOTHAN = 5;

	static const int TWILEK = 6;

	static const int ZABRAK = 7;

	static const int ITHORIAN = 0x21;

	static const int SULLUSTAN = 0x31;

	static const int MALE = 0;

	static const int FEMALE = 1;

	unsigned static const long long DEAD_TOO_LONG = 1800000;

	/**
	 * CreatureObject constructor, used to initialized the object
	 * @pre { templateData is a valid SharedCreatureObjectTemplate LuaObject that contains the necessary values to initialize CreatureObject }
	 * @post { CreatureObject is initialized } 
	 * @param templateData templateData points to the SharedCreatureObjectTemplate LuaObject that is used to initialize CreatureObject members
	 */
	CreatureObject();

	void initializeMembers();

	void createChildObjects();

	/**
	 * Reads and sets the template data from a SharedTangibleObjectTemplate LuaObject
	 * @pre { templateData is a valid pointer }
	 * @post { TangibleObject members are initialized }
	 * @param templateData templateData points to the SharedTangibleObjectTemplate LuaObject that is used to initialize the TangibleObject members
	 */
	void loadTemplateData(SharedObjectTemplate* templateData);

	/**
	 * Initializes the transient members of SceneObject, must call the inherited object method first.
	 * @pre {transient members are not initialized }
	 * @post { transient members are initialized }
	 */
	void initializeTransientMembers();

	/**
	 * Sends a CommandQueueRemove ObjectControllerMessage to the owner client of this object
	 * @pre { }
	 * @post { client received the CommandQueueRemove message }
	 * @param actioncntr action id that will be cleared from clients queue
	 * @param timer how many seconds will the action take to execute
	 * @param tab1 message 1
	 * @param tab2 message 2 
	 */
	void clearQueueAction(unsigned int actioncntr, float timer = 0, unsigned int tab1 = 0, unsigned int tab2 = 0);

	/**
	 * Sends the CREO baseline messages of this object to the specified player
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the baseline messages }
	 * @param player SceneObject that will receive the baselines 
	 */
	void sendBaselinesTo(SceneObject* player);

	/**
	 * Sends the necessary messages to owner client
	 * @pre { this object is locked }
	 * @post { this object is locked, owner received its own scene object }
	 * @param doClose if true a SceneObjectCloseMessage is sent to finish the object
	 */
	void sendToOwner(bool doClose = true);

	/**
	 * Sends the necessary messages to player in order to create this object
	 * @pre { this object is locked }
	 * @post { this object is locked, player received this object }
	 * @param player SceneObject that will receive the messages
	 * @param doClose if true a SceneObjectCloseMessage is sent to finish the object
	 */
	void sendTo(SceneObject* player, bool doClose);

	/**
	 * Sends a system message to the client of this object
	 * @pre {}
	 * @post { this object received the message }
	 * @param message string message to send
	 */
	void sendSystemMessage(const String& message);

	/**
	 * Sends a PlayMusicMessage
	 */
	void playMusicMessage(const String& file);

	/**
	 * Sends a tutorial request
	 */
	void sendNewbieTutorialRequest(const String& request);

	/**
	 * Sends NewbieTutorialEnableHud
	 */
	void sendNewbieTutorialEnableHudElement(const String& ui, bool enable = true);

	void sendOpenHolocronToPageMessage();

	/**
	 * Sends a system message to the client of this object
	 * @pre {}
	 * @post { this object received the message }
	 * @param message unicode message to send
	 */
	void sendSystemMessage(UnicodeString& message);

	/**
	 * Sends a system message to the client of this object
	 * @pre {}
	 * @post { this object received the message }
	 * @param message StringIdChatParameter message to send
	 */
	void sendSystemMessage(StringIdChatParameter& stringid);

	/**
	 * Sends the contained slotted objects to the specified player
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the slotted objects }
	 * @param player SceneObject that will receive the objects 
	 */
	void sendSlottedObjectsTo(SceneObject* player);

	/**
	 * Sets the combat state
	 * @pre { this object is locked }
	 * @post { this object is locked, this object is in a combat state }
	 */
	void setCombatState();

	/**
	 * Cleares the combat state
	 * @pre { this object is locked }
	 * @post { this object is locked, this object is not in a combat state }
	 * @param clearDefenders if true the defender vector willl be emptied
	 */
	void clearCombatState(bool clearDefenders = true);

	/**
	 * Sets a new posture
	 * @pre { this object is locked }
	 * @post {this object is locked, this object has the new posture set }
	 * @param newPosture posture to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setPosture(int newPosture, bool notifyClient = true);

	/**
	 * checks locomotion and sets a new one if appropriate
	 * @pre { this object is locked }
	 * @post {this object is locked, this object has the new locomotion set, if appropriate }
	 */
	float calculateSpeed();

	void updateLocomotion();

	void setHeight(float heigh, bool notifyClient = true);

	/**
	 * Updates the acceleration speed multiplier base
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param newMultiplierBase new multiplier base to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setAccelerationMultiplierBase(float newMultiplierBase, bool notifyClient = true);

	/**
	 * Updates the acceleration speed multiplier mod
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param newMultiplierMod new multiplier mod to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setAccelerationMultiplierMod(float newMultiplierMod, bool notifyClient = true);

	/**
	 * Updates the speed multiplier base
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param newMultiplierBase new multiplier base to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setSpeedMultiplierBase(float newMultiplierBase, bool notifyClient = true);

	/**
	 * Updates the speed multiplier mod
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param newMultiplierMod new multiplier mod to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setSpeedMultiplierMod(float newMultiplierMod, bool notifyClient = true);

	/**
	 * Updates the turn scale mod
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param newMultiplierMod new multiplier mod to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setTurnScale(float newMultiplierMod, bool notifyClient = true);

	/**
	 * Updates the run speed
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * 
	 */
	void setRunSpeed(float newSpeed, bool notifyClient = true);

	void setCurrentSpeed(float newSpeed);

	/**
	 * Updates a specific type of the HAM
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the HAM type updated to the new value }
	 * @param type specifies which HAM type to update
	 * @param value the new value
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setHAM(int type, int value, bool notifyClient = true);

	/**
	 * Inflicts damage into the object
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return unused for now
	 */
	int inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, bool notifyClient = true);

	int inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, const String& xp, bool notifyClient = true);

	bool hasDamage(int attribute);

	/**
	 * Heals damage
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return unused for now
	 */
	int healDamage(TangibleObject* healer, int damageType, int damage, bool notifyClient = true, bool notifyObservers = true);

	/**
	 * Heals wound
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return unused for now
	 */
	int healWound(TangibleObject* healer, int damageType, int damage, bool notifyClient = true, bool notifyObservers = true);

	/**
	 * Updates a specific type of the Base HAM
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the Base HAM type updated to the new value }
	 * @param type specifies which Base HAM type to update
	 * @param value the new value
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setBaseHAM(int type, int value, bool notifyClient = true);

	/**
	 * Updates a specific type of the Wounds
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the Wounds type updated to the new value }
	 * @param type specifies which Wounds type to update
	 * @param value the new value
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setWounds(int type, int value, bool notifyClient = true);

	/**
	 * @return returns wounds added
	 */
	int addWounds(int type, int value, bool notifyClient = true);

	/**
	 * Updates a specific type of the Max HAM
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the Max HAM type updated to the new value }
	 * @param type specifies which Max HAM type to update
	 * @param value the new value
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setMaxHAM(int type, int value, bool notifyClient = true);

	void addMaxHAM(int type, int value, bool notifyClient = true);

	/**
	 * Updates a specific type of the Encumbrance
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the Encumbrance type updated to the new value }
	 * @param type specifies which Encumbrance type to update
	 * @param value the new value
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setEncumbrance(int type, int value, bool notifyClient = true);

	void addEncumbrance(int type, int value, bool notifyClient = true);

	/**
	 * Updates the weapon to the specified object
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified weapon id }
	 * @param weao the new weapon
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setWeapon(WeaponObject* weao, bool notifyClient = false);

	/**
	 * Is called when this object has been inserted with an object
	 * @param object object that has been inserted
	 */
	int notifyObjectInserted(SceneObject* object);

	/**
	 * Is called when an object was removed
	 * @param object object that has been inserted
	 */
	int notifyObjectRemoved(SceneObject* object);

	/**
	 * Updates the instrument id to the specified object id
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified weapon id }
	 * @param instrumentid the new instrument id
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setInstrumentID(int instrumentid, bool notifyClient = true);

	/**
	 * Updates listen id
	 */
	void setListenToID(unsigned long long id, bool notifyClient = true);

	/**
	 * Updates the preformance counter
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the counter updated }
	 * @param counter new performance counter
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setPerformanceCounter(int counter, bool notifyClient = true);

	/**
	 * Updates the preformance animation string
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the animation updated }
	 * @param animation new animation
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setPerformanceAnimation(const String& animation, bool notifyClient = true);

	/**
	 * Updates shock wounds
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified target id }
	 * @param shock new shock wounds
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setShockWounds(int newShock, bool notifyClient = true);

	void addShockWounds(int shockToAdd, bool notiyClient = true);

	/**
	 * Updates the target id to the specified object id
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified target id }
	 * @param objectID the new target id
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setTargetID(unsigned long long targetID, bool notifyClient = true);

	/**
	 * Updates the bank credits of this object
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified bank credits }
	 * @param credits the new credits
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setBankCredits(int credits, bool notifyClient = true);

	/**
	 * Adds the buff to the creature, activating it and sending packets if it is a player.
	 * Buffs should never be added to the list without sending of packets.
	 * @param buff The Buff object to add the creature.
	 */
	void addBuff(Buff* buff);

	/**
	 * Removes the buff from the creature, activating it and sending packets if it is a player.
	 * Buffs should never be removed from the list without sending of packets.
	 * @param buffcrc The buff crc to remove from the buff list.
	 */
	bool removeBuff(unsigned int buffcrc);

	/**
	 * Removes the buff from the creature, activating it and sending packets if it is a player.
	 * Buffs should never be removed from the list without sending of packets.
	 * @param buffcrc The buff object to remove from the list.
	 */
	void removeBuff(Buff* buff);

	bool removeStateBuff(unsigned long long state);

	/**
	 * Removes all buffs from the creature, deactivating any currently active buffs.
	 * @param updateclient Should packets be sent to the player?
	 */
	void clearBuffs(bool updateclient);

	void addWearableObject(TangibleObject* object, bool notifyClient = true);

	void removeWearableObject(TangibleObject* object, bool notifyClient = true);

	WearablesDeltaVector* getWearablesDeltaVector();

	void sendBuffsTo(CreatureObject* creature);

	BuffList* getBuffList();

	Buff* getBuff(unsigned int buffcrc);

	long long getSkillModFromBuffs(const String& skillMod);

	int addDotState(unsigned long long dotType, unsigned long long objectID, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense, int secondaryStrength = 0);

	bool healDot(unsigned long long dotType, int reduction);

	void clearDots();

	DamageOverTimeList* getDamageOverTimeList();

	bool hasBuff(unsigned int buffcrc);

	void notifySelfPositionUpdate();

	void notifyPostureChange(int newPosture);

	void setLevel(int level);

	void updateToDatabaseAllObjects(bool startTask);

	bool isResuscitable();

	void addBankCredits(int credits, bool notifyClient = true);

	void addCashCredits(int credits, bool notifyClient = true);

	void subtractBankCredits(int credits);

	void subtractCashCredits(int credits);

	bool verifyCashCredits(int credits);

	bool verifyBankCredits(int credits);

	bool isDancing();

	bool isPlayingMusic();

	void stopEntertaining();

	bool isEntertaining();

	/**
	 * Update the cash credits of this object
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified cash credits }
	 * @param credits the new credits
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setCashCredits(int credits, bool notifyClient = true);

	/**
	 * Updates the terrain negotiation variable?
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified terrain negotiation }
	 * @param terrain new terrain negotiation
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setTerrainNegotiation(float value, bool notifyClient = true);

	/**
	 * Adds the specified skillbox to this object
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified skillbox in the delta vector
	 * @param skillbox skillbox to add
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void addSkill(Skill* skill, bool notifyClient = true);

	/**
	 * Adds the specified skillbox to this object
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified skillbox in the delta vector
	 * @param skillbox skillbox name to add
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void addSkill(const String& skill, bool notifyClient = true);

	/**
	 * Removes the specified skillbox from this object
	 * @pre { this object is locked }
	 * @post { this obejct is locked, skillbox is removed }
	 * @param skillBox skillBox to remove
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void removeSkill(Skill* skill, bool notifyClient = true);

	/**
	 * Removes the specified skillbox from this object
	 * @pre { this object is locked }
	 * @post { this obejct is locked, skillbox is removed }
	 * @param skillBox skillBox to remove
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void removeSkill(const String& skill, bool notifyClient = true);

	/**
	 * Adds new value to the specified skillmod (add a negative number to subtract)
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param skillMod skill mod to change
	 * @param value value to add/subtract
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void addSkillMod(const int modType, const String& skillMod, int value, bool notifyClient = true);

	/**
	 * Removes skill mod from the list (same as setting to 0)
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param skillMod skill mod to remove
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void removeSkillMod(const int modType, const String& skillMod, int value, bool notifyClient = true);

	void removeAllSkillModsOfType(const int modType, bool notifyClient = true);

	/**
	 * Sets a new group inviter id
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param id object id of the inviter
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void updateGroupInviterID(unsigned long long id, bool notifyClient = true);

	/**
	 * Sets the group of this object
	 * @pre { this object is locked }
	 * @post {this object is locked }
	 * @param group GroupObject to update
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void updateGroup(GroupObject* group, bool notifyClient = true);

	/**
	 * Enqueues a command action
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param actionCRC queue command crc
	 * @param actionCount command count
	 * @param targetID target
	 * @param arguments arguments
	 * @param priority command priority
	 */
	void enqueueCommand(unsigned int actionCRC, unsigned int actionCount, unsigned long long targetID, const UnicodeString& arguments, int priority = -1);

	/**
	 * Sets characters mood
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param moodID mood to set
	 */
	void setMood(byte moodID, bool notifyClient = true);

	/**
	 * Sets a new mood animation
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param mood mood animation string
	 */
	void setMoodString(const String& animation, bool notifyClient = true);

	/**
	 * Removes a command from queue
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param actionCount the action count to remove
	 */
	void deleteQueueAction(unsigned int actionCount);

	/**
	 * Sets a new state to the statebitmask
	 * @pre { this object is locked }
	 * @post { this object is locked, stateBitmask has the new state }
	 * @param state state to add
	 */
	bool setState(unsigned long long state, bool notifyClient = true);

	/**
	 * Cleares a state from the state bitmask
	 * @pre { this object is locked }
	 * @post { this object is locked, stateBitmask doesnt have the specified state }
	 * @param state state to clear
	 */
	bool clearState(unsigned long long state, bool notifyClient = true);

	void setControlDevice(ControlDevice* device);

	/**
	 * Updates creatureLinkID with specified object
	 * @pre { this is locked }
	 * @post { this is locked }
	 */
	void setCreatureLink(CreatureObject* object, bool notifyClient = true);

	/**
	 * Executes an object controller command
	 */
	void executeObjectControllerAction(unsigned int actionCRC);

	void executeObjectControllerAction(unsigned int actionCRC, unsigned long long targetID, const UnicodeString& args);

	/**
	 * Evaluates if this object can be attacket by the passed creature object
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return returns true if the creature object can attack this 
	 */
	bool isAttackableBy(CreatureObject* object);

	bool isAttackableBy(TangibleObject* attacker);

	bool isHealableBy(CreatureObject* object);

	/**
	 * Evaluates if the bounty hunter has a mission with the target.
	 * @param bountyHunter the bounty hunter.
	 * @param target the target.
	 * @return true if bounty hunter has a mission with the target.
	 */
	bool isInBountyMission(CreatureObject* bountyHunter, CreatureObject* target);

	/**
	 * sends the conversation list 
	 * @pre {this locked, player locked }
	 * @post { this locked, player locked }
	 */
	void sendConversationStartTo(SceneObject* player);

	/**
	 * sends the conversation list 
	 * @pre {this locked, player locked }
	 * @post { this locked, player locked }
	 */
	void selectConversationOption(int option, SceneObject* obj);

	/**
	 * Sends a message to client
	 * @pre { }
	 * @post { message is sent to client }
	 * @param msg BasePacket to send
	 */
	void sendMessage(BasePacket* msg);

	/**
	 * Sends a ExecuteConsoleCommand to the client
	 * @param command example "/attack"
	 */
	void sendExecuteConsoleCommand(const String& command);

	/**
	 * Evaluates if this creature is aggresive to the object
	 * @pre { }
	 * @post { }
	 * @return returns true if its aggressive
	 */
	bool isAggressiveTo(CreatureObject* object);

	/**
	 * Is called when this object is destroyed
	 * @pre { this, attacker locked }
	 * @post { this, attacker locked }
	 */
	int notifyObjectDestructionObservers(TangibleObject* attacker, int condition);

	/**
	 * Is called when this object is killed
	 * @pre { this, killer locked }
	 * @post { this, killer locked }
	 * @param killer The killer.
	 */
	int notifyObjectKillObservers(TangibleObject* killer);

	/**
	 * Gets called when this objects is loaded from database
	 * @pre { this locked }
	 * @post { this locked }
	 */
	void notifyLoadFromDatabase();

	void setFactionRank(int rank, bool notifyClient = true);

	String getFirstName();

	String getLastName();

	bool isOnline();

	bool canTreatInjuries();

	bool canTreatStates();

	bool canTreatWounds();

	bool canTreatConditions();

	Reference<PlayerObject* > getPlayerObject();

	AiActor* getActorObject();

	bool isListening();

	bool isWatching();

	void setClient(ZoneClientSession* cli);

	void dismount();

	float calculateBFRatio();

	void setDizziedState(int durationSeconds = 5);

	void setRalliedState(int durationSeconds = 5);

	void setAimingState(int durationSeconds = 5);

	void setCoverState(int durationSeconds = 40);

	void setBerserkedState(unsigned int duration);

	void setStunnedState(int durationSeconds = 5);

	void setBlindedState(int durationSeconds = 5);

	void setIntimidatedState(unsigned int mod, int durationSeconds = 15);

	void setSnaredState(int durationSeconds = 20);

	void setRootedState(int durationSeconds = 20);

	bool setNextAttackDelay(unsigned int mod, int del);

	void setMeditateState();

	void activateHAMRegeneration();

	void activatePassiveWoundRegeneration();

	void activateStateRecovery();

	void updateTimeOfDeath();

	bool hasAttackDelay();

	void removeAttackDelay();

	CooldownTimerMap* getCooldownTimerMap();

	bool hasSpice();

	void updateLastSuccessfulCombatAction();

	void updateKnockdownRecovery();

	void queueDizzyFallEvent();

	void updateLastKnockdown();

	bool checkKnockdownRecovery();

	bool checkLastKnockdown();

	void updatePostureDownRecovery();

	void updatePostureUpRecovery();

	bool checkPostureDownRecovery();

	unsigned long long getScreenPlayState(const String& screenPlay);

	void setScreenPlayState(const String& screenPlay, unsigned long long state);

	bool checkPostureUpRecovery();

	void updateCooldownTimer(const String& coooldownTimer, unsigned int miliSecondsToAdd = 0);

	bool checkCooldownRecovery(const String& cooldown);

	Time* getCooldownTime(const String& cooldown);

	void addCooldown(const String& name, unsigned int miliseconds);

	void doAnimation(const String& animation);

	void doCombatAnimation(CreatureObject* defender, unsigned int animationCRC, byte hit, byte trails);

	void playEffect(const String& file, const String& aux);

	void playEffect(const String& file);

	void activateQueueAction();

	void activateImmediateAction();

	UnicodeString getCreatureName();

	bool isGrouped();

	int getBankCredits();

	int getCashCredits();

	int getBaseHAM(int idx);

	int getWounds(int idx);

	DeltaVector<int>* getWounds();

	int getHAM(int idx);

	DeltaVector<int>* getHAM();

	int getMaxHAM(int idx);

	DeltaVector<int>* getMaxHAM();

	int getEncumbrance(int idx);

	DeltaVector<int>* getEncumbrances();

	byte getPosture();

	byte getLocomotion();

	byte getFactionRank();

	ManagedWeakReference<CreatureObject* > getLinkedCreature();

	unsigned long long getCreatureLinkID();

	float getShockWounds();

	unsigned long long getWatchToID();

	unsigned long long getStateBitmask();

	bool hasState(unsigned long long state);

	bool hasStates();

	unsigned long long getListenID();

	float getAccelerationMultiplierBase();

	float getAccelerationMultiplierMod();

	float getSpeedMultiplierBase();

	float getSpeedMultiplierMod();

	float getCurrentSpeed();

	SpeedMultiplierModChanges* getSpeedMultiplierModChanges();

	CommandQueueActionVector* getCommandQueue();

	float getRunSpeed();

	float getWalkSpeed();

	float getTurnScale();

	float getTerrainNegotiation();

	float getRunAcceleration();

	float getWalkAcceleration();

	String getPerformanceAnimation();

	String getMoodString();

	unsigned long long getWeaponID();

	Reference<WeaponObject* > getWeapon();

	Reference<GuildObject* > getGuildObject();

	int getGuildID();

	bool isInGuild();

	void setGuildObject(GuildObject* guildobj);

	unsigned long long getGroupID();

	unsigned long long getGroupInviterID();

	GroupObject* getGroup();

	unsigned long long getGroupInviteCounter();

	unsigned long long getTargetID();

	byte getMoodID();

	float getSlopeModPercent();

	int getPerformanceCounter();

	int getInstrumentID();

	byte getFrozen();

	float getHeight();

	int getSpecies();

	String getSpeciesName();

	int getGender();

	DeltaVector<int>* getBaseHAM();

	SkillList* getSkillList();

	int getSkillMod(const String& skillmod);

	bool hasSkill(const String& skill);

	SkillModList* getSkillModList();

	void setWatchToID(unsigned long long id);

	bool isCreatureObject();

	bool isNextActionPast();

	bool isTrainerCreature();

	bool isSwimming();

	ZoneClientSession* getClient();

	bool isRidingMount();

	ManagedWeakReference<ControlDevice* > getControlDevice();

	float getSwimHeight();

	bool isIncapacitated();

	bool isDead();

	bool isKnockedDown();

	bool isKneeling();

	bool isProne();

	bool isStanding();

	bool isSitting();

	bool isSkillAnimating();

	bool isRallied();

	bool isInCombat();

	bool isDizzied();

	bool isBerserked();

	bool isStunned();

	bool isBlinded();

	bool isIntimidated();

	bool isSnared();

	bool isImmobilized();

	bool isRooted();

	bool isFrozen();

	bool isDiseased();

	bool isPoisoned();

	bool isBleeding();

	bool isOnFire();

	bool isMounted();

	bool isRidingCreature();

	bool isPeaced();

	bool isMeditating();

	bool isAiming();

	bool isInCover();

	bool isRunning();

	bool isNonPlayerCreatureObject();

	bool isCreature();

	bool isPlayerCreature();

	bool isAiActor();

	bool isInformantCreature();

	CampSiteActiveArea* getCurrentCamp();

	byte getCurrentWeather();

	void setCurrentWeather(byte value);

	byte getCurrentWind();

	void setCurrentWind(byte value);

	int handleObjectMenuSelect(CreatureObject* player, byte selectedID);

	void fillAttributeList(AttributeListMessage* msg, CreatureObject* object);

	void destroyObjectFromWorld(bool sendSelfDestroy);

	bool isInvisible();

	void setInvisible(bool invis);

	Mutex* getSkillModMutex();

	float calculateCostAdjustment(byte stat, float baseCost);

	void updateSpeedAndAccelerationMods();

	DistributedObjectServant* _getImplementation();
	DistributedObjectServant* _getImplementationForRead();

	void _setImplementation(DistributedObjectServant* servant);

protected:
	CreatureObject(DummyConstructorParameter* param);

	virtual ~CreatureObject();

	friend class CreatureObjectHelper;
};

} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature;

namespace server {
namespace zone {
namespace objects {
namespace creature {

class CreatureObjectImplementation : public TangibleObjectImplementation {
protected:
	ManagedReference<ZoneClientSession* > owner;

	int bankCredits;

	int cashCredits;

	int gender;

	int species;

	DeltaVector<int> baseHAM;

	byte posture;

	byte locomotion;

	byte factionRank;

	bool invisible;

	ManagedWeakReference<CreatureObject* > linkedCreature;

	ManagedWeakReference<ControlDevice* > controlDevice;

	float shockWounds;

	DeltaVector<int> wounds;

	unsigned long long stateBitmask;

	DeltaVector<int> encumbrances;

	WearablesDeltaVector wearablesVector;

	float accelerationMultiplierBase;

	float accelerationMultiplierMod;

	float speedMultiplierBase;

	SpeedMultiplierModChanges speedMultiplierModChanges;

	float speedMultiplierMod;

	float turnScale;

	float runSpeed;

	float walkSpeed;

	float currentSpeed;

	float terrainNegotiation;

	float runAcceleration;

	float walkAcceleration;

	float height;

	float swimHeight;

	float slopeModPercent;

	float slopeModAngle;

	unsigned long long listenToID;

	unsigned long long watchToID;

	String performanceAnimation;

	String moodString;

	ManagedReference<WeaponObject* > weapon;

	ManagedReference<GroupObject* > group;

	unsigned long long groupInviterID;

	unsigned long long groupInviteCounter;

	ManagedReference<GuildObject* > guild;

	unsigned long long targetID;

	byte moodID;

	int performanceCounter;

	int instrumentID;

	DeltaVector<int> hamList;

	DeltaVector<int> maxHamList;

	byte frozen;

	String templateString;

	SkillList skillList;

	SkillModList skillModList;

	Mutex skillModMutex;

	Reference<CommandQueueActionVector* > commandQueue;

	Reference<CommandQueueActionVector* > immediateQueue;

	Time nextAction;

	Reference<CooldownTimerMap* > cooldownTimerMap;

	BuffList creatureBuffs;

	DamageOverTimeList damageOverTimeList;

	Time lastSuccessfulCombatAction;

	Time timeOfDeath;

	VectorMap<String, unsigned long long> screenPlayStates;

	byte healthWoundHeal;

	byte actionWoundHeal;

	byte mindWoundHeal;

	byte currentWeather;

	byte currentWind;

	Time lastCombatActionTime;

	Vector3 lastCombatPosition;

public:
	static const int HUMAN = 0;

	static const int RODIAN = 1;

	static const int TRANDOSHAN = 2;

	static const int MONCAL = 3;

	static const int WOOKIE = 4;

	static const int BOTHAN = 5;

	static const int TWILEK = 6;

	static const int ZABRAK = 7;

	static const int ITHORIAN = 0x21;

	static const int SULLUSTAN = 0x31;

	static const int MALE = 0;

	static const int FEMALE = 1;

	static float DEFAULTRUNSPEED;

	unsigned static const long long DEAD_TOO_LONG = 1800000;

	CreatureObjectImplementation();

	CreatureObjectImplementation(DummyConstructorParameter* param);

	void initializeMembers();

	void finalize();

	void createChildObjects();

	/**
	 * Reads and sets the template data from a SharedTangibleObjectTemplate LuaObject
	 * @pre { templateData is a valid pointer }
	 * @post { TangibleObject members are initialized }
	 * @param templateData templateData points to the SharedTangibleObjectTemplate LuaObject that is used to initialize the TangibleObject members
	 */
	void loadTemplateData(SharedObjectTemplate* templateData);

	/**
	 * Initializes the transient members of SceneObject, must call the inherited object method first.
	 * @pre {transient members are not initialized }
	 * @post { transient members are initialized }
	 */
	void initializeTransientMembers();

	/**
	 * Sends a CommandQueueRemove ObjectControllerMessage to the owner client of this object
	 * @pre { }
	 * @post { client received the CommandQueueRemove message }
	 * @param actioncntr action id that will be cleared from clients queue
	 * @param timer how many seconds will the action take to execute
	 * @param tab1 message 1
	 * @param tab2 message 2 
	 */
	void clearQueueAction(unsigned int actioncntr, float timer = 0, unsigned int tab1 = 0, unsigned int tab2 = 0);

	/**
	 * Sends the CREO baseline messages of this object to the specified player
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the baseline messages }
	 * @param player SceneObject that will receive the baselines 
	 */
	void sendBaselinesTo(SceneObject* player);

	/**
	 * Sends the necessary messages to owner client
	 * @pre { this object is locked }
	 * @post { this object is locked, owner received its own scene object }
	 * @param doClose if true a SceneObjectCloseMessage is sent to finish the object
	 */
	void sendToOwner(bool doClose = true);

	/**
	 * Sends the necessary messages to player in order to create this object
	 * @pre { this object is locked }
	 * @post { this object is locked, player received this object }
	 * @param player SceneObject that will receive the messages
	 * @param doClose if true a SceneObjectCloseMessage is sent to finish the object
	 */
	void sendTo(SceneObject* player, bool doClose);

	/**
	 * Sends a system message to the client of this object
	 * @pre {}
	 * @post { this object received the message }
	 * @param message string message to send
	 */
	void sendSystemMessage(const String& message);

	/**
	 * Sends a PlayMusicMessage
	 */
	void playMusicMessage(const String& file);

	/**
	 * Sends a tutorial request
	 */
	void sendNewbieTutorialRequest(const String& request);

	/**
	 * Sends NewbieTutorialEnableHud
	 */
	void sendNewbieTutorialEnableHudElement(const String& ui, bool enable = true);

	void sendOpenHolocronToPageMessage();

	/**
	 * Sends a system message to the client of this object
	 * @pre {}
	 * @post { this object received the message }
	 * @param message unicode message to send
	 */
	void sendSystemMessage(UnicodeString& message);

	/**
	 * Sends a system message to the client of this object
	 * @pre {}
	 * @post { this object received the message }
	 * @param message StringIdChatParameter message to send
	 */
	void sendSystemMessage(StringIdChatParameter& stringid);

	/**
	 * Sends the contained slotted objects to the specified player
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the slotted objects }
	 * @param player SceneObject that will receive the objects 
	 */
	void sendSlottedObjectsTo(SceneObject* player);

	/**
	 * Sets the combat state
	 * @pre { this object is locked }
	 * @post { this object is locked, this object is in a combat state }
	 */
	void setCombatState();

	/**
	 * Cleares the combat state
	 * @pre { this object is locked }
	 * @post { this object is locked, this object is not in a combat state }
	 * @param clearDefenders if true the defender vector willl be emptied
	 */
	void clearCombatState(bool clearDefenders = true);

	/**
	 * Sets a new posture
	 * @pre { this object is locked }
	 * @post {this object is locked, this object has the new posture set }
	 * @param newPosture posture to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	virtual void setPosture(int newPosture, bool notifyClient = true);

	/**
	 * checks locomotion and sets a new one if appropriate
	 * @pre { this object is locked }
	 * @post {this object is locked, this object has the new locomotion set, if appropriate }
	 */
	float calculateSpeed();

	virtual void updateLocomotion();

	void setHeight(float heigh, bool notifyClient = true);

	/**
	 * Updates the acceleration speed multiplier base
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param newMultiplierBase new multiplier base to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setAccelerationMultiplierBase(float newMultiplierBase, bool notifyClient = true);

	/**
	 * Updates the acceleration speed multiplier mod
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param newMultiplierMod new multiplier mod to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setAccelerationMultiplierMod(float newMultiplierMod, bool notifyClient = true);

	/**
	 * Updates the speed multiplier base
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param newMultiplierBase new multiplier base to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setSpeedMultiplierBase(float newMultiplierBase, bool notifyClient = true);

	/**
	 * Updates the speed multiplier mod
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param newMultiplierMod new multiplier mod to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	virtual void setSpeedMultiplierMod(float newMultiplierMod, bool notifyClient = true);

	/**
	 * Updates the turn scale mod
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param newMultiplierMod new multiplier mod to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	virtual void setTurnScale(float newMultiplierMod, bool notifyClient = true);

	/**
	 * Updates the run speed
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * 
	 */
	void setRunSpeed(float newSpeed, bool notifyClient = true);

	void setCurrentSpeed(float newSpeed);

	/**
	 * Updates a specific type of the HAM
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the HAM type updated to the new value }
	 * @param type specifies which HAM type to update
	 * @param value the new value
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setHAM(int type, int value, bool notifyClient = true);

	/**
	 * Inflicts damage into the object
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return unused for now
	 */
	int inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, bool notifyClient = true);

	int inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, const String& xp, bool notifyClient = true);

	bool hasDamage(int attribute);

	/**
	 * Heals damage
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return unused for now
	 */
	int healDamage(TangibleObject* healer, int damageType, int damage, bool notifyClient = true, bool notifyObservers = true);

	/**
	 * Heals wound
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return unused for now
	 */
	int healWound(TangibleObject* healer, int damageType, int damage, bool notifyClient = true, bool notifyObservers = true);

	/**
	 * Updates a specific type of the Base HAM
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the Base HAM type updated to the new value }
	 * @param type specifies which Base HAM type to update
	 * @param value the new value
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setBaseHAM(int type, int value, bool notifyClient = true);

	/**
	 * Updates a specific type of the Wounds
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the Wounds type updated to the new value }
	 * @param type specifies which Wounds type to update
	 * @param value the new value
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setWounds(int type, int value, bool notifyClient = true);

	/**
	 * @return returns wounds added
	 */
	int addWounds(int type, int value, bool notifyClient = true);

	/**
	 * Updates a specific type of the Max HAM
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the Max HAM type updated to the new value }
	 * @param type specifies which Max HAM type to update
	 * @param value the new value
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setMaxHAM(int type, int value, bool notifyClient = true);

	void addMaxHAM(int type, int value, bool notifyClient = true);

	/**
	 * Updates a specific type of the Encumbrance
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the Encumbrance type updated to the new value }
	 * @param type specifies which Encumbrance type to update
	 * @param value the new value
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setEncumbrance(int type, int value, bool notifyClient = true);

	void addEncumbrance(int type, int value, bool notifyClient = true);

	/**
	 * Updates the weapon to the specified object
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified weapon id }
	 * @param weao the new weapon
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setWeapon(WeaponObject* weao, bool notifyClient = false);

	/**
	 * Is called when this object has been inserted with an object
	 * @param object object that has been inserted
	 */
	int notifyObjectInserted(SceneObject* object);

	/**
	 * Is called when an object was removed
	 * @param object object that has been inserted
	 */
	int notifyObjectRemoved(SceneObject* object);

	/**
	 * Updates the instrument id to the specified object id
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified weapon id }
	 * @param instrumentid the new instrument id
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setInstrumentID(int instrumentid, bool notifyClient = true);

	/**
	 * Updates listen id
	 */
	void setListenToID(unsigned long long id, bool notifyClient = true);

	/**
	 * Updates the preformance counter
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the counter updated }
	 * @param counter new performance counter
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setPerformanceCounter(int counter, bool notifyClient = true);

	/**
	 * Updates the preformance animation string
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the animation updated }
	 * @param animation new animation
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setPerformanceAnimation(const String& animation, bool notifyClient = true);

	/**
	 * Updates shock wounds
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified target id }
	 * @param shock new shock wounds
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setShockWounds(int newShock, bool notifyClient = true);

	void addShockWounds(int shockToAdd, bool notiyClient = true);

	/**
	 * Updates the target id to the specified object id
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified target id }
	 * @param objectID the new target id
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setTargetID(unsigned long long targetID, bool notifyClient = true);

	/**
	 * Updates the bank credits of this object
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified bank credits }
	 * @param credits the new credits
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setBankCredits(int credits, bool notifyClient = true);

	/**
	 * Adds the buff to the creature, activating it and sending packets if it is a player.
	 * Buffs should never be added to the list without sending of packets.
	 * @param buff The Buff object to add the creature.
	 */
	void addBuff(Buff* buff);

	/**
	 * Removes the buff from the creature, activating it and sending packets if it is a player.
	 * Buffs should never be removed from the list without sending of packets.
	 * @param buffcrc The buff crc to remove from the buff list.
	 */
	bool removeBuff(unsigned int buffcrc);

	/**
	 * Removes the buff from the creature, activating it and sending packets if it is a player.
	 * Buffs should never be removed from the list without sending of packets.
	 * @param buffcrc The buff object to remove from the list.
	 */
	void removeBuff(Buff* buff);

	bool removeStateBuff(unsigned long long state);

	/**
	 * Removes all buffs from the creature, deactivating any currently active buffs.
	 * @param updateclient Should packets be sent to the player?
	 */
	void clearBuffs(bool updateclient);

	void addWearableObject(TangibleObject* object, bool notifyClient = true);

	void removeWearableObject(TangibleObject* object, bool notifyClient = true);

	WearablesDeltaVector* getWearablesDeltaVector();

	void sendBuffsTo(CreatureObject* creature);

	BuffList* getBuffList();

	Buff* getBuff(unsigned int buffcrc);

	long long getSkillModFromBuffs(const String& skillMod);

	int addDotState(unsigned long long dotType, unsigned long long objectID, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense, int secondaryStrength = 0);

	bool healDot(unsigned long long dotType, int reduction);

	void clearDots();

	DamageOverTimeList* getDamageOverTimeList();

	bool hasBuff(unsigned int buffcrc);

	void notifySelfPositionUpdate();

	void notifyPostureChange(int newPosture);

	void setLevel(int level);

	void updateToDatabaseAllObjects(bool startTask);

	bool isResuscitable();

	void addBankCredits(int credits, bool notifyClient = true);

	void addCashCredits(int credits, bool notifyClient = true);

	void subtractBankCredits(int credits);

	void subtractCashCredits(int credits);

	bool verifyCashCredits(int credits);

	bool verifyBankCredits(int credits);

	bool isDancing();

	bool isPlayingMusic();

	void stopEntertaining();

	bool isEntertaining();

	/**
	 * Update the cash credits of this object
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified cash credits }
	 * @param credits the new credits
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setCashCredits(int credits, bool notifyClient = true);

	/**
	 * Updates the terrain negotiation variable?
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified terrain negotiation }
	 * @param terrain new terrain negotiation
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setTerrainNegotiation(float value, bool notifyClient = true);

	/**
	 * Adds the specified skillbox to this object
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified skillbox in the delta vector
	 * @param skillbox skillbox to add
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void addSkill(Skill* skill, bool notifyClient = true);

	/**
	 * Adds the specified skillbox to this object
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified skillbox in the delta vector
	 * @param skillbox skillbox name to add
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void addSkill(const String& skill, bool notifyClient = true);

	/**
	 * Removes the specified skillbox from this object
	 * @pre { this object is locked }
	 * @post { this obejct is locked, skillbox is removed }
	 * @param skillBox skillBox to remove
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void removeSkill(Skill* skill, bool notifyClient = true);

	/**
	 * Removes the specified skillbox from this object
	 * @pre { this object is locked }
	 * @post { this obejct is locked, skillbox is removed }
	 * @param skillBox skillBox to remove
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void removeSkill(const String& skill, bool notifyClient = true);

	/**
	 * Adds new value to the specified skillmod (add a negative number to subtract)
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param skillMod skill mod to change
	 * @param value value to add/subtract
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void addSkillMod(const int modType, const String& skillMod, int value, bool notifyClient = true);

	/**
	 * Removes skill mod from the list (same as setting to 0)
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param skillMod skill mod to remove
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void removeSkillMod(const int modType, const String& skillMod, int value, bool notifyClient = true);

	void removeAllSkillModsOfType(const int modType, bool notifyClient = true);

	/**
	 * Sets a new group inviter id
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param id object id of the inviter
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void updateGroupInviterID(unsigned long long id, bool notifyClient = true);

	/**
	 * Sets the group of this object
	 * @pre { this object is locked }
	 * @post {this object is locked }
	 * @param group GroupObject to update
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void updateGroup(GroupObject* group, bool notifyClient = true);

	/**
	 * Enqueues a command action
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param actionCRC queue command crc
	 * @param actionCount command count
	 * @param targetID target
	 * @param arguments arguments
	 * @param priority command priority
	 */
	void enqueueCommand(unsigned int actionCRC, unsigned int actionCount, unsigned long long targetID, const UnicodeString& arguments, int priority = -1);

	/**
	 * Sets characters mood
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param moodID mood to set
	 */
	void setMood(byte moodID, bool notifyClient = true);

	/**
	 * Sets a new mood animation
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param mood mood animation string
	 */
	void setMoodString(const String& animation, bool notifyClient = true);

	/**
	 * Removes a command from queue
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param actionCount the action count to remove
	 */
	void deleteQueueAction(unsigned int actionCount);

	/**
	 * Sets a new state to the statebitmask
	 * @pre { this object is locked }
	 * @post { this object is locked, stateBitmask has the new state }
	 * @param state state to add
	 */
	bool setState(unsigned long long state, bool notifyClient = true);

	/**
	 * Cleares a state from the state bitmask
	 * @pre { this object is locked }
	 * @post { this object is locked, stateBitmask doesnt have the specified state }
	 * @param state state to clear
	 */
	bool clearState(unsigned long long state, bool notifyClient = true);

	void setControlDevice(ControlDevice* device);

	/**
	 * Updates creatureLinkID with specified object
	 * @pre { this is locked }
	 * @post { this is locked }
	 */
	void setCreatureLink(CreatureObject* object, bool notifyClient = true);

	/**
	 * Executes an object controller command
	 */
	void executeObjectControllerAction(unsigned int actionCRC);

	void executeObjectControllerAction(unsigned int actionCRC, unsigned long long targetID, const UnicodeString& args);

	/**
	 * Evaluates if this object can be attacket by the passed creature object
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return returns true if the creature object can attack this 
	 */
	bool isAttackableBy(CreatureObject* object);

	bool isAttackableBy(TangibleObject* attacker);

	bool isHealableBy(CreatureObject* object);

	/**
	 * Evaluates if the bounty hunter has a mission with the target.
	 * @param bountyHunter the bounty hunter.
	 * @param target the target.
	 * @return true if bounty hunter has a mission with the target.
	 */
	bool isInBountyMission(CreatureObject* bountyHunter, CreatureObject* target);

	/**
	 * sends the conversation list 
	 * @pre {this locked, player locked }
	 * @post { this locked, player locked }
	 */
	virtual void sendConversationStartTo(SceneObject* player);

	/**
	 * sends the conversation list 
	 * @pre {this locked, player locked }
	 * @post { this locked, player locked }
	 */
	virtual void selectConversationOption(int option, SceneObject* obj);

	/**
	 * Sends a message to client
	 * @pre { }
	 * @post { message is sent to client }
	 * @param msg BasePacket to send
	 */
	void sendMessage(BasePacket* msg);

	/**
	 * Sends a ExecuteConsoleCommand to the client
	 * @param command example "/attack"
	 */
	void sendExecuteConsoleCommand(const String& command);

	/**
	 * Evaluates if this creature is aggresive to the object
	 * @pre { }
	 * @post { }
	 * @return returns true if its aggressive
	 */
	bool isAggressiveTo(CreatureObject* object);

	/**
	 * Is called when this object is destroyed
	 * @pre { this, attacker locked }
	 * @post { this, attacker locked }
	 */
	int notifyObjectDestructionObservers(TangibleObject* attacker, int condition);

	/**
	 * Is called when this object is killed
	 * @pre { this, killer locked }
	 * @post { this, killer locked }
	 * @param killer The killer.
	 */
	int notifyObjectKillObservers(TangibleObject* killer);

	/**
	 * Gets called when this objects is loaded from database
	 * @pre { this locked }
	 * @post { this locked }
	 */
	void notifyLoadFromDatabase();

	void setFactionRank(int rank, bool notifyClient = true);

	String getFirstName();

	String getLastName();

	bool isOnline();

	bool canTreatInjuries();

	bool canTreatStates();

	bool canTreatWounds();

	bool canTreatConditions();

	Reference<PlayerObject* > getPlayerObject();

	AiActor* getActorObject();

	bool isListening();

	bool isWatching();

	void setClient(ZoneClientSession* cli);

	void dismount();

	float calculateBFRatio();

	void setDizziedState(int durationSeconds = 5);

	void setRalliedState(int durationSeconds = 5);

	void setAimingState(int durationSeconds = 5);

	void setCoverState(int durationSeconds = 40);

	void setBerserkedState(unsigned int duration);

	void setStunnedState(int durationSeconds = 5);

	void setBlindedState(int durationSeconds = 5);

	void setIntimidatedState(unsigned int mod, int durationSeconds = 15);

	void setSnaredState(int durationSeconds = 20);

	void setRootedState(int durationSeconds = 20);

	bool setNextAttackDelay(unsigned int mod, int del);

	void setMeditateState();

	virtual void activateHAMRegeneration();

	virtual void activatePassiveWoundRegeneration();

	virtual void activateStateRecovery();

	void updateTimeOfDeath();

	bool hasAttackDelay();

	void removeAttackDelay();

	CooldownTimerMap* getCooldownTimerMap();

	bool hasSpice();

	void updateLastSuccessfulCombatAction();

	void updateKnockdownRecovery();

	virtual void queueDizzyFallEvent();

	void updateLastKnockdown();

	bool checkKnockdownRecovery();

	bool checkLastKnockdown();

	void updatePostureDownRecovery();

	void updatePostureUpRecovery();

	bool checkPostureDownRecovery();

	unsigned long long getScreenPlayState(const String& screenPlay);

	void setScreenPlayState(const String& screenPlay, unsigned long long state);

	bool checkPostureUpRecovery();

	void updateCooldownTimer(const String& coooldownTimer, unsigned int miliSecondsToAdd = 0);

	bool checkCooldownRecovery(const String& cooldown);

	Time* getCooldownTime(const String& cooldown);

	void addCooldown(const String& name, unsigned int miliseconds);

	void doAnimation(const String& animation);

	void doCombatAnimation(CreatureObject* defender, unsigned int animationCRC, byte hit, byte trails);

	void playEffect(const String& file, const String& aux);

	void playEffect(const String& file);

	void activateQueueAction();

	void activateImmediateAction();

	UnicodeString getCreatureName();

	bool isGrouped();

	int getBankCredits();

	int getCashCredits();

	int getBaseHAM(int idx);

	int getWounds(int idx);

	DeltaVector<int>* getWounds();

	int getHAM(int idx);

	DeltaVector<int>* getHAM();

	int getMaxHAM(int idx);

	DeltaVector<int>* getMaxHAM();

	int getEncumbrance(int idx);

	DeltaVector<int>* getEncumbrances();

	byte getPosture();

	byte getLocomotion();

	byte getFactionRank();

	ManagedWeakReference<CreatureObject* > getLinkedCreature();

	unsigned long long getCreatureLinkID();

	float getShockWounds();

	unsigned long long getWatchToID();

	unsigned long long getStateBitmask();

	bool hasState(unsigned long long state);

	bool hasStates();

	unsigned long long getListenID();

	float getAccelerationMultiplierBase();

	float getAccelerationMultiplierMod();

	float getSpeedMultiplierBase();

	float getSpeedMultiplierMod();

	float getCurrentSpeed();

	SpeedMultiplierModChanges* getSpeedMultiplierModChanges();

	CommandQueueActionVector* getCommandQueue();

	float getRunSpeed();

	float getWalkSpeed();

	float getTurnScale();

	float getTerrainNegotiation();

	float getRunAcceleration();

	float getWalkAcceleration();

	String getPerformanceAnimation();

	String getMoodString();

	unsigned long long getWeaponID();

	Reference<WeaponObject* > getWeapon();

	Reference<GuildObject* > getGuildObject();

	int getGuildID();

	bool isInGuild();

	void setGuildObject(GuildObject* guildobj);

	unsigned long long getGroupID();

	unsigned long long getGroupInviterID();

	GroupObject* getGroup();

	unsigned long long getGroupInviteCounter();

	unsigned long long getTargetID();

	byte getMoodID();

	float getSlopeModPercent();

	int getPerformanceCounter();

	int getInstrumentID();

	byte getFrozen();

	float getHeight();

	int getSpecies();

	String getSpeciesName();

	int getGender();

	DeltaVector<int>* getBaseHAM();

	SkillList* getSkillList();

	int getSkillMod(const String& skillmod);

	bool hasSkill(const String& skill);

	SkillModList* getSkillModList();

	void setWatchToID(unsigned long long id);

	bool isCreatureObject();

	bool isNextActionPast();

	virtual bool isTrainerCreature();

	bool isSwimming();

	ZoneClientSession* getClient();

	bool isRidingMount();

	ManagedWeakReference<ControlDevice* > getControlDevice();

	float getSwimHeight();

	bool isIncapacitated();

	bool isDead();

	bool isKnockedDown();

	bool isKneeling();

	bool isProne();

	bool isStanding();

	bool isSitting();

	bool isSkillAnimating();

	bool isRallied();

	bool isInCombat();

	bool isDizzied();

	bool isBerserked();

	bool isStunned();

	bool isBlinded();

	bool isIntimidated();

	bool isSnared();

	bool isImmobilized();

	bool isRooted();

	bool isFrozen();

	bool isDiseased();

	bool isPoisoned();

	bool isBleeding();

	bool isOnFire();

	bool isMounted();

	bool isRidingCreature();

	bool isPeaced();

	bool isMeditating();

	bool isAiming();

	bool isInCover();

	bool isRunning();

	virtual bool isNonPlayerCreatureObject();

	virtual bool isCreature();

	bool isPlayerCreature();

	bool isAiActor();

	virtual bool isInformantCreature();

	CampSiteActiveArea* getCurrentCamp();

	byte getCurrentWeather();

	void setCurrentWeather(byte value);

	byte getCurrentWind();

	void setCurrentWind(byte value);

	int handleObjectMenuSelect(CreatureObject* player, byte selectedID);

	void fillAttributeList(AttributeListMessage* msg, CreatureObject* object);

	void destroyObjectFromWorld(bool sendSelfDestroy);

	bool isInvisible();

	void setInvisible(bool invis);

	Mutex* getSkillModMutex();

	float calculateCostAdjustment(byte stat, float baseCost);

	void updateSpeedAndAccelerationMods();

	WeakReference<CreatureObject*> _this;

	operator const CreatureObject*();

	DistributedObjectStub* _getStub();
	virtual void readObject(ObjectInputStream* stream);
	virtual void writeObject(ObjectOutputStream* stream);
protected:
	virtual ~CreatureObjectImplementation();

	void _initializeImplementation();

	void _setStub(DistributedObjectStub* stub);

	void lock(bool doLock = true);

	void lock(ManagedObject* obj);

	void rlock(bool doLock = true);

	void wlock(bool doLock = true);

	void wlock(ManagedObject* obj);

	void unlock(bool doLock = true);

	void runlock(bool doLock = true);

	void _serializationHelperMethod();
	bool readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode);
	int writeObjectMembers(ObjectOutputStream* stream);

	friend class CreatureObject;
};

class CreatureObjectAdapter : public TangibleObjectAdapter {
public:
	CreatureObjectAdapter(CreatureObject* impl);

	void invokeMethod(sys::uint32 methid, DistributedMethod* method);

	void initializeMembers();

	void finalize();

	void createChildObjects();

	void initializeTransientMembers();

	void clearQueueAction(unsigned int actioncntr, float timer, unsigned int tab1, unsigned int tab2);

	void sendBaselinesTo(SceneObject* player);

	void sendToOwner(bool doClose);

	void sendTo(SceneObject* player, bool doClose);

	void sendSystemMessage(const String& message);

	void playMusicMessage(const String& file);

	void sendNewbieTutorialRequest(const String& request);

	void sendNewbieTutorialEnableHudElement(const String& ui, bool enable);

	void sendOpenHolocronToPageMessage();

	void sendSystemMessage(UnicodeString& message);

	void sendSlottedObjectsTo(SceneObject* player);

	void setCombatState();

	void clearCombatState(bool clearDefenders);

	void setPosture(int newPosture, bool notifyClient);

	float calculateSpeed();

	void updateLocomotion();

	void setHeight(float heigh, bool notifyClient);

	void setAccelerationMultiplierBase(float newMultiplierBase, bool notifyClient);

	void setAccelerationMultiplierMod(float newMultiplierMod, bool notifyClient);

	void setSpeedMultiplierBase(float newMultiplierBase, bool notifyClient);

	void setSpeedMultiplierMod(float newMultiplierMod, bool notifyClient);

	void setTurnScale(float newMultiplierMod, bool notifyClient);

	void setRunSpeed(float newSpeed, bool notifyClient);

	void setCurrentSpeed(float newSpeed);

	void setHAM(int type, int value, bool notifyClient);

	int inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, bool notifyClient);

	int inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, const String& xp, bool notifyClient);

	bool hasDamage(int attribute);

	int healDamage(TangibleObject* healer, int damageType, int damage, bool notifyClient, bool notifyObservers);

	int healWound(TangibleObject* healer, int damageType, int damage, bool notifyClient, bool notifyObservers);

	void setBaseHAM(int type, int value, bool notifyClient);

	void setWounds(int type, int value, bool notifyClient);

	int addWounds(int type, int value, bool notifyClient);

	void setMaxHAM(int type, int value, bool notifyClient);

	void addMaxHAM(int type, int value, bool notifyClient);

	void setEncumbrance(int type, int value, bool notifyClient);

	void addEncumbrance(int type, int value, bool notifyClient);

	void setWeapon(WeaponObject* weao, bool notifyClient);

	int notifyObjectInserted(SceneObject* object);

	int notifyObjectRemoved(SceneObject* object);

	void setInstrumentID(int instrumentid, bool notifyClient);

	void setListenToID(unsigned long long id, bool notifyClient);

	void setPerformanceCounter(int counter, bool notifyClient);

	void setPerformanceAnimation(const String& animation, bool notifyClient);

	void setShockWounds(int newShock, bool notifyClient);

	void addShockWounds(int shockToAdd, bool notiyClient);

	void setTargetID(unsigned long long targetID, bool notifyClient);

	void setBankCredits(int credits, bool notifyClient);

	void addBuff(Buff* buff);

	bool removeBuff(unsigned int buffcrc);

	void removeBuff(Buff* buff);

	bool removeStateBuff(unsigned long long state);

	void clearBuffs(bool updateclient);

	void addWearableObject(TangibleObject* object, bool notifyClient);

	void removeWearableObject(TangibleObject* object, bool notifyClient);

	void sendBuffsTo(CreatureObject* creature);

	Buff* getBuff(unsigned int buffcrc);

	long long getSkillModFromBuffs(const String& skillMod);

	int addDotState(unsigned long long dotType, unsigned long long objectID, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense, int secondaryStrength);

	bool healDot(unsigned long long dotType, int reduction);

	void clearDots();

	bool hasBuff(unsigned int buffcrc);

	void notifySelfPositionUpdate();

	void notifyPostureChange(int newPosture);

	void setLevel(int level);

	void updateToDatabaseAllObjects(bool startTask);

	bool isResuscitable();

	void addBankCredits(int credits, bool notifyClient);

	void addCashCredits(int credits, bool notifyClient);

	void subtractBankCredits(int credits);

	void subtractCashCredits(int credits);

	bool verifyCashCredits(int credits);

	bool verifyBankCredits(int credits);

	bool isDancing();

	bool isPlayingMusic();

	void stopEntertaining();

	bool isEntertaining();

	void setCashCredits(int credits, bool notifyClient);

	void setTerrainNegotiation(float value, bool notifyClient);

	void addSkill(const String& skill, bool notifyClient);

	void removeSkill(const String& skill, bool notifyClient);

	void addSkillMod(const int modType, const String& skillMod, int value, bool notifyClient);

	void removeSkillMod(const int modType, const String& skillMod, int value, bool notifyClient);

	void removeAllSkillModsOfType(const int modType, bool notifyClient);

	void updateGroupInviterID(unsigned long long id, bool notifyClient);

	void updateGroup(GroupObject* group, bool notifyClient);

	void enqueueCommand(unsigned int actionCRC, unsigned int actionCount, unsigned long long targetID, const UnicodeString& arguments, int priority);

	void setMood(byte moodID, bool notifyClient);

	void setMoodString(const String& animation, bool notifyClient);

	void deleteQueueAction(unsigned int actionCount);

	bool setState(unsigned long long state, bool notifyClient);

	bool clearState(unsigned long long state, bool notifyClient);

	void setControlDevice(ControlDevice* device);

	void setCreatureLink(CreatureObject* object, bool notifyClient);

	void executeObjectControllerAction(unsigned int actionCRC);

	void executeObjectControllerAction(unsigned int actionCRC, unsigned long long targetID, const UnicodeString& args);

	bool isAttackableBy(CreatureObject* object);

	bool isAttackableBy(TangibleObject* attacker);

	bool isHealableBy(CreatureObject* object);

	bool isInBountyMission(CreatureObject* bountyHunter, CreatureObject* target);

	void sendConversationStartTo(SceneObject* player);

	void selectConversationOption(int option, SceneObject* obj);

	void sendMessage(BasePacket* msg);

	void sendExecuteConsoleCommand(const String& command);

	bool isAggressiveTo(CreatureObject* object);

	int notifyObjectDestructionObservers(TangibleObject* attacker, int condition);

	int notifyObjectKillObservers(TangibleObject* killer);

	void notifyLoadFromDatabase();

	void setFactionRank(int rank, bool notifyClient);

	String getFirstName();

	String getLastName();

	bool isOnline();

	bool canTreatInjuries();

	bool canTreatStates();

	bool canTreatWounds();

	bool canTreatConditions();

	Reference<PlayerObject* > getPlayerObject();

	AiActor* getActorObject();

	bool isListening();

	bool isWatching();

	void setClient(ZoneClientSession* cli);

	void dismount();

	float calculateBFRatio();

	void setDizziedState(int durationSeconds);

	void setRalliedState(int durationSeconds);

	void setAimingState(int durationSeconds);

	void setCoverState(int durationSeconds);

	void setBerserkedState(unsigned int duration);

	void setStunnedState(int durationSeconds);

	void setBlindedState(int durationSeconds);

	void setIntimidatedState(unsigned int mod, int durationSeconds);

	void setSnaredState(int durationSeconds);

	void setRootedState(int durationSeconds);

	bool setNextAttackDelay(unsigned int mod, int del);

	void setMeditateState();

	void activateHAMRegeneration();

	void activatePassiveWoundRegeneration();

	void activateStateRecovery();

	void updateTimeOfDeath();

	bool hasAttackDelay();

	void removeAttackDelay();

	bool hasSpice();

	void updateLastSuccessfulCombatAction();

	void updateKnockdownRecovery();

	void queueDizzyFallEvent();

	void updateLastKnockdown();

	bool checkKnockdownRecovery();

	bool checkLastKnockdown();

	void updatePostureDownRecovery();

	void updatePostureUpRecovery();

	bool checkPostureDownRecovery();

	unsigned long long getScreenPlayState(const String& screenPlay);

	void setScreenPlayState(const String& screenPlay, unsigned long long state);

	bool checkPostureUpRecovery();

	void updateCooldownTimer(const String& coooldownTimer, unsigned int miliSecondsToAdd);

	bool checkCooldownRecovery(const String& cooldown);

	void addCooldown(const String& name, unsigned int miliseconds);

	void doAnimation(const String& animation);

	void doCombatAnimation(CreatureObject* defender, unsigned int animationCRC, byte hit, byte trails);

	void playEffect(const String& file, const String& aux);

	void playEffect(const String& file);

	void activateQueueAction();

	void activateImmediateAction();

	UnicodeString getCreatureName();

	bool isGrouped();

	int getBankCredits();

	int getCashCredits();

	int getBaseHAM(int idx);

	int getWounds(int idx);

	int getHAM(int idx);

	int getMaxHAM(int idx);

	int getEncumbrance(int idx);

	byte getPosture();

	byte getLocomotion();

	byte getFactionRank();

	ManagedWeakReference<CreatureObject* > getLinkedCreature();

	unsigned long long getCreatureLinkID();

	float getShockWounds();

	unsigned long long getWatchToID();

	unsigned long long getStateBitmask();

	bool hasState(unsigned long long state);

	bool hasStates();

	unsigned long long getListenID();

	float getAccelerationMultiplierBase();

	float getAccelerationMultiplierMod();

	float getSpeedMultiplierBase();

	float getSpeedMultiplierMod();

	float getCurrentSpeed();

	float getRunSpeed();

	float getWalkSpeed();

	float getTurnScale();

	float getTerrainNegotiation();

	float getRunAcceleration();

	float getWalkAcceleration();

	String getPerformanceAnimation();

	String getMoodString();

	unsigned long long getWeaponID();

	Reference<WeaponObject* > getWeapon();

	Reference<GuildObject* > getGuildObject();

	int getGuildID();

	bool isInGuild();

	void setGuildObject(GuildObject* guildobj);

	unsigned long long getGroupID();

	unsigned long long getGroupInviterID();

	GroupObject* getGroup();

	unsigned long long getGroupInviteCounter();

	unsigned long long getTargetID();

	byte getMoodID();

	float getSlopeModPercent();

	int getPerformanceCounter();

	int getInstrumentID();

	byte getFrozen();

	float getHeight();

	int getSpecies();

	String getSpeciesName();

	int getGender();

	int getSkillMod(const String& skillmod);

	bool hasSkill(const String& skill);

	void setWatchToID(unsigned long long id);

	bool isCreatureObject();

	bool isNextActionPast();

	bool isTrainerCreature();

	bool isSwimming();

	ZoneClientSession* getClient();

	bool isRidingMount();

	ManagedWeakReference<ControlDevice* > getControlDevice();

	float getSwimHeight();

	bool isIncapacitated();

	bool isDead();

	bool isKnockedDown();

	bool isKneeling();

	bool isProne();

	bool isStanding();

	bool isSitting();

	bool isSkillAnimating();

	bool isRallied();

	bool isInCombat();

	bool isDizzied();

	bool isBerserked();

	bool isStunned();

	bool isBlinded();

	bool isIntimidated();

	bool isSnared();

	bool isImmobilized();

	bool isRooted();

	bool isFrozen();

	bool isDiseased();

	bool isPoisoned();

	bool isBleeding();

	bool isOnFire();

	bool isMounted();

	bool isRidingCreature();

	bool isPeaced();

	bool isMeditating();

	bool isAiming();

	bool isInCover();

	bool isRunning();

	bool isNonPlayerCreatureObject();

	bool isCreature();

	bool isPlayerCreature();

	bool isAiActor();

	bool isInformantCreature();

	CampSiteActiveArea* getCurrentCamp();

	byte getCurrentWeather();

	void setCurrentWeather(byte value);

	byte getCurrentWind();

	void setCurrentWind(byte value);

	int handleObjectMenuSelect(CreatureObject* player, byte selectedID);

	void fillAttributeList(AttributeListMessage* msg, CreatureObject* object);

	void destroyObjectFromWorld(bool sendSelfDestroy);

	bool isInvisible();

	void setInvisible(bool invis);

	float calculateCostAdjustment(byte stat, float baseCost);

	void updateSpeedAndAccelerationMods();

};

class CreatureObjectHelper : public DistributedObjectClassHelper, public Singleton<CreatureObjectHelper> {
	static CreatureObjectHelper* staticInitializer;

public:
	CreatureObjectHelper();

	void finalizeHelper();

	DistributedObject* instantiateObject();

	DistributedObjectServant* instantiateServant();

	DistributedObjectAdapter* createAdapter(DistributedObjectStub* obj);

	friend class Singleton<CreatureObjectHelper>;
};

class MockCreatureObject : public CreatureObject {
public:

	MOCK_METHOD0(getWorldPositionX,float());
	MOCK_METHOD0(getWorldPositionY,float());
	MOCK_METHOD0(getWorldPositionZ,float());
	MOCK_METHOD0(getWorldPosition,Vector3());

};

} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature;

#endif /*CREATUREOBJECT_H_*/
