/*
 *	server/zone/objects/player/PlayerCreature.cpp generated by engine3 IDL compiler 0.60
 */

#include "PlayerCreature.h"

#include "server/zone/ZoneClientSession.h"

#include "server/zone/objects/player/PlayerObject.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/objects/building/BuildingObject.h"

#include "server/zone/objects/tangible/Container.h"

#include "server/zone/objects/tangible/tool/CraftingTool.h"

#include "server/zone/objects/player/events/PlayerDisconnectEvent.h"

#include "server/zone/objects/player/events/PlayerRecoveryEvent.h"

#include "server/chat/room/ChatRoom.h"

#include "server/zone/Zone.h"

#include "server/zone/objects/tangible/weapon/WeaponObject.h"

#include "server/zone/objects/group/GroupObject.h"

#include "server/zone/objects/waypoint/WaypointObject.h"

#include "server/zone/objects/tangible/TangibleObject.h"

#include "server/zone/templates/SharedObjectTemplate.h"

#include "server/zone/objects/area/ActiveArea.h"

#include "server/zone/packets/object/ObjectMenuResponse.h"

#include "server/zone/objects/creature/professions/SkillBox.h"

#include "server/zone/packets/MessageCallback.h"

#include "server/zone/objects/structure/StructureObject.h"

/*
 *	PlayerCreatureStub
 */

PlayerCreature::PlayerCreature() : CreatureObject(DummyConstructorParameter::instance()) {
	PlayerCreatureImplementation* _implementation = new PlayerCreatureImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
}

PlayerCreature::PlayerCreature(DummyConstructorParameter* param) : CreatureObject(param) {
}

PlayerCreature::~PlayerCreature() {
}


void PlayerCreature::loadTemplateData(SharedObjectTemplate* templateData) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->loadTemplateData(templateData);
}

void PlayerCreature::initializeTransientMembers() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 6);

		method.executeWithVoidReturn();
	} else
		_implementation->initializeTransientMembers();
}

void PlayerCreature::notifyLoadFromDatabase() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 7);

		method.executeWithVoidReturn();
	} else
		_implementation->notifyLoadFromDatabase();
}

void PlayerCreature::notifyInsert(QuadTreeEntry* entry) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->notifyInsert(entry);
}

void PlayerCreature::notifyDissapear(QuadTreeEntry* entry) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->notifyDissapear(entry);
}

void PlayerCreature::disconnect(bool closeClient, bool doLock) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 8);
		method.addBooleanParameter(closeClient);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else
		_implementation->disconnect(closeClient, doLock);
}

void PlayerCreature::unload() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 9);

		method.executeWithVoidReturn();
	} else
		_implementation->unload();
}

void PlayerCreature::reload(ZoneClientSession* client) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 10);
		method.addObjectParameter(client);

		method.executeWithVoidReturn();
	} else
		_implementation->reload(client);
}

void PlayerCreature::logout(bool doLock) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 11);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else
		_implementation->logout(doLock);
}

void PlayerCreature::activateRecovery() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 12);

		method.executeWithVoidReturn();
	} else
		_implementation->activateRecovery();
}

void PlayerCreature::doRecovery() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 13);

		method.executeWithVoidReturn();
	} else
		_implementation->doRecovery();
}

void PlayerCreature::teleport(float newPositionX, float newPositionZ, float newPositionY, unsigned long long parentID) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 14);
		method.addFloatParameter(newPositionX);
		method.addFloatParameter(newPositionZ);
		method.addFloatParameter(newPositionY);
		method.addUnsignedLongParameter(parentID);

		method.executeWithVoidReturn();
	} else
		_implementation->teleport(newPositionX, newPositionZ, newPositionY, parentID);
}

void PlayerCreature::updateZone(bool lightUpdate, bool sendPackets) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 15);
		method.addBooleanParameter(lightUpdate);
		method.addBooleanParameter(sendPackets);

		method.executeWithVoidReturn();
	} else
		_implementation->updateZone(lightUpdate, sendPackets);
}

void PlayerCreature::updateZoneWithParent(SceneObject* newParent, bool lightUpdate, bool sendPackets) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 16);
		method.addObjectParameter(newParent);
		method.addBooleanParameter(lightUpdate);
		method.addBooleanParameter(sendPackets);

		method.executeWithVoidReturn();
	} else
		_implementation->updateZoneWithParent(newParent, lightUpdate, sendPackets);
}

void PlayerCreature::fillObjectMenuResponse(ObjectMenuResponse* menuResponse, PlayerCreature* player) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->fillObjectMenuResponse(menuResponse, player);
}

int PlayerCreature::handleObjectMenuSelect(PlayerCreature* player, byte selectedID) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 17);
		method.addObjectParameter(player);
		method.addByteParameter(selectedID);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->handleObjectMenuSelect(player, selectedID);
}

void PlayerCreature::insertToBuilding(BuildingObject* building) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 18);
		method.addObjectParameter(building);

		method.executeWithVoidReturn();
	} else
		_implementation->insertToBuilding(building);
}

void PlayerCreature::removeFromBuilding(BuildingObject* building) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 19);
		method.addObjectParameter(building);

		method.executeWithVoidReturn();
	} else
		_implementation->removeFromBuilding(building);
}

void PlayerCreature::updateToDatabase() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 20);

		method.executeWithVoidReturn();
	} else
		_implementation->updateToDatabase();
}

void PlayerCreature::sendMessage(BasePacket* msg) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 21);
		method.addObjectParameter(msg);

		method.executeWithVoidReturn();
	} else
		_implementation->sendMessage(msg);
}

void PlayerCreature::sendToOwner(bool doClose) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 22);
		method.addBooleanParameter(doClose);

		method.executeWithVoidReturn();
	} else
		_implementation->sendToOwner(doClose);
}

void PlayerCreature::sendBadgesResponseTo(PlayerCreature* player) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 23);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		_implementation->sendBadgesResponseTo(player);
}

void PlayerCreature::unloadSpawnedChildren() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 24);

		method.executeWithVoidReturn();
	} else
		_implementation->unloadSpawnedChildren();
}

bool PlayerCreature::isAggressiveTo(PlayerCreature* object) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 25);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isAggressiveTo(object);
}

void PlayerCreature::sendExecuteConsoleCommand(const String& command) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 26);
		method.addAsciiParameter(command);

		method.executeWithVoidReturn();
	} else
		_implementation->sendExecuteConsoleCommand(command);
}

bool PlayerCreature::isAttackableBy(CreatureObject* object) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 27);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isAttackableBy(object);
}

int PlayerCreature::canAddObject(SceneObject* object, int containmentType, String& errorDescription) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 28);
		method.addObjectParameter(object);
		method.addSignedIntParameter(containmentType);
		method.addAsciiParameter(errorDescription);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->canAddObject(object, containmentType, errorDescription);
}

int PlayerCreature::notifyObjectInserted(SceneObject* object) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 29);
		method.addObjectParameter(object);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->notifyObjectInserted(object);
}

int PlayerCreature::notifyObjectRemoved(SceneObject* object) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 30);
		method.addObjectParameter(object);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->notifyObjectRemoved(object);
}

int PlayerCreature::notifyObjectDestructionObservers(TangibleObject* attacker, int condition) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 31);
		method.addObjectParameter(attacker);
		method.addSignedIntParameter(condition);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->notifyObjectDestructionObservers(attacker, condition);
}

void PlayerCreature::setCombatState() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 32);

		method.executeWithVoidReturn();
	} else
		_implementation->setCombatState();
}

void PlayerCreature::setBadge(unsigned int badge) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 33);
		method.addUnsignedIntParameter(badge);

		method.executeWithVoidReturn();
	} else
		_implementation->setBadge(badge);
}

void PlayerCreature::awardBadge(unsigned int badge) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 34);
		method.addUnsignedIntParameter(badge);

		method.executeWithVoidReturn();
	} else
		_implementation->awardBadge(badge);
}

int PlayerCreature::getNumBadges() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 35);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getNumBadges();
}

int PlayerCreature::getBadgeTypeCount(byte type) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 36);
		method.addByteParameter(type);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getBadgeTypeCount(type);
}

bool PlayerCreature::isFirstIncapacitationExpired() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 37);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isFirstIncapacitationExpired();
}

void PlayerCreature::resetIncapacitationCounter() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 38);

		method.executeWithVoidReturn();
	} else
		_implementation->resetIncapacitationCounter();
}

void PlayerCreature::resetFirstIncapacitationTime() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 39);

		method.executeWithVoidReturn();
	} else
		_implementation->resetFirstIncapacitationTime();
}

void PlayerCreature::updateIncapacitationCounter() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 40);

		method.executeWithVoidReturn();
	} else
		_implementation->updateIncapacitationCounter();
}

bool PlayerCreature::isFirstIncapacitation() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 41);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isFirstIncapacitation();
}

byte PlayerCreature::getIncapacitationCounter() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 42);

		return method.executeWithByteReturn();
	} else
		return _implementation->getIncapacitationCounter();
}

void PlayerCreature::setLastNpcConvStr(const String& conv) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 43);
		method.addAsciiParameter(conv);

		method.executeWithVoidReturn();
	} else
		_implementation->setLastNpcConvStr(conv);
}

void PlayerCreature::setLastNpcConvMessStr(const String& mess) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 44);
		method.addAsciiParameter(mess);

		method.executeWithVoidReturn();
	} else
		_implementation->setLastNpcConvMessStr(mess);
}

String PlayerCreature::getLastNpcConvStr() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 45);

		method.executeWithAsciiReturn(_return_getLastNpcConvStr);
		return _return_getLastNpcConvStr;
	} else
		return _implementation->getLastNpcConvStr();
}

ValidatedPosition* PlayerCreature::getLastValidatedPosition() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getLastValidatedPosition();
}

String PlayerCreature::getLastNpcConvMessStr() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 46);

		method.executeWithAsciiReturn(_return_getLastNpcConvMessStr);
		return _return_getLastNpcConvMessStr;
	} else
		return _implementation->getLastNpcConvMessStr();
}

String PlayerCreature::getLastNpcConvOption(int idx) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 47);
		method.addSignedIntParameter(idx);

		method.executeWithAsciiReturn(_return_getLastNpcConvOption);
		return _return_getLastNpcConvOption;
	} else
		return _implementation->getLastNpcConvOption(idx);
}

void PlayerCreature::addLastNpcConvOptions(const String& option) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 48);
		method.addAsciiParameter(option);

		method.executeWithVoidReturn();
	} else
		_implementation->addLastNpcConvOptions(option);
}

int PlayerCreature::countLastNpcConvOptions() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 49);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->countLastNpcConvOptions();
}

void PlayerCreature::clearLastNpcConvOptions() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 50);

		method.executeWithVoidReturn();
	} else
		_implementation->clearLastNpcConvOptions();
}

void PlayerCreature::setSpawnedBlueFrog() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 51);

		method.executeWithVoidReturn();
	} else
		_implementation->setSpawnedBlueFrog();
}

bool PlayerCreature::hasSpawnedBlueFrog() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 52);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasSpawnedBlueFrog();
}

void PlayerCreature::addToConsentList(const String& name) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 53);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else
		_implementation->addToConsentList(name);
}

bool PlayerCreature::hasInConsentList(const String& name) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 54);
		method.addAsciiParameter(name);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasInConsentList(name);
}

void PlayerCreature::removeFromConsentList(const String& name) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 55);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else
		_implementation->removeFromConsentList(name);
}

String PlayerCreature::getConsentName(int i) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 56);
		method.addSignedIntParameter(i);

		method.executeWithAsciiReturn(_return_getConsentName);
		return _return_getConsentName;
	} else
		return _implementation->getConsentName(i);
}

int PlayerCreature::getConsentListSize() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 57);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getConsentListSize();
}

void PlayerCreature::addToDuelList(PlayerCreature* targetPlayer) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 58);
		method.addObjectParameter(targetPlayer);

		method.executeWithVoidReturn();
	} else
		_implementation->addToDuelList(targetPlayer);
}

void PlayerCreature::removeFromDuelList(PlayerCreature* targetPlayer) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 59);
		method.addObjectParameter(targetPlayer);

		method.executeWithVoidReturn();
	} else
		_implementation->removeFromDuelList(targetPlayer);
}

PlayerCreature* PlayerCreature::getDuelListObject(int index) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 60);
		method.addSignedIntParameter(index);

		return (PlayerCreature*) method.executeWithObjectReturn();
	} else
		return _implementation->getDuelListObject(index);
}

bool PlayerCreature::requestedDuelTo(PlayerCreature* targetPlayer) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 61);
		method.addObjectParameter(targetPlayer);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->requestedDuelTo(targetPlayer);
}

bool PlayerCreature::isDuelListEmpty() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 62);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isDuelListEmpty();
}

int PlayerCreature::getDuelListSize() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 63);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getDuelListSize();
}

void PlayerCreature::notifySceneReady() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 64);

		method.executeWithVoidReturn();
	} else
		_implementation->notifySceneReady();
}

void PlayerCreature::notifySelfPositionUpdate() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 65);

		method.executeWithVoidReturn();
	} else
		_implementation->notifySelfPositionUpdate();
}

SortedVector<unsigned long long>* PlayerCreature::getPersistentMessages() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getPersistentMessages();
}

void PlayerCreature::addPersistentMessage(unsigned long long id) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 66);
		method.addUnsignedLongParameter(id);

		method.executeWithVoidReturn();
	} else
		_implementation->addPersistentMessage(id);
}

void PlayerCreature::dropPersistentMessage(unsigned long long id) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 67);
		method.addUnsignedLongParameter(id);

		method.executeWithVoidReturn();
	} else
		_implementation->dropPersistentMessage(id);
}

PlayerObject* PlayerCreature::getPlayerObject() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 68);

		return (PlayerObject*) method.executeWithObjectReturn();
	} else
		return _implementation->getPlayerObject();
}

bool PlayerCreature::isOnline() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 69);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isOnline();
}

bool PlayerCreature::isOffline() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 70);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isOffline();
}

bool PlayerCreature::isLoading() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 71);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isLoading();
}

bool PlayerCreature::isLinkDead() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 72);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isLinkDead();
}

bool PlayerCreature::isLoggingIn() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 73);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isLoggingIn();
}

bool PlayerCreature::isLoggingOut() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 74);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isLoggingOut();
}

unsigned int PlayerCreature::getAccountID() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 75);

		return method.executeWithUnsignedIntReturn();
	} else
		return _implementation->getAccountID();
}

bool PlayerCreature::isTeleporting() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 76);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isTeleporting();
}

ZoneClientSession* PlayerCreature::getClient() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 77);

		return (ZoneClientSession*) method.executeWithObjectReturn();
	} else
		return _implementation->getClient();
}

byte PlayerCreature::getRaceID() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 78);

		return method.executeWithByteReturn();
	} else
		return _implementation->getRaceID();
}

unsigned long long PlayerCreature::getSavedParentID() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 79);

		return method.executeWithUnsignedLongReturn();
	} else
		return _implementation->getSavedParentID();
}

unsigned long long PlayerCreature::getServerMovementTimeDelta() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 80);

		return method.executeWithUnsignedLongReturn();
	} else
		return _implementation->getServerMovementTimeDelta();
}

Time* PlayerCreature::getServerMovementTimeStamp() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getServerMovementTimeStamp();
}

int PlayerCreature::getSavedZoneID() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 81);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getSavedZoneID();
}

String PlayerCreature::getFirstName() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 82);

		method.executeWithAsciiReturn(_return_getFirstName);
		return _return_getFirstName;
	} else
		return _implementation->getFirstName();
}

String PlayerCreature::getLastName() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 83);

		method.executeWithAsciiReturn(_return_getLastName);
		return _return_getLastName;
	} else
		return _implementation->getLastName();
}

void PlayerCreature::setSavedParentID(unsigned long long id) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 84);
		method.addUnsignedLongParameter(id);

		method.executeWithVoidReturn();
	} else
		_implementation->setSavedParentID(id);
}

void PlayerCreature::setSavedZoneID(int id) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 85);
		method.addSignedIntParameter(id);

		method.executeWithVoidReturn();
	} else
		_implementation->setSavedZoneID(id);
}

void PlayerCreature::setSkillPoints(int points) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 86);
		method.addSignedIntParameter(points);

		method.executeWithVoidReturn();
	} else
		_implementation->setSkillPoints(points);
}

void PlayerCreature::setTeleporting(bool val) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 87);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else
		_implementation->setTeleporting(val);
}

void PlayerCreature::addSkillPoints(int points) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 88);
		method.addSignedIntParameter(points);

		method.executeWithVoidReturn();
	} else
		_implementation->addSkillPoints(points);
}

void PlayerCreature::setClient(ZoneClientSession* cli) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 89);
		method.addObjectParameter(cli);

		method.executeWithVoidReturn();
	} else
		_implementation->setClient(cli);
}

void PlayerCreature::setBiography(const UnicodeString& bio) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 90);
		method.addUnicodeParameter(bio);

		method.executeWithVoidReturn();
	} else
		_implementation->setBiography(bio);
}

void PlayerCreature::setRaceID(byte id) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 91);
		method.addByteParameter(id);

		method.executeWithVoidReturn();
	} else
		_implementation->setRaceID(id);
}

void PlayerCreature::setConversatingCreature(CreatureObject* creature) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 92);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else
		_implementation->setConversatingCreature(creature);
}

void PlayerCreature::setClientLastMovementStamp(unsigned int stamp) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 93);
		method.addUnsignedIntParameter(stamp);

		method.executeWithVoidReturn();
	} else
		_implementation->setClientLastMovementStamp(stamp);
}

void PlayerCreature::updateServerLastMovementStamp() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 94);

		method.executeWithVoidReturn();
	} else
		_implementation->updateServerLastMovementStamp();
}

void PlayerCreature::setOffline() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 95);

		method.executeWithVoidReturn();
	} else
		_implementation->setOffline();
}

void PlayerCreature::setLinkDead() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 96);

		method.executeWithVoidReturn();
	} else
		_implementation->setLinkDead();
}

void PlayerCreature::setOnline() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 97);

		method.executeWithVoidReturn();
	} else
		_implementation->setOnline();
}

void PlayerCreature::setLoggingOut() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 98);

		method.executeWithVoidReturn();
	} else
		_implementation->setLoggingOut();
}

void PlayerCreature::setAccountID(unsigned int id) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 99);
		method.addUnsignedIntParameter(id);

		method.executeWithVoidReturn();
	} else
		_implementation->setAccountID(id);
}

void PlayerCreature::clearDisconnectEvent() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 100);

		method.executeWithVoidReturn();
	} else
		_implementation->clearDisconnectEvent();
}

void PlayerCreature::clearRecoveryEvent() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 101);

		method.executeWithVoidReturn();
	} else
		_implementation->clearRecoveryEvent();
}

void PlayerCreature::addChatRoom(ChatRoom* room) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 102);
		method.addObjectParameter(room);

		method.executeWithVoidReturn();
	} else
		_implementation->addChatRoom(room);
}

void PlayerCreature::removeChatRoom(ChatRoom* room) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 103);
		method.addObjectParameter(room);

		method.executeWithVoidReturn();
	} else
		_implementation->removeChatRoom(room);
}

int PlayerCreature::getSkillPoints() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 104);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getSkillPoints();
}

unsigned int PlayerCreature::getNewSuiBoxID(unsigned int type) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 105);
		method.addUnsignedIntParameter(type);

		return method.executeWithUnsignedIntReturn();
	} else
		return _implementation->getNewSuiBoxID(type);
}

bool PlayerCreature::hasSuiBox(unsigned int boxID) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 106);
		method.addUnsignedIntParameter(boxID);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasSuiBox(boxID);
}

SuiBox* PlayerCreature::getSuiBox(unsigned int boxID) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 107);
		method.addUnsignedIntParameter(boxID);

		return (SuiBox*) method.executeWithObjectReturn();
	} else
		return _implementation->getSuiBox(boxID);
}

void PlayerCreature::removeSuiBox(unsigned int boxID, bool closeWindowToClient) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 108);
		method.addUnsignedIntParameter(boxID);
		method.addBooleanParameter(closeWindowToClient);

		method.executeWithVoidReturn();
	} else
		_implementation->removeSuiBox(boxID, closeWindowToClient);
}

void PlayerCreature::removeSuiBoxType(unsigned int windowType) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 109);
		method.addUnsignedIntParameter(windowType);

		method.executeWithVoidReturn();
	} else
		_implementation->removeSuiBoxType(windowType);
}

bool PlayerCreature::hasSuiBoxWindowType(unsigned int windowType) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 110);
		method.addUnsignedIntParameter(windowType);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasSuiBoxWindowType(windowType);
}

void PlayerCreature::closeSuiWindowType(unsigned int windowType) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 111);
		method.addUnsignedIntParameter(windowType);

		method.executeWithVoidReturn();
	} else
		_implementation->closeSuiWindowType(windowType);
}

SuiBox* PlayerCreature::getSuiBoxFromWindowType(unsigned int windowType) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 112);
		method.addUnsignedIntParameter(windowType);

		return (SuiBox*) method.executeWithObjectReturn();
	} else
		return _implementation->getSuiBoxFromWindowType(windowType);
}

void PlayerCreature::addSuiBox(SuiBox* sui) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 113);
		method.addObjectParameter(sui);

		method.executeWithVoidReturn();
	} else
		_implementation->addSuiBox(sui);
}

int PlayerCreature::getLotsRemaining() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 114);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getLotsRemaining();
}

void PlayerCreature::setLotsRemaining(int lots) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 115);
		method.addSignedIntParameter(lots);

		method.executeWithVoidReturn();
	} else
		_implementation->setLotsRemaining(lots);
}

int PlayerCreature::getFactionStatus() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 116);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getFactionStatus();
}

UnicodeString PlayerCreature::getBiography() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 117);

		method.executeWithUnicodeReturn(_return_getBiography);
		return _return_getBiography;
	} else
		return _implementation->getBiography();
}

unsigned int PlayerCreature::getClientLastMovementStamp() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 118);

		return method.executeWithUnsignedIntReturn();
	} else
		return _implementation->getClientLastMovementStamp();
}

void PlayerCreature::setSurveyTool(SurveyTool* tool) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 119);
		method.addObjectParameter(tool);

		method.executeWithVoidReturn();
	} else
		_implementation->setSurveyTool(tool);
}

SurveyTool* PlayerCreature::getSurveyTool() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 120);

		return (SurveyTool*) method.executeWithObjectReturn();
	} else
		return _implementation->getSurveyTool();
}

void PlayerCreature::clearTradeContainer() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->clearTradeContainer();
}

void PlayerCreature::setTeachingOrLearning(bool value) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 121);
		method.addBooleanParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setTeachingOrLearning(value);
}

bool PlayerCreature::isTeachingOrLearning() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->isTeachingOrLearning();
}

WaypointObject* PlayerCreature::getSurveyWaypoint() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 122);

		return (WaypointObject*) method.executeWithObjectReturn();
	} else
		return _implementation->getSurveyWaypoint();
}

CreatureObject* PlayerCreature::getConversatingCreature() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 123);

		return (CreatureObject*) method.executeWithObjectReturn();
	} else
		return _implementation->getConversatingCreature();
}

int PlayerCreature::getCenteredBonus() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 124);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getCenteredBonus();
}

void PlayerCreature::setCenteredBonus(int bonus) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 125);
		method.addSignedIntParameter(bonus);

		method.executeWithVoidReturn();
	} else
		_implementation->setCenteredBonus(bonus);
}

TradeContainer* PlayerCreature::getTradeContainer() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getTradeContainer();
}

bool PlayerCreature::hasBadge(unsigned int badge) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 126);
		method.addUnsignedIntParameter(badge);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasBadge(badge);
}

CraftingTool* PlayerCreature::getLastCraftingToolUsed() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 127);

		return (CraftingTool*) method.executeWithObjectReturn();
	} else
		return _implementation->getLastCraftingToolUsed();
}

void PlayerCreature::setLastCraftingToolUsed(CraftingTool* tool) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 128);
		method.addObjectParameter(tool);

		method.executeWithVoidReturn();
	} else
		_implementation->setLastCraftingToolUsed(tool);
}

bool PlayerCreature::isInvisible() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 129);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isInvisible();
}

void PlayerCreature::setInvisible(bool invis) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 130);
		method.addBooleanParameter(invis);

		method.executeWithVoidReturn();
	} else
		_implementation->setInvisible(invis);
}

BuildingObject* PlayerCreature::getDeclaredResidence() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 131);

		return (BuildingObject*) method.executeWithObjectReturn();
	} else
		return _implementation->getDeclaredResidence();
}

void PlayerCreature::setDeclaredResidence(BuildingObject* residence) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 132);
		method.addObjectParameter(residence);

		method.executeWithVoidReturn();
	} else
		_implementation->setDeclaredResidence(residence);
}

void PlayerCreature::setCloningFacility(BuildingObject* cloningfac) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 133);
		method.addObjectParameter(cloningfac);

		method.executeWithVoidReturn();
	} else
		_implementation->setCloningFacility(cloningfac);
}

BuildingObject* PlayerCreature::getCloningFacility() {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 134);

		return (BuildingObject*) method.executeWithObjectReturn();
	} else
		return _implementation->getCloningFacility();
}

void PlayerCreature::setHologrindProfessions(Vector<byte>& profs) {
	PlayerCreatureImplementation* _implementation = (PlayerCreatureImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->setHologrindProfessions(profs);
}

DistributedObjectServant* PlayerCreature::_getImplementation() {

	_updated = true;
	return _impl;
}

void PlayerCreature::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	PlayerCreatureImplementation
 */

PlayerCreatureImplementation::PlayerCreatureImplementation(DummyConstructorParameter* param) : CreatureObjectImplementation(param) {
	_initializeImplementation();
}


PlayerCreatureImplementation::~PlayerCreatureImplementation() {
	PlayerCreatureImplementation::finalize();
}


void PlayerCreatureImplementation::_initializeImplementation() {
	_setClassHelper(PlayerCreatureHelper::instance());

	_serializationHelperMethod();
	_serializationHelperMethod();
}

void PlayerCreatureImplementation::_setStub(DistributedObjectStub* stub) {
	_this = (PlayerCreature*) stub;
	CreatureObjectImplementation::_setStub(stub);
}

DistributedObjectStub* PlayerCreatureImplementation::_getStub() {
	return _this;
}

PlayerCreatureImplementation::operator const PlayerCreature*() {
	return _this;
}

void PlayerCreatureImplementation::lock(bool doLock) {
	_this->lock(doLock);
}

void PlayerCreatureImplementation::lock(ManagedObject* obj) {
	_this->lock(obj);
}

void PlayerCreatureImplementation::rlock(bool doLock) {
	_this->rlock(doLock);
}

void PlayerCreatureImplementation::wlock(bool doLock) {
	_this->wlock(doLock);
}

void PlayerCreatureImplementation::wlock(ManagedObject* obj) {
	_this->wlock(obj);
}

void PlayerCreatureImplementation::unlock(bool doLock) {
	_this->unlock(doLock);
}

void PlayerCreatureImplementation::runlock(bool doLock) {
	_this->runlock(doLock);
}

void PlayerCreatureImplementation::_serializationHelperMethod() {
	CreatureObjectImplementation::_serializationHelperMethod();

	_setClassName("PlayerCreature");

}

void PlayerCreatureImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		String _name;
		_name.parseFromBinaryStream(stream);

		uint16 _varSize = stream->readShort();

		int _currentOffset = stream->getOffset();

		if(PlayerCreatureImplementation::readObjectMember(stream, _name)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool PlayerCreatureImplementation::readObjectMember(ObjectInputStream* stream, const String& _name) {
	if (CreatureObjectImplementation::readObjectMember(stream, _name))
		return true;

	if (_name == "savedZoneID") {
		TypeInfo<int >::parseFromBinaryStream(&savedZoneID, stream);
		return true;
	}

	if (_name == "savedParentID") {
		TypeInfo<unsigned long long >::parseFromBinaryStream(&savedParentID, stream);
		return true;
	}

	if (_name == "onlineStatus") {
		TypeInfo<int >::parseFromBinaryStream(&onlineStatus, stream);
		return true;
	}

	if (_name == "declaredResidence") {
		TypeInfo<ManagedWeakReference<BuildingObject* > >::parseFromBinaryStream(&declaredResidence, stream);
		return true;
	}

	if (_name == "cloningFacility") {
		TypeInfo<ManagedWeakReference<BuildingObject* > >::parseFromBinaryStream(&cloningFacility, stream);
		return true;
	}

	if (_name == "hologrindProfessions") {
		TypeInfo<Vector<byte> >::parseFromBinaryStream(&hologrindProfessions, stream);
		return true;
	}

	if (_name == "logoutTimeStamp") {
		TypeInfo<Time >::parseFromBinaryStream(&logoutTimeStamp, stream);
		return true;
	}

	if (_name == "clientLastMovementStamp") {
		TypeInfo<unsigned int >::parseFromBinaryStream(&clientLastMovementStamp, stream);
		return true;
	}

	if (_name == "serverLastMovementStamp") {
		TypeInfo<Time >::parseFromBinaryStream(&serverLastMovementStamp, stream);
		return true;
	}

	if (_name == "teleporting") {
		TypeInfo<bool >::parseFromBinaryStream(&teleporting, stream);
		return true;
	}

	if (_name == "lastValidatedPosition") {
		TypeInfo<ValidatedPosition >::parseFromBinaryStream(&lastValidatedPosition, stream);
		return true;
	}

	if (_name == "accountID") {
		TypeInfo<unsigned int >::parseFromBinaryStream(&accountID, stream);
		return true;
	}

	if (_name == "invisible") {
		TypeInfo<bool >::parseFromBinaryStream(&invisible, stream);
		return true;
	}

	if (_name == "suiBoxNextID") {
		TypeInfo<unsigned int >::parseFromBinaryStream(&suiBoxNextID, stream);
		return true;
	}

	if (_name == "raceFile") {
		TypeInfo<String >::parseFromBinaryStream(&raceFile, stream);
		return true;
	}

	if (_name == "raceID") {
		TypeInfo<byte >::parseFromBinaryStream(&raceID, stream);
		return true;
	}

	if (_name == "startingLocation") {
		TypeInfo<String >::parseFromBinaryStream(&startingLocation, stream);
		return true;
	}

	if (_name == "startingProfession") {
		TypeInfo<String >::parseFromBinaryStream(&startingProfession, stream);
		return true;
	}

	if (_name == "biography") {
		TypeInfo<UnicodeString >::parseFromBinaryStream(&biography, stream);
		return true;
	}

	if (_name == "lotsRemaining") {
		TypeInfo<int >::parseFromBinaryStream(&lotsRemaining, stream);
		return true;
	}

	if (_name == "skillPoints") {
		TypeInfo<int >::parseFromBinaryStream(&skillPoints, stream);
		return true;
	}

	if (_name == "teachingOrLearning") {
		TypeInfo<bool >::parseFromBinaryStream(&teachingOrLearning, stream);
		return true;
	}

	if (_name == "badges") {
		TypeInfo<Badges >::parseFromBinaryStream(&badges, stream);
		return true;
	}

	if (_name == "chatRooms") {
		TypeInfo<SortedVector<ManagedReference<ChatRoom* > > >::parseFromBinaryStream(&chatRooms, stream);
		return true;
	}

	if (_name == "incapacitationCounter") {
		TypeInfo<byte >::parseFromBinaryStream(&incapacitationCounter, stream);
		return true;
	}

	if (_name == "suiBoxes") {
		TypeInfo<VectorMap<unsigned int, ManagedReference<SuiBox* > > >::parseFromBinaryStream(&suiBoxes, stream);
		return true;
	}

	if (_name == "pvpRating") {
		TypeInfo<int >::parseFromBinaryStream(&pvpRating, stream);
		return true;
	}

	if (_name == "factionStatus") {
		TypeInfo<int >::parseFromBinaryStream(&factionStatus, stream);
		return true;
	}

	if (_name == "persistentMessages") {
		TypeInfo<SortedVector<unsigned long long> >::parseFromBinaryStream(&persistentMessages, stream);
		return true;
	}

	if (_name == "duelList") {
		TypeInfo<SortedVector<ManagedReference<PlayerCreature* > > >::parseFromBinaryStream(&duelList, stream);
		return true;
	}

	if (_name == "surveyTool") {
		TypeInfo<ManagedWeakReference<SurveyTool* > >::parseFromBinaryStream(&surveyTool, stream);
		return true;
	}

	if (_name == "consentList") {
		TypeInfo<SortedVector<String> >::parseFromBinaryStream(&consentList, stream);
		return true;
	}

	if (_name == "lastNpcConvoMessage") {
		TypeInfo<String >::parseFromBinaryStream(&lastNpcConvoMessage, stream);
		return true;
	}

	if (_name == "lastNpcConvo") {
		TypeInfo<String >::parseFromBinaryStream(&lastNpcConvo, stream);
		return true;
	}

	if (_name == "lastNpcConvoOptions") {
		TypeInfo<Vector<String> >::parseFromBinaryStream(&lastNpcConvoOptions, stream);
		return true;
	}

	if (_name == "conversatingCreature") {
		TypeInfo<ManagedWeakReference<CreatureObject* > >::parseFromBinaryStream(&conversatingCreature, stream);
		return true;
	}

	if (_name == "centeredBonus") {
		TypeInfo<int >::parseFromBinaryStream(&centeredBonus, stream);
		return true;
	}

	if (_name == "tradeContainer") {
		TypeInfo<TradeContainer >::parseFromBinaryStream(&tradeContainer, stream);
		return true;
	}


	return false;
}

void PlayerCreatureImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = PlayerCreatureImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int PlayerCreatureImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	String _name;
	int _offset;
	uint16 _totalSize;
	_name = "savedZoneID";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&savedZoneID, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "savedParentID";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<unsigned long long >::toBinaryStream(&savedParentID, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "onlineStatus";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&onlineStatus, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "declaredResidence";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<ManagedWeakReference<BuildingObject* > >::toBinaryStream(&declaredResidence, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "cloningFacility";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<ManagedWeakReference<BuildingObject* > >::toBinaryStream(&cloningFacility, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "hologrindProfessions";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<Vector<byte> >::toBinaryStream(&hologrindProfessions, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "logoutTimeStamp";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<Time >::toBinaryStream(&logoutTimeStamp, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "clientLastMovementStamp";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<unsigned int >::toBinaryStream(&clientLastMovementStamp, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "serverLastMovementStamp";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<Time >::toBinaryStream(&serverLastMovementStamp, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "teleporting";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<bool >::toBinaryStream(&teleporting, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "lastValidatedPosition";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<ValidatedPosition >::toBinaryStream(&lastValidatedPosition, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "accountID";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<unsigned int >::toBinaryStream(&accountID, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "invisible";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<bool >::toBinaryStream(&invisible, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "suiBoxNextID";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<unsigned int >::toBinaryStream(&suiBoxNextID, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "raceFile";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<String >::toBinaryStream(&raceFile, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "raceID";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<byte >::toBinaryStream(&raceID, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "startingLocation";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<String >::toBinaryStream(&startingLocation, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "startingProfession";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<String >::toBinaryStream(&startingProfession, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "biography";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<UnicodeString >::toBinaryStream(&biography, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "lotsRemaining";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&lotsRemaining, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "skillPoints";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&skillPoints, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "teachingOrLearning";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<bool >::toBinaryStream(&teachingOrLearning, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "badges";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<Badges >::toBinaryStream(&badges, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "chatRooms";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<SortedVector<ManagedReference<ChatRoom* > > >::toBinaryStream(&chatRooms, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "incapacitationCounter";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<byte >::toBinaryStream(&incapacitationCounter, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "suiBoxes";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<VectorMap<unsigned int, ManagedReference<SuiBox* > > >::toBinaryStream(&suiBoxes, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "pvpRating";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&pvpRating, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "factionStatus";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&factionStatus, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "persistentMessages";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<SortedVector<unsigned long long> >::toBinaryStream(&persistentMessages, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "duelList";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<SortedVector<ManagedReference<PlayerCreature* > > >::toBinaryStream(&duelList, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "surveyTool";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<ManagedWeakReference<SurveyTool* > >::toBinaryStream(&surveyTool, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "consentList";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<SortedVector<String> >::toBinaryStream(&consentList, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "lastNpcConvoMessage";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<String >::toBinaryStream(&lastNpcConvoMessage, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "lastNpcConvo";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<String >::toBinaryStream(&lastNpcConvo, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "lastNpcConvoOptions";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<Vector<String> >::toBinaryStream(&lastNpcConvoOptions, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "conversatingCreature";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<ManagedWeakReference<CreatureObject* > >::toBinaryStream(&conversatingCreature, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "centeredBonus";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&centeredBonus, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "tradeContainer";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<TradeContainer >::toBinaryStream(&tradeContainer, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);


	return 38 + CreatureObjectImplementation::writeObjectMembers(stream);
}

PlayerCreatureImplementation::PlayerCreatureImplementation() {
	_initializeImplementation();
	// server/zone/objects/player/PlayerCreature.idl():  		Logger.setLoggingName("PlayerCreature");
	Logger::setLoggingName("PlayerCreature");
	// server/zone/objects/player/PlayerCreature.idl():  		owner = null;
	owner = NULL;
	// server/zone/objects/player/PlayerCreature.idl():  		disconnectEvent = null;
	disconnectEvent = NULL;
	// server/zone/objects/player/PlayerCreature.idl():  		recoveryEvent = null;
	recoveryEvent = NULL;
	// server/zone/objects/player/PlayerCreature.idl():  		accountID = 0;
	accountID = 0;
	// server/zone/objects/player/PlayerCreature.idl():  		savedZoneID = -1;
	savedZoneID = -1;
	// server/zone/objects/player/PlayerCreature.idl():  		savedParentID = 0;
	savedParentID = 0;
	// server/zone/objects/player/PlayerCreature.idl():  		skillPoints = 0;
	skillPoints = 0;
	// server/zone/objects/player/PlayerCreature.idl():  		teachingOrLearning = false;
	teachingOrLearning = false;
	// server/zone/objects/player/PlayerCreature.idl():  		invisible = false;
	invisible = false;
	// server/zone/objects/player/PlayerCreature.idl():  		suiBoxNextID = 0;
	suiBoxNextID = 0;
	// server/zone/objects/player/PlayerCreature.idl():  		factionStatus = 0;
	factionStatus = 0;
	// server/zone/objects/player/PlayerCreature.idl():  		lotsRemaining = 10;
	lotsRemaining = 10;
	// server/zone/objects/player/PlayerCreature.idl():  		centeredBonus = 0;
	centeredBonus = 0;
	// server/zone/objects/player/PlayerCreature.idl():  		clientLastMovementStamp = 0;
	clientLastMovementStamp = 0;
	// server/zone/objects/player/PlayerCreature.idl():  		teleporting = false;
	teleporting = false;
	// server/zone/objects/player/PlayerCreature.idl():  		super.pvpStatusBitmask = CreatureFlag.PLAYER;
	CreatureObjectImplementation::pvpStatusBitmask = CreatureFlag::PLAYER;
	// server/zone/objects/player/PlayerCreature.idl():  		conversatingCreature = null;
	conversatingCreature = NULL;
	// server/zone/objects/player/PlayerCreature.idl():  		spawnedBlueFrog = false;
	spawnedBlueFrog = false;
	// server/zone/objects/player/PlayerCreature.idl():  		declaredResidence = null;
	declaredResidence = NULL;
	// server/zone/objects/player/PlayerCreature.idl():  		persistentMessages.setNoDuplicateInsertPlan();
	(&persistentMessages)->setNoDuplicateInsertPlan();
	// server/zone/objects/player/PlayerCreature.idl():  		duelList.setNoDuplicateInsertPlan();
	(&duelList)->setNoDuplicateInsertPlan();
	// server/zone/objects/player/PlayerCreature.idl():  		consentList.setNoDuplicateInsertPlan();
	(&consentList)->setNoDuplicateInsertPlan();
	// server/zone/objects/player/PlayerCreature.idl():  		setOffline();
	setOffline();
}

void PlayerCreatureImplementation::loadTemplateData(SharedObjectTemplate* templateData) {
	// server/zone/objects/player/PlayerCreature.idl():  		super.loadTemplateData(templateData);
	CreatureObjectImplementation::loadTemplateData(templateData);
	// server/zone/objects/player/PlayerCreature.idl():  		super.pvpStatusBitmask = CreatureFlag.PLAYER;
	CreatureObjectImplementation::pvpStatusBitmask = CreatureFlag::PLAYER;
}

bool PlayerCreatureImplementation::isAggressiveTo(PlayerCreature* object) {
	// server/zone/objects/player/PlayerCreature.idl():  		return 
	if ((&duelList)->contains(object) && object->requestedDuelTo(_this))	// server/zone/objects/player/PlayerCreature.idl():  			return true;
	return true;
	// server/zone/objects/player/PlayerCreature.idl():  		return false;
	return false;
}

void PlayerCreatureImplementation::setBadge(unsigned int badge) {
	// server/zone/objects/player/PlayerCreature.idl():  		badges.setBadge(badge);
	(&badges)->setBadge(badge);
}

int PlayerCreatureImplementation::getNumBadges() {
	// server/zone/objects/player/PlayerCreature.idl():  		return badges.getNumBadges();
	return (&badges)->getNumBadges();
}

int PlayerCreatureImplementation::getBadgeTypeCount(byte type) {
	// server/zone/objects/player/PlayerCreature.idl():  		return badges.getTypeCount(type);
	return (&badges)->getTypeCount(type);
}

void PlayerCreatureImplementation::resetIncapacitationCounter() {
	// server/zone/objects/player/PlayerCreature.idl():  		incapacitationCounter = 0;
	incapacitationCounter = 0;
}

void PlayerCreatureImplementation::updateIncapacitationCounter() {
	// server/zone/objects/player/PlayerCreature.idl():  		incapacitationCounter++;
	incapacitationCounter ++;
	// server/zone/objects/player/PlayerCreature.idl():  	}
	if (isFirstIncapacitation() || isFirstIncapacitationExpired())	// server/zone/objects/player/PlayerCreature.idl():  			resetFirstIncapacitationTime();
	resetFirstIncapacitationTime();
}

bool PlayerCreatureImplementation::isFirstIncapacitation() {
	// server/zone/objects/player/PlayerCreature.idl():  		return incapacitationCounter == 1;
	return incapacitationCounter == 1;
}

byte PlayerCreatureImplementation::getIncapacitationCounter() {
	// server/zone/objects/player/PlayerCreature.idl():  		return incapacitationCounter;
	return incapacitationCounter;
}

void PlayerCreatureImplementation::setLastNpcConvStr(const String& conv) {
	// server/zone/objects/player/PlayerCreature.idl():  		lastNpcConvo = conv;
	lastNpcConvo = conv;
}

void PlayerCreatureImplementation::setLastNpcConvMessStr(const String& mess) {
	// server/zone/objects/player/PlayerCreature.idl():  		lastNpcConvoMessage = mess;
	lastNpcConvoMessage = mess;
}

String PlayerCreatureImplementation::getLastNpcConvStr() {
	// server/zone/objects/player/PlayerCreature.idl():  		return lastNpcConvo;
	return lastNpcConvo;
}

ValidatedPosition* PlayerCreatureImplementation::getLastValidatedPosition() {
	// server/zone/objects/player/PlayerCreature.idl():  		return lastValidatedPosition;
	return (&lastValidatedPosition);
}

String PlayerCreatureImplementation::getLastNpcConvMessStr() {
	// server/zone/objects/player/PlayerCreature.idl():  		return lastNpcConvoMessage;
	return lastNpcConvoMessage;
}

String PlayerCreatureImplementation::getLastNpcConvOption(int idx) {
	// server/zone/objects/player/PlayerCreature.idl():  		return lastNpcConvoOptions.get(idx);
	return (&lastNpcConvoOptions)->get(idx);
}

void PlayerCreatureImplementation::addLastNpcConvOptions(const String& option) {
	// server/zone/objects/player/PlayerCreature.idl():  		lastNpcConvoOptions.add(option);
	(&lastNpcConvoOptions)->add(option);
}

int PlayerCreatureImplementation::countLastNpcConvOptions() {
	// server/zone/objects/player/PlayerCreature.idl():  		return lastNpcConvoOptions.size();
	return (&lastNpcConvoOptions)->size();
}

void PlayerCreatureImplementation::clearLastNpcConvOptions() {
	// server/zone/objects/player/PlayerCreature.idl():  		lastNpcConvoOptions.removeAll();
	(&lastNpcConvoOptions)->removeAll();
}

void PlayerCreatureImplementation::setSpawnedBlueFrog() {
	// server/zone/objects/player/PlayerCreature.idl():  		spawnedBlueFrog = true;
	spawnedBlueFrog = true;
}

bool PlayerCreatureImplementation::hasSpawnedBlueFrog() {
	// server/zone/objects/player/PlayerCreature.idl():  		return spawnedBlueFrog;
	return spawnedBlueFrog;
}

void PlayerCreatureImplementation::addToConsentList(const String& name) {
	// server/zone/objects/player/PlayerCreature.idl():  		consentList.put(name);
	(&consentList)->put(name);
}

bool PlayerCreatureImplementation::hasInConsentList(const String& name) {
	// server/zone/objects/player/PlayerCreature.idl():  		return consentList.contains(name);
	return (&consentList)->contains(name);
}

void PlayerCreatureImplementation::removeFromConsentList(const String& name) {
	// server/zone/objects/player/PlayerCreature.idl():  		consentList.drop(name);
	(&consentList)->drop(name);
}

String PlayerCreatureImplementation::getConsentName(int i) {
	// server/zone/objects/player/PlayerCreature.idl():  		return consentList.get(i);
	return (&consentList)->get(i);
}

int PlayerCreatureImplementation::getConsentListSize() {
	// server/zone/objects/player/PlayerCreature.idl():  		return consentList.size();
	return (&consentList)->size();
}

void PlayerCreatureImplementation::addToDuelList(PlayerCreature* targetPlayer) {
	// server/zone/objects/player/PlayerCreature.idl():  		duelList.put(targetPlayer);
	(&duelList)->put(targetPlayer);
}

void PlayerCreatureImplementation::removeFromDuelList(PlayerCreature* targetPlayer) {
	// server/zone/objects/player/PlayerCreature.idl():  		duelList.drop(targetPlayer);
	(&duelList)->drop(targetPlayer);
}

PlayerCreature* PlayerCreatureImplementation::getDuelListObject(int index) {
	// server/zone/objects/player/PlayerCreature.idl():  		return duelList.get(index);
	return (&duelList)->get(index);
}

bool PlayerCreatureImplementation::requestedDuelTo(PlayerCreature* targetPlayer) {
	// server/zone/objects/player/PlayerCreature.idl():  		return duelList.contains(targetPlayer);
	return (&duelList)->contains(targetPlayer);
}

bool PlayerCreatureImplementation::isDuelListEmpty() {
	// server/zone/objects/player/PlayerCreature.idl():  		return duelList.isEmpty();
	return (&duelList)->isEmpty();
}

int PlayerCreatureImplementation::getDuelListSize() {
	// server/zone/objects/player/PlayerCreature.idl():  		return duelList.size();
	return (&duelList)->size();
}

SortedVector<unsigned long long>* PlayerCreatureImplementation::getPersistentMessages() {
	// server/zone/objects/player/PlayerCreature.idl():  		return persistentMessages;
	return (&persistentMessages);
}

void PlayerCreatureImplementation::addPersistentMessage(unsigned long long id) {
	// server/zone/objects/player/PlayerCreature.idl():  		persistentMessages.put(id);
	(&persistentMessages)->put(id);
}

void PlayerCreatureImplementation::dropPersistentMessage(unsigned long long id) {
	// server/zone/objects/player/PlayerCreature.idl():  		persistentMessages.drop(id);
	(&persistentMessages)->drop(id);
}

PlayerObject* PlayerCreatureImplementation::getPlayerObject() {
	// server/zone/objects/player/PlayerCreature.idl():  		return (PlayerObject) super.getSlottedObject("ghost");
	return (PlayerObject*) CreatureObjectImplementation::getSlottedObject("ghost");
}

bool PlayerCreatureImplementation::isOnline() {
	// server/zone/objects/player/PlayerCreature.idl():  		return onlineStatus != OFFLINE && onlineStatus != LINKDEAD;
	return onlineStatus != OFFLINE && onlineStatus != LINKDEAD;
}

bool PlayerCreatureImplementation::isOffline() {
	// server/zone/objects/player/PlayerCreature.idl():  		return onlineStatus == OFFLINE;
	return onlineStatus == OFFLINE;
}

bool PlayerCreatureImplementation::isLoading() {
	// server/zone/objects/player/PlayerCreature.idl():  		return onlineStatus == LOADING || onlineStatus == LOGGINGOUT;
	return onlineStatus == LOADING || onlineStatus == LOGGINGOUT;
}

bool PlayerCreatureImplementation::isLinkDead() {
	// server/zone/objects/player/PlayerCreature.idl():  		return onlineStatus == LINKDEAD;
	return onlineStatus == LINKDEAD;
}

bool PlayerCreatureImplementation::isLoggingIn() {
	// server/zone/objects/player/PlayerCreature.idl():  		return onlineStatus == LOGGINGIN;
	return onlineStatus == LOGGINGIN;
}

bool PlayerCreatureImplementation::isLoggingOut() {
	// server/zone/objects/player/PlayerCreature.idl():  		return onlineStatus == LOGGINGOUT;
	return onlineStatus == LOGGINGOUT;
}

unsigned int PlayerCreatureImplementation::getAccountID() {
	// server/zone/objects/player/PlayerCreature.idl():  		return accountID;
	return accountID;
}

bool PlayerCreatureImplementation::isTeleporting() {
	// server/zone/objects/player/PlayerCreature.idl():  		return teleporting;
	return teleporting;
}

ZoneClientSession* PlayerCreatureImplementation::getClient() {
	// server/zone/objects/player/PlayerCreature.idl():  		return owner;
	return owner;
}

byte PlayerCreatureImplementation::getRaceID() {
	// server/zone/objects/player/PlayerCreature.idl():  		return raceID;
	return raceID;
}

unsigned long long PlayerCreatureImplementation::getSavedParentID() {
	// server/zone/objects/player/PlayerCreature.idl():  		return savedParentID;
	return savedParentID;
}

unsigned long long PlayerCreatureImplementation::getServerMovementTimeDelta() {
	// server/zone/objects/player/PlayerCreature.idl():  		return serverLastMovementStamp.miliDifference();
	return (&serverLastMovementStamp)->miliDifference();
}

Time* PlayerCreatureImplementation::getServerMovementTimeStamp() {
	// server/zone/objects/player/PlayerCreature.idl():  		return serverLastMovementStamp;
	return (&serverLastMovementStamp);
}

int PlayerCreatureImplementation::getSavedZoneID() {
	// server/zone/objects/player/PlayerCreature.idl():  		return savedZoneID;
	return savedZoneID;
}

void PlayerCreatureImplementation::setSavedParentID(unsigned long long id) {
	// server/zone/objects/player/PlayerCreature.idl():  		savedParentID = id;
	savedParentID = id;
}

void PlayerCreatureImplementation::setSavedZoneID(int id) {
	// server/zone/objects/player/PlayerCreature.idl():  		savedZoneID = id;
	savedZoneID = id;
}

void PlayerCreatureImplementation::setSkillPoints(int points) {
	// server/zone/objects/player/PlayerCreature.idl():  		skillPoints = points;
	skillPoints = points;
}

void PlayerCreatureImplementation::setTeleporting(bool val) {
	// server/zone/objects/player/PlayerCreature.idl():  		teleporting = val;
	teleporting = val;
}

void PlayerCreatureImplementation::addSkillPoints(int points) {
	// server/zone/objects/player/PlayerCreature.idl():  		skillPoints += points;
	skillPoints += points;
}

void PlayerCreatureImplementation::setClient(ZoneClientSession* cli) {
	// server/zone/objects/player/PlayerCreature.idl():  		owner = cli;
	owner = cli;
}

void PlayerCreatureImplementation::setBiography(const UnicodeString& bio) {
	// server/zone/objects/player/PlayerCreature.idl():  		biography = bio;
	biography = bio;
}

void PlayerCreatureImplementation::setRaceID(byte id) {
	// server/zone/objects/player/PlayerCreature.idl():  		raceID = id;
	raceID = id;
}

void PlayerCreatureImplementation::setConversatingCreature(CreatureObject* creature) {
	// server/zone/objects/player/PlayerCreature.idl():  		conversatingCreature = creature;
	conversatingCreature = creature;
}

void PlayerCreatureImplementation::setClientLastMovementStamp(unsigned int stamp) {
	// server/zone/objects/player/PlayerCreature.idl():  		clientLastMovementStamp = stamp;
	clientLastMovementStamp = stamp;
}

void PlayerCreatureImplementation::updateServerLastMovementStamp() {
	// server/zone/objects/player/PlayerCreature.idl():  		serverLastMovementStamp.updateToCurrentTime();
	(&serverLastMovementStamp)->updateToCurrentTime();
}

void PlayerCreatureImplementation::setOffline() {
	// server/zone/objects/player/PlayerCreature.idl():  		onlineStatus 
	if (isLinkDead()){
}
	// server/zone/objects/player/PlayerCreature.idl():  		onlineStatus = OFFLINE;
	onlineStatus = OFFLINE;
}

void PlayerCreatureImplementation::setLoggingOut() {
	// server/zone/objects/player/PlayerCreature.idl():  		onlineStatus = LOGGINGOUT;
	onlineStatus = LOGGINGOUT;
}

void PlayerCreatureImplementation::setAccountID(unsigned int id) {
	// server/zone/objects/player/PlayerCreature.idl():  		accountID = id;
	accountID = id;
}

void PlayerCreatureImplementation::clearDisconnectEvent() {
	// server/zone/objects/player/PlayerCreature.idl():  		disconnectEvent = null;
	disconnectEvent = NULL;
}

void PlayerCreatureImplementation::clearRecoveryEvent() {
	// server/zone/objects/player/PlayerCreature.idl():  		recoveryEvent = null;
	recoveryEvent = NULL;
}

void PlayerCreatureImplementation::addChatRoom(ChatRoom* room) {
	// server/zone/objects/player/PlayerCreature.idl():  		chatRooms.put(room);
	(&chatRooms)->put(room);
}

void PlayerCreatureImplementation::removeChatRoom(ChatRoom* room) {
	// server/zone/objects/player/PlayerCreature.idl():  		chatRooms.drop(room);
	(&chatRooms)->drop(room);
}

int PlayerCreatureImplementation::getSkillPoints() {
	// server/zone/objects/player/PlayerCreature.idl():  		return skillPoints;
	return skillPoints;
}

bool PlayerCreatureImplementation::hasSuiBox(unsigned int boxID) {
	// server/zone/objects/player/PlayerCreature.idl():  		return suiBoxes.contains(boxID);
	return (&suiBoxes)->contains(boxID);
}

SuiBox* PlayerCreatureImplementation::getSuiBox(unsigned int boxID) {
	// server/zone/objects/player/PlayerCreature.idl():  		return suiBoxes.get(boxID);
	return (&suiBoxes)->get(boxID);
}

bool PlayerCreatureImplementation::hasSuiBoxWindowType(unsigned int windowType) {
	// server/zone/objects/player/PlayerCreature.idl():  		unsigned int type = 0;
	unsigned int type = 0;
	// server/zone/objects/player/PlayerCreature.idl():  		}
	for (	// server/zone/objects/player/PlayerCreature.idl():  		for (int i = 0;
	int i = 0;
	i < (&suiBoxes)->size();
 ++i) {
	// server/zone/objects/player/PlayerCreature.idl():  			SuiBox sui = suiBoxes.get(i);
	SuiBox* sui = (&suiBoxes)->get(i);
	// server/zone/objects/player/PlayerCreature.idl():  			type = sui.getWindowType();
	type = sui->getWindowType();
	// server/zone/objects/player/PlayerCreature.idl():  		}
	if (windowType == type)	// server/zone/objects/player/PlayerCreature.idl():  				return true;
	return true;
}
	// server/zone/objects/player/PlayerCreature.idl():  		return false;
	return false;
}

void PlayerCreatureImplementation::closeSuiWindowType(unsigned int windowType) {
	// server/zone/objects/player/PlayerCreature.idl():  	}
	if (hasSuiBoxWindowType(windowType)){
	// server/zone/objects/player/PlayerCreature.idl():  			SuiBox sui = getSuiBoxFromWindowType(windowType);
	SuiBox* sui = getSuiBoxFromWindowType(windowType);
	// server/zone/objects/player/PlayerCreature.idl():  		}
	if (sui != NULL){
	// server/zone/objects/player/PlayerCreature.idl():  				sendMessage(sui.generateCloseMessage());
	sendMessage(sui->generateCloseMessage());
	// server/zone/objects/player/PlayerCreature.idl():  				removeSuiBox(sui.getBoxID());
	removeSuiBox(sui->getBoxID());
}
}
}

SuiBox* PlayerCreatureImplementation::getSuiBoxFromWindowType(unsigned int windowType) {
	// server/zone/objects/player/PlayerCreature.idl():  		unsigned int type = 0;
	unsigned int type = 0;
	// server/zone/objects/player/PlayerCreature.idl():  		}
	for (	// server/zone/objects/player/PlayerCreature.idl():  		for (int i = 0;
	int i = 0;
	i < (&suiBoxes)->size();
 ++i) {
	// server/zone/objects/player/PlayerCreature.idl():  			SuiBox sui = suiBoxes.get(i);
	SuiBox* sui = (&suiBoxes)->get(i);
	// server/zone/objects/player/PlayerCreature.idl():  		}
	if (windowType == sui->getWindowType())	// server/zone/objects/player/PlayerCreature.idl():  				return sui;
	return sui;
}
	// server/zone/objects/player/PlayerCreature.idl():  		return null;
	return NULL;
}

void PlayerCreatureImplementation::addSuiBox(SuiBox* sui) {
	// server/zone/objects/player/PlayerCreature.idl():  		unsigned int key = sui.getBoxID();
	unsigned int key = sui->getBoxID();
	// server/zone/objects/player/PlayerCreature.idl():  		suiBoxes.put(key, sui);
	(&suiBoxes)->put(key, sui);
}

int PlayerCreatureImplementation::getLotsRemaining() {
	// server/zone/objects/player/PlayerCreature.idl():  		return lotsRemaining;
	return lotsRemaining;
}

void PlayerCreatureImplementation::setLotsRemaining(int lots) {
	// server/zone/objects/player/PlayerCreature.idl():  		lotsRemaining = lots;
	lotsRemaining = lots;
}

int PlayerCreatureImplementation::getFactionStatus() {
	// server/zone/objects/player/PlayerCreature.idl():  		return factionStatus;
	return factionStatus;
}

UnicodeString PlayerCreatureImplementation::getBiography() {
	// server/zone/objects/player/PlayerCreature.idl():  		return biography;
	return biography;
}

unsigned int PlayerCreatureImplementation::getClientLastMovementStamp() {
	// server/zone/objects/player/PlayerCreature.idl():  		return clientLastMovementStamp;
	return clientLastMovementStamp;
}

void PlayerCreatureImplementation::setSurveyTool(SurveyTool* tool) {
	// server/zone/objects/player/PlayerCreature.idl():  		surveyTool = tool;
	surveyTool = tool;
}

SurveyTool* PlayerCreatureImplementation::getSurveyTool() {
	// server/zone/objects/player/PlayerCreature.idl():  		return surveyTool;
	return surveyTool;
}

void PlayerCreatureImplementation::clearTradeContainer() {
	// server/zone/objects/player/PlayerCreature.idl():  		tradeContainer.clear();
	(&tradeContainer)->clear();
}

void PlayerCreatureImplementation::setTeachingOrLearning(bool value) {
	// server/zone/objects/player/PlayerCreature.idl():  	 teachingOrLearning = value;
	teachingOrLearning = value;
}

bool PlayerCreatureImplementation::isTeachingOrLearning() {
	// server/zone/objects/player/PlayerCreature.idl():  	 return teachingOrLearning;
	return teachingOrLearning;
}

CreatureObject* PlayerCreatureImplementation::getConversatingCreature() {
	// server/zone/objects/player/PlayerCreature.idl():  		return conversatingCreature;
	return conversatingCreature;
}

int PlayerCreatureImplementation::getCenteredBonus() {
	// server/zone/objects/player/PlayerCreature.idl():  		return centeredBonus;
	return centeredBonus;
}

void PlayerCreatureImplementation::setCenteredBonus(int bonus) {
	// server/zone/objects/player/PlayerCreature.idl():  		centeredBonus = bonus;
	centeredBonus = bonus;
}

TradeContainer* PlayerCreatureImplementation::getTradeContainer() {
	// server/zone/objects/player/PlayerCreature.idl():  		return tradeContainer;
	return (&tradeContainer);
}

bool PlayerCreatureImplementation::hasBadge(unsigned int badge) {
	// server/zone/objects/player/PlayerCreature.idl():  		return badges.hasBadge(badge);
	return (&badges)->hasBadge(badge);
}

CraftingTool* PlayerCreatureImplementation::getLastCraftingToolUsed() {
	// server/zone/objects/player/PlayerCreature.idl():  		return lastCraftingToolUsed;
	return lastCraftingToolUsed;
}

void PlayerCreatureImplementation::setLastCraftingToolUsed(CraftingTool* tool) {
	// server/zone/objects/player/PlayerCreature.idl():  		lastCraftingToolUsed = tool;
	lastCraftingToolUsed = tool;
}

bool PlayerCreatureImplementation::isInvisible() {
	// server/zone/objects/player/PlayerCreature.idl():  		return invisible;
	return invisible;
}

void PlayerCreatureImplementation::setInvisible(bool invis) {
	// server/zone/objects/player/PlayerCreature.idl():  		invisible = invis;
	invisible = invis;
}

BuildingObject* PlayerCreatureImplementation::getDeclaredResidence() {
	// server/zone/objects/player/PlayerCreature.idl():  		return declaredResidence;
	return declaredResidence;
}

void PlayerCreatureImplementation::setDeclaredResidence(BuildingObject* residence) {
	// server/zone/objects/player/PlayerCreature.idl():  		declaredResidence = residence;
	declaredResidence = residence;
}

void PlayerCreatureImplementation::setCloningFacility(BuildingObject* cloningfac) {
	// server/zone/objects/player/PlayerCreature.idl():  		cloningFacility = cloningfac;
	cloningFacility = cloningfac;
}

BuildingObject* PlayerCreatureImplementation::getCloningFacility() {
	// server/zone/objects/player/PlayerCreature.idl():  		return cloningFacility;
	return cloningFacility;
}

/*
 *	PlayerCreatureAdapter
 */

PlayerCreatureAdapter::PlayerCreatureAdapter(PlayerCreatureImplementation* obj) : CreatureObjectAdapter(obj) {
}

enum {RPC_FINALIZE__ = 6,RPC_INITIALIZETRANSIENTMEMBERS__,RPC_NOTIFYLOADFROMDATABASE__,RPC_DISCONNECT__BOOL_BOOL_,RPC_UNLOAD__,RPC_RELOAD__ZONECLIENTSESSION_,RPC_LOGOUT__BOOL_,RPC_ACTIVATERECOVERY__,RPC_DORECOVERY__,RPC_TELEPORT__FLOAT_FLOAT_FLOAT_LONG_,RPC_UPDATEZONE__BOOL_BOOL_,RPC_UPDATEZONEWITHPARENT__SCENEOBJECT_BOOL_BOOL_,RPC_HANDLEOBJECTMENUSELECT__PLAYERCREATURE_BYTE_,RPC_INSERTTOBUILDING__BUILDINGOBJECT_,RPC_REMOVEFROMBUILDING__BUILDINGOBJECT_,RPC_UPDATETODATABASE__,RPC_SENDMESSAGE__BASEPACKET_,RPC_SENDTOOWNER__BOOL_,RPC_SENDBADGESRESPONSETO__PLAYERCREATURE_,RPC_UNLOADSPAWNEDCHILDREN__,RPC_ISAGGRESSIVETO__PLAYERCREATURE_,RPC_SENDEXECUTECONSOLECOMMAND__STRING_,RPC_ISATTACKABLEBY__CREATUREOBJECT_,RPC_CANADDOBJECT__SCENEOBJECT_INT_STRING_,RPC_NOTIFYOBJECTINSERTED__SCENEOBJECT_,RPC_NOTIFYOBJECTREMOVED__SCENEOBJECT_,RPC_NOTIFYOBJECTDESTRUCTIONOBSERVERS__TANGIBLEOBJECT_INT_,RPC_SETCOMBATSTATE__,RPC_SETBADGE__INT_,RPC_AWARDBADGE__INT_,RPC_GETNUMBADGES__,RPC_GETBADGETYPECOUNT__BYTE_,RPC_ISFIRSTINCAPACITATIONEXPIRED__,RPC_RESETINCAPACITATIONCOUNTER__,RPC_RESETFIRSTINCAPACITATIONTIME__,RPC_UPDATEINCAPACITATIONCOUNTER__,RPC_ISFIRSTINCAPACITATION__,RPC_GETINCAPACITATIONCOUNTER__,RPC_SETLASTNPCCONVSTR__STRING_,RPC_SETLASTNPCCONVMESSSTR__STRING_,RPC_GETLASTNPCCONVSTR__,RPC_GETLASTNPCCONVMESSSTR__,RPC_GETLASTNPCCONVOPTION__INT_,RPC_ADDLASTNPCCONVOPTIONS__STRING_,RPC_COUNTLASTNPCCONVOPTIONS__,RPC_CLEARLASTNPCCONVOPTIONS__,RPC_SETSPAWNEDBLUEFROG__,RPC_HASSPAWNEDBLUEFROG__,RPC_ADDTOCONSENTLIST__STRING_,RPC_HASINCONSENTLIST__STRING_,RPC_REMOVEFROMCONSENTLIST__STRING_,RPC_GETCONSENTNAME__INT_,RPC_GETCONSENTLISTSIZE__,RPC_ADDTODUELLIST__PLAYERCREATURE_,RPC_REMOVEFROMDUELLIST__PLAYERCREATURE_,RPC_GETDUELLISTOBJECT__INT_,RPC_REQUESTEDDUELTO__PLAYERCREATURE_,RPC_ISDUELLISTEMPTY__,RPC_GETDUELLISTSIZE__,RPC_NOTIFYSCENEREADY__,RPC_NOTIFYSELFPOSITIONUPDATE__,RPC_ADDPERSISTENTMESSAGE__LONG_,RPC_DROPPERSISTENTMESSAGE__LONG_,RPC_GETPLAYEROBJECT__,RPC_ISONLINE__,RPC_ISOFFLINE__,RPC_ISLOADING__,RPC_ISLINKDEAD__,RPC_ISLOGGINGIN__,RPC_ISLOGGINGOUT__,RPC_GETACCOUNTID__,RPC_ISTELEPORTING__,RPC_GETCLIENT__,RPC_GETRACEID__,RPC_GETSAVEDPARENTID__,RPC_GETSERVERMOVEMENTTIMEDELTA__,RPC_GETSAVEDZONEID__,RPC_GETFIRSTNAME__,RPC_GETLASTNAME__,RPC_SETSAVEDPARENTID__LONG_,RPC_SETSAVEDZONEID__INT_,RPC_SETSKILLPOINTS__INT_,RPC_SETTELEPORTING__BOOL_,RPC_ADDSKILLPOINTS__INT_,RPC_SETCLIENT__ZONECLIENTSESSION_,RPC_SETBIOGRAPHY__UNICODESTRING_,RPC_SETRACEID__BYTE_,RPC_SETCONVERSATINGCREATURE__CREATUREOBJECT_,RPC_SETCLIENTLASTMOVEMENTSTAMP__INT_,RPC_UPDATESERVERLASTMOVEMENTSTAMP__,RPC_SETOFFLINE__,RPC_SETLINKDEAD__,RPC_SETONLINE__,RPC_SETLOGGINGOUT__,RPC_SETACCOUNTID__INT_,RPC_CLEARDISCONNECTEVENT__,RPC_CLEARRECOVERYEVENT__,RPC_ADDCHATROOM__CHATROOM_,RPC_REMOVECHATROOM__CHATROOM_,RPC_GETSKILLPOINTS__,RPC_GETNEWSUIBOXID__INT_,RPC_HASSUIBOX__INT_,RPC_GETSUIBOX__INT_,RPC_REMOVESUIBOX__INT_BOOL_,RPC_REMOVESUIBOXTYPE__INT_,RPC_HASSUIBOXWINDOWTYPE__INT_,RPC_CLOSESUIWINDOWTYPE__INT_,RPC_GETSUIBOXFROMWINDOWTYPE__INT_,RPC_ADDSUIBOX__SUIBOX_,RPC_GETLOTSREMAINING__,RPC_SETLOTSREMAINING__INT_,RPC_GETFACTIONSTATUS__,RPC_GETBIOGRAPHY__,RPC_GETCLIENTLASTMOVEMENTSTAMP__,RPC_SETSURVEYTOOL__SURVEYTOOL_,RPC_GETSURVEYTOOL__,RPC_SETTEACHINGORLEARNING__BOOL_,RPC_GETSURVEYWAYPOINT__,RPC_GETCONVERSATINGCREATURE__,RPC_GETCENTEREDBONUS__,RPC_SETCENTEREDBONUS__INT_,RPC_HASBADGE__INT_,RPC_GETLASTCRAFTINGTOOLUSED__,RPC_SETLASTCRAFTINGTOOLUSED__CRAFTINGTOOL_,RPC_ISINVISIBLE__,RPC_SETINVISIBLE__BOOL_,RPC_GETDECLAREDRESIDENCE__,RPC_SETDECLAREDRESIDENCE__BUILDINGOBJECT_,RPC_SETCLONINGFACILITY__BUILDINGOBJECT_,RPC_GETCLONINGFACILITY__,};

Packet* PlayerCreatureAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	Packet* resp = new MethodReturnMessage(0);

	switch (methid) {
	case RPC_FINALIZE__:
		finalize();
		break;
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		initializeTransientMembers();
		break;
	case RPC_NOTIFYLOADFROMDATABASE__:
		notifyLoadFromDatabase();
		break;
	case RPC_DISCONNECT__BOOL_BOOL_:
		disconnect(inv->getBooleanParameter(), inv->getBooleanParameter());
		break;
	case RPC_UNLOAD__:
		unload();
		break;
	case RPC_RELOAD__ZONECLIENTSESSION_:
		reload((ZoneClientSession*) inv->getObjectParameter());
		break;
	case RPC_LOGOUT__BOOL_:
		logout(inv->getBooleanParameter());
		break;
	case RPC_ACTIVATERECOVERY__:
		activateRecovery();
		break;
	case RPC_DORECOVERY__:
		doRecovery();
		break;
	case RPC_TELEPORT__FLOAT_FLOAT_FLOAT_LONG_:
		teleport(inv->getFloatParameter(), inv->getFloatParameter(), inv->getFloatParameter(), inv->getUnsignedLongParameter());
		break;
	case RPC_UPDATEZONE__BOOL_BOOL_:
		updateZone(inv->getBooleanParameter(), inv->getBooleanParameter());
		break;
	case RPC_UPDATEZONEWITHPARENT__SCENEOBJECT_BOOL_BOOL_:
		updateZoneWithParent((SceneObject*) inv->getObjectParameter(), inv->getBooleanParameter(), inv->getBooleanParameter());
		break;
	case RPC_HANDLEOBJECTMENUSELECT__PLAYERCREATURE_BYTE_:
		resp->insertSignedInt(handleObjectMenuSelect((PlayerCreature*) inv->getObjectParameter(), inv->getByteParameter()));
		break;
	case RPC_INSERTTOBUILDING__BUILDINGOBJECT_:
		insertToBuilding((BuildingObject*) inv->getObjectParameter());
		break;
	case RPC_REMOVEFROMBUILDING__BUILDINGOBJECT_:
		removeFromBuilding((BuildingObject*) inv->getObjectParameter());
		break;
	case RPC_UPDATETODATABASE__:
		updateToDatabase();
		break;
	case RPC_SENDMESSAGE__BASEPACKET_:
		sendMessage((BasePacket*) inv->getObjectParameter());
		break;
	case RPC_SENDTOOWNER__BOOL_:
		sendToOwner(inv->getBooleanParameter());
		break;
	case RPC_SENDBADGESRESPONSETO__PLAYERCREATURE_:
		sendBadgesResponseTo((PlayerCreature*) inv->getObjectParameter());
		break;
	case RPC_UNLOADSPAWNEDCHILDREN__:
		unloadSpawnedChildren();
		break;
	case RPC_ISAGGRESSIVETO__PLAYERCREATURE_:
		resp->insertBoolean(isAggressiveTo((PlayerCreature*) inv->getObjectParameter()));
		break;
	case RPC_SENDEXECUTECONSOLECOMMAND__STRING_:
		sendExecuteConsoleCommand(inv->getAsciiParameter(_param0_sendExecuteConsoleCommand__String_));
		break;
	case RPC_ISATTACKABLEBY__CREATUREOBJECT_:
		resp->insertBoolean(isAttackableBy((CreatureObject*) inv->getObjectParameter()));
		break;
	case RPC_CANADDOBJECT__SCENEOBJECT_INT_STRING_:
		resp->insertSignedInt(canAddObject((SceneObject*) inv->getObjectParameter(), inv->getSignedIntParameter(), inv->getAsciiParameter(_param2_canAddObject__SceneObject_int_String_)));
		break;
	case RPC_NOTIFYOBJECTINSERTED__SCENEOBJECT_:
		resp->insertSignedInt(notifyObjectInserted((SceneObject*) inv->getObjectParameter()));
		break;
	case RPC_NOTIFYOBJECTREMOVED__SCENEOBJECT_:
		resp->insertSignedInt(notifyObjectRemoved((SceneObject*) inv->getObjectParameter()));
		break;
	case RPC_NOTIFYOBJECTDESTRUCTIONOBSERVERS__TANGIBLEOBJECT_INT_:
		resp->insertSignedInt(notifyObjectDestructionObservers((TangibleObject*) inv->getObjectParameter(), inv->getSignedIntParameter()));
		break;
	case RPC_SETCOMBATSTATE__:
		setCombatState();
		break;
	case RPC_SETBADGE__INT_:
		setBadge(inv->getUnsignedIntParameter());
		break;
	case RPC_AWARDBADGE__INT_:
		awardBadge(inv->getUnsignedIntParameter());
		break;
	case RPC_GETNUMBADGES__:
		resp->insertSignedInt(getNumBadges());
		break;
	case RPC_GETBADGETYPECOUNT__BYTE_:
		resp->insertSignedInt(getBadgeTypeCount(inv->getByteParameter()));
		break;
	case RPC_ISFIRSTINCAPACITATIONEXPIRED__:
		resp->insertBoolean(isFirstIncapacitationExpired());
		break;
	case RPC_RESETINCAPACITATIONCOUNTER__:
		resetIncapacitationCounter();
		break;
	case RPC_RESETFIRSTINCAPACITATIONTIME__:
		resetFirstIncapacitationTime();
		break;
	case RPC_UPDATEINCAPACITATIONCOUNTER__:
		updateIncapacitationCounter();
		break;
	case RPC_ISFIRSTINCAPACITATION__:
		resp->insertBoolean(isFirstIncapacitation());
		break;
	case RPC_GETINCAPACITATIONCOUNTER__:
		resp->insertByte(getIncapacitationCounter());
		break;
	case RPC_SETLASTNPCCONVSTR__STRING_:
		setLastNpcConvStr(inv->getAsciiParameter(_param0_setLastNpcConvStr__String_));
		break;
	case RPC_SETLASTNPCCONVMESSSTR__STRING_:
		setLastNpcConvMessStr(inv->getAsciiParameter(_param0_setLastNpcConvMessStr__String_));
		break;
	case RPC_GETLASTNPCCONVSTR__:
		resp->insertAscii(getLastNpcConvStr());
		break;
	case RPC_GETLASTNPCCONVMESSSTR__:
		resp->insertAscii(getLastNpcConvMessStr());
		break;
	case RPC_GETLASTNPCCONVOPTION__INT_:
		resp->insertAscii(getLastNpcConvOption(inv->getSignedIntParameter()));
		break;
	case RPC_ADDLASTNPCCONVOPTIONS__STRING_:
		addLastNpcConvOptions(inv->getAsciiParameter(_param0_addLastNpcConvOptions__String_));
		break;
	case RPC_COUNTLASTNPCCONVOPTIONS__:
		resp->insertSignedInt(countLastNpcConvOptions());
		break;
	case RPC_CLEARLASTNPCCONVOPTIONS__:
		clearLastNpcConvOptions();
		break;
	case RPC_SETSPAWNEDBLUEFROG__:
		setSpawnedBlueFrog();
		break;
	case RPC_HASSPAWNEDBLUEFROG__:
		resp->insertBoolean(hasSpawnedBlueFrog());
		break;
	case RPC_ADDTOCONSENTLIST__STRING_:
		addToConsentList(inv->getAsciiParameter(_param0_addToConsentList__String_));
		break;
	case RPC_HASINCONSENTLIST__STRING_:
		resp->insertBoolean(hasInConsentList(inv->getAsciiParameter(_param0_hasInConsentList__String_)));
		break;
	case RPC_REMOVEFROMCONSENTLIST__STRING_:
		removeFromConsentList(inv->getAsciiParameter(_param0_removeFromConsentList__String_));
		break;
	case RPC_GETCONSENTNAME__INT_:
		resp->insertAscii(getConsentName(inv->getSignedIntParameter()));
		break;
	case RPC_GETCONSENTLISTSIZE__:
		resp->insertSignedInt(getConsentListSize());
		break;
	case RPC_ADDTODUELLIST__PLAYERCREATURE_:
		addToDuelList((PlayerCreature*) inv->getObjectParameter());
		break;
	case RPC_REMOVEFROMDUELLIST__PLAYERCREATURE_:
		removeFromDuelList((PlayerCreature*) inv->getObjectParameter());
		break;
	case RPC_GETDUELLISTOBJECT__INT_:
		resp->insertLong(getDuelListObject(inv->getSignedIntParameter())->_getObjectID());
		break;
	case RPC_REQUESTEDDUELTO__PLAYERCREATURE_:
		resp->insertBoolean(requestedDuelTo((PlayerCreature*) inv->getObjectParameter()));
		break;
	case RPC_ISDUELLISTEMPTY__:
		resp->insertBoolean(isDuelListEmpty());
		break;
	case RPC_GETDUELLISTSIZE__:
		resp->insertSignedInt(getDuelListSize());
		break;
	case RPC_NOTIFYSCENEREADY__:
		notifySceneReady();
		break;
	case RPC_NOTIFYSELFPOSITIONUPDATE__:
		notifySelfPositionUpdate();
		break;
	case RPC_ADDPERSISTENTMESSAGE__LONG_:
		addPersistentMessage(inv->getUnsignedLongParameter());
		break;
	case RPC_DROPPERSISTENTMESSAGE__LONG_:
		dropPersistentMessage(inv->getUnsignedLongParameter());
		break;
	case RPC_GETPLAYEROBJECT__:
		resp->insertLong(getPlayerObject()->_getObjectID());
		break;
	case RPC_ISONLINE__:
		resp->insertBoolean(isOnline());
		break;
	case RPC_ISOFFLINE__:
		resp->insertBoolean(isOffline());
		break;
	case RPC_ISLOADING__:
		resp->insertBoolean(isLoading());
		break;
	case RPC_ISLINKDEAD__:
		resp->insertBoolean(isLinkDead());
		break;
	case RPC_ISLOGGINGIN__:
		resp->insertBoolean(isLoggingIn());
		break;
	case RPC_ISLOGGINGOUT__:
		resp->insertBoolean(isLoggingOut());
		break;
	case RPC_GETACCOUNTID__:
		resp->insertInt(getAccountID());
		break;
	case RPC_ISTELEPORTING__:
		resp->insertBoolean(isTeleporting());
		break;
	case RPC_GETCLIENT__:
		resp->insertLong(getClient()->_getObjectID());
		break;
	case RPC_GETRACEID__:
		resp->insertByte(getRaceID());
		break;
	case RPC_GETSAVEDPARENTID__:
		resp->insertLong(getSavedParentID());
		break;
	case RPC_GETSERVERMOVEMENTTIMEDELTA__:
		resp->insertLong(getServerMovementTimeDelta());
		break;
	case RPC_GETSAVEDZONEID__:
		resp->insertSignedInt(getSavedZoneID());
		break;
	case RPC_GETFIRSTNAME__:
		resp->insertAscii(getFirstName());
		break;
	case RPC_GETLASTNAME__:
		resp->insertAscii(getLastName());
		break;
	case RPC_SETSAVEDPARENTID__LONG_:
		setSavedParentID(inv->getUnsignedLongParameter());
		break;
	case RPC_SETSAVEDZONEID__INT_:
		setSavedZoneID(inv->getSignedIntParameter());
		break;
	case RPC_SETSKILLPOINTS__INT_:
		setSkillPoints(inv->getSignedIntParameter());
		break;
	case RPC_SETTELEPORTING__BOOL_:
		setTeleporting(inv->getBooleanParameter());
		break;
	case RPC_ADDSKILLPOINTS__INT_:
		addSkillPoints(inv->getSignedIntParameter());
		break;
	case RPC_SETCLIENT__ZONECLIENTSESSION_:
		setClient((ZoneClientSession*) inv->getObjectParameter());
		break;
	case RPC_SETBIOGRAPHY__UNICODESTRING_:
		setBiography(inv->getUnicodeParameter(_param0_setBiography__UnicodeString_));
		break;
	case RPC_SETRACEID__BYTE_:
		setRaceID(inv->getByteParameter());
		break;
	case RPC_SETCONVERSATINGCREATURE__CREATUREOBJECT_:
		setConversatingCreature((CreatureObject*) inv->getObjectParameter());
		break;
	case RPC_SETCLIENTLASTMOVEMENTSTAMP__INT_:
		setClientLastMovementStamp(inv->getUnsignedIntParameter());
		break;
	case RPC_UPDATESERVERLASTMOVEMENTSTAMP__:
		updateServerLastMovementStamp();
		break;
	case RPC_SETOFFLINE__:
		setOffline();
		break;
	case RPC_SETLINKDEAD__:
		setLinkDead();
		break;
	case RPC_SETONLINE__:
		setOnline();
		break;
	case RPC_SETLOGGINGOUT__:
		setLoggingOut();
		break;
	case RPC_SETACCOUNTID__INT_:
		setAccountID(inv->getUnsignedIntParameter());
		break;
	case RPC_CLEARDISCONNECTEVENT__:
		clearDisconnectEvent();
		break;
	case RPC_CLEARRECOVERYEVENT__:
		clearRecoveryEvent();
		break;
	case RPC_ADDCHATROOM__CHATROOM_:
		addChatRoom((ChatRoom*) inv->getObjectParameter());
		break;
	case RPC_REMOVECHATROOM__CHATROOM_:
		removeChatRoom((ChatRoom*) inv->getObjectParameter());
		break;
	case RPC_GETSKILLPOINTS__:
		resp->insertSignedInt(getSkillPoints());
		break;
	case RPC_GETNEWSUIBOXID__INT_:
		resp->insertInt(getNewSuiBoxID(inv->getUnsignedIntParameter()));
		break;
	case RPC_HASSUIBOX__INT_:
		resp->insertBoolean(hasSuiBox(inv->getUnsignedIntParameter()));
		break;
	case RPC_GETSUIBOX__INT_:
		resp->insertLong(getSuiBox(inv->getUnsignedIntParameter())->_getObjectID());
		break;
	case RPC_REMOVESUIBOX__INT_BOOL_:
		removeSuiBox(inv->getUnsignedIntParameter(), inv->getBooleanParameter());
		break;
	case RPC_REMOVESUIBOXTYPE__INT_:
		removeSuiBoxType(inv->getUnsignedIntParameter());
		break;
	case RPC_HASSUIBOXWINDOWTYPE__INT_:
		resp->insertBoolean(hasSuiBoxWindowType(inv->getUnsignedIntParameter()));
		break;
	case RPC_CLOSESUIWINDOWTYPE__INT_:
		closeSuiWindowType(inv->getUnsignedIntParameter());
		break;
	case RPC_GETSUIBOXFROMWINDOWTYPE__INT_:
		resp->insertLong(getSuiBoxFromWindowType(inv->getUnsignedIntParameter())->_getObjectID());
		break;
	case RPC_ADDSUIBOX__SUIBOX_:
		addSuiBox((SuiBox*) inv->getObjectParameter());
		break;
	case RPC_GETLOTSREMAINING__:
		resp->insertSignedInt(getLotsRemaining());
		break;
	case RPC_SETLOTSREMAINING__INT_:
		setLotsRemaining(inv->getSignedIntParameter());
		break;
	case RPC_GETFACTIONSTATUS__:
		resp->insertSignedInt(getFactionStatus());
		break;
	case RPC_GETBIOGRAPHY__:
		resp->insertUnicode(getBiography());
		break;
	case RPC_GETCLIENTLASTMOVEMENTSTAMP__:
		resp->insertInt(getClientLastMovementStamp());
		break;
	case RPC_SETSURVEYTOOL__SURVEYTOOL_:
		setSurveyTool((SurveyTool*) inv->getObjectParameter());
		break;
	case RPC_GETSURVEYTOOL__:
		resp->insertLong(getSurveyTool()->_getObjectID());
		break;
	case RPC_SETTEACHINGORLEARNING__BOOL_:
		setTeachingOrLearning(inv->getBooleanParameter());
		break;
	case RPC_GETSURVEYWAYPOINT__:
		resp->insertLong(getSurveyWaypoint()->_getObjectID());
		break;
	case RPC_GETCONVERSATINGCREATURE__:
		resp->insertLong(getConversatingCreature()->_getObjectID());
		break;
	case RPC_GETCENTEREDBONUS__:
		resp->insertSignedInt(getCenteredBonus());
		break;
	case RPC_SETCENTEREDBONUS__INT_:
		setCenteredBonus(inv->getSignedIntParameter());
		break;
	case RPC_HASBADGE__INT_:
		resp->insertBoolean(hasBadge(inv->getUnsignedIntParameter()));
		break;
	case RPC_GETLASTCRAFTINGTOOLUSED__:
		resp->insertLong(getLastCraftingToolUsed()->_getObjectID());
		break;
	case RPC_SETLASTCRAFTINGTOOLUSED__CRAFTINGTOOL_:
		setLastCraftingToolUsed((CraftingTool*) inv->getObjectParameter());
		break;
	case RPC_ISINVISIBLE__:
		resp->insertBoolean(isInvisible());
		break;
	case RPC_SETINVISIBLE__BOOL_:
		setInvisible(inv->getBooleanParameter());
		break;
	case RPC_GETDECLAREDRESIDENCE__:
		resp->insertLong(getDeclaredResidence()->_getObjectID());
		break;
	case RPC_SETDECLAREDRESIDENCE__BUILDINGOBJECT_:
		setDeclaredResidence((BuildingObject*) inv->getObjectParameter());
		break;
	case RPC_SETCLONINGFACILITY__BUILDINGOBJECT_:
		setCloningFacility((BuildingObject*) inv->getObjectParameter());
		break;
	case RPC_GETCLONINGFACILITY__:
		resp->insertLong(getCloningFacility()->_getObjectID());
		break;
	default:
		return NULL;
	}

	return resp;
}

void PlayerCreatureAdapter::finalize() {
	((PlayerCreatureImplementation*) impl)->finalize();
}

void PlayerCreatureAdapter::initializeTransientMembers() {
	((PlayerCreatureImplementation*) impl)->initializeTransientMembers();
}

void PlayerCreatureAdapter::notifyLoadFromDatabase() {
	((PlayerCreatureImplementation*) impl)->notifyLoadFromDatabase();
}

void PlayerCreatureAdapter::disconnect(bool closeClient, bool doLock) {
	((PlayerCreatureImplementation*) impl)->disconnect(closeClient, doLock);
}

void PlayerCreatureAdapter::unload() {
	((PlayerCreatureImplementation*) impl)->unload();
}

void PlayerCreatureAdapter::reload(ZoneClientSession* client) {
	((PlayerCreatureImplementation*) impl)->reload(client);
}

void PlayerCreatureAdapter::logout(bool doLock) {
	((PlayerCreatureImplementation*) impl)->logout(doLock);
}

void PlayerCreatureAdapter::activateRecovery() {
	((PlayerCreatureImplementation*) impl)->activateRecovery();
}

void PlayerCreatureAdapter::doRecovery() {
	((PlayerCreatureImplementation*) impl)->doRecovery();
}

void PlayerCreatureAdapter::teleport(float newPositionX, float newPositionZ, float newPositionY, unsigned long long parentID) {
	((PlayerCreatureImplementation*) impl)->teleport(newPositionX, newPositionZ, newPositionY, parentID);
}

void PlayerCreatureAdapter::updateZone(bool lightUpdate, bool sendPackets) {
	((PlayerCreatureImplementation*) impl)->updateZone(lightUpdate, sendPackets);
}

void PlayerCreatureAdapter::updateZoneWithParent(SceneObject* newParent, bool lightUpdate, bool sendPackets) {
	((PlayerCreatureImplementation*) impl)->updateZoneWithParent(newParent, lightUpdate, sendPackets);
}

int PlayerCreatureAdapter::handleObjectMenuSelect(PlayerCreature* player, byte selectedID) {
	return ((PlayerCreatureImplementation*) impl)->handleObjectMenuSelect(player, selectedID);
}

void PlayerCreatureAdapter::insertToBuilding(BuildingObject* building) {
	((PlayerCreatureImplementation*) impl)->insertToBuilding(building);
}

void PlayerCreatureAdapter::removeFromBuilding(BuildingObject* building) {
	((PlayerCreatureImplementation*) impl)->removeFromBuilding(building);
}

void PlayerCreatureAdapter::updateToDatabase() {
	((PlayerCreatureImplementation*) impl)->updateToDatabase();
}

void PlayerCreatureAdapter::sendMessage(BasePacket* msg) {
	((PlayerCreatureImplementation*) impl)->sendMessage(msg);
}

void PlayerCreatureAdapter::sendToOwner(bool doClose) {
	((PlayerCreatureImplementation*) impl)->sendToOwner(doClose);
}

void PlayerCreatureAdapter::sendBadgesResponseTo(PlayerCreature* player) {
	((PlayerCreatureImplementation*) impl)->sendBadgesResponseTo(player);
}

void PlayerCreatureAdapter::unloadSpawnedChildren() {
	((PlayerCreatureImplementation*) impl)->unloadSpawnedChildren();
}

bool PlayerCreatureAdapter::isAggressiveTo(PlayerCreature* object) {
	return ((PlayerCreatureImplementation*) impl)->isAggressiveTo(object);
}

void PlayerCreatureAdapter::sendExecuteConsoleCommand(const String& command) {
	((PlayerCreatureImplementation*) impl)->sendExecuteConsoleCommand(command);
}

bool PlayerCreatureAdapter::isAttackableBy(CreatureObject* object) {
	return ((PlayerCreatureImplementation*) impl)->isAttackableBy(object);
}

int PlayerCreatureAdapter::canAddObject(SceneObject* object, int containmentType, String& errorDescription) {
	return ((PlayerCreatureImplementation*) impl)->canAddObject(object, containmentType, errorDescription);
}

int PlayerCreatureAdapter::notifyObjectInserted(SceneObject* object) {
	return ((PlayerCreatureImplementation*) impl)->notifyObjectInserted(object);
}

int PlayerCreatureAdapter::notifyObjectRemoved(SceneObject* object) {
	return ((PlayerCreatureImplementation*) impl)->notifyObjectRemoved(object);
}

int PlayerCreatureAdapter::notifyObjectDestructionObservers(TangibleObject* attacker, int condition) {
	return ((PlayerCreatureImplementation*) impl)->notifyObjectDestructionObservers(attacker, condition);
}

void PlayerCreatureAdapter::setCombatState() {
	((PlayerCreatureImplementation*) impl)->setCombatState();
}

void PlayerCreatureAdapter::setBadge(unsigned int badge) {
	((PlayerCreatureImplementation*) impl)->setBadge(badge);
}

void PlayerCreatureAdapter::awardBadge(unsigned int badge) {
	((PlayerCreatureImplementation*) impl)->awardBadge(badge);
}

int PlayerCreatureAdapter::getNumBadges() {
	return ((PlayerCreatureImplementation*) impl)->getNumBadges();
}

int PlayerCreatureAdapter::getBadgeTypeCount(byte type) {
	return ((PlayerCreatureImplementation*) impl)->getBadgeTypeCount(type);
}

bool PlayerCreatureAdapter::isFirstIncapacitationExpired() {
	return ((PlayerCreatureImplementation*) impl)->isFirstIncapacitationExpired();
}

void PlayerCreatureAdapter::resetIncapacitationCounter() {
	((PlayerCreatureImplementation*) impl)->resetIncapacitationCounter();
}

void PlayerCreatureAdapter::resetFirstIncapacitationTime() {
	((PlayerCreatureImplementation*) impl)->resetFirstIncapacitationTime();
}

void PlayerCreatureAdapter::updateIncapacitationCounter() {
	((PlayerCreatureImplementation*) impl)->updateIncapacitationCounter();
}

bool PlayerCreatureAdapter::isFirstIncapacitation() {
	return ((PlayerCreatureImplementation*) impl)->isFirstIncapacitation();
}

byte PlayerCreatureAdapter::getIncapacitationCounter() {
	return ((PlayerCreatureImplementation*) impl)->getIncapacitationCounter();
}

void PlayerCreatureAdapter::setLastNpcConvStr(const String& conv) {
	((PlayerCreatureImplementation*) impl)->setLastNpcConvStr(conv);
}

void PlayerCreatureAdapter::setLastNpcConvMessStr(const String& mess) {
	((PlayerCreatureImplementation*) impl)->setLastNpcConvMessStr(mess);
}

String PlayerCreatureAdapter::getLastNpcConvStr() {
	return ((PlayerCreatureImplementation*) impl)->getLastNpcConvStr();
}

String PlayerCreatureAdapter::getLastNpcConvMessStr() {
	return ((PlayerCreatureImplementation*) impl)->getLastNpcConvMessStr();
}

String PlayerCreatureAdapter::getLastNpcConvOption(int idx) {
	return ((PlayerCreatureImplementation*) impl)->getLastNpcConvOption(idx);
}

void PlayerCreatureAdapter::addLastNpcConvOptions(const String& option) {
	((PlayerCreatureImplementation*) impl)->addLastNpcConvOptions(option);
}

int PlayerCreatureAdapter::countLastNpcConvOptions() {
	return ((PlayerCreatureImplementation*) impl)->countLastNpcConvOptions();
}

void PlayerCreatureAdapter::clearLastNpcConvOptions() {
	((PlayerCreatureImplementation*) impl)->clearLastNpcConvOptions();
}

void PlayerCreatureAdapter::setSpawnedBlueFrog() {
	((PlayerCreatureImplementation*) impl)->setSpawnedBlueFrog();
}

bool PlayerCreatureAdapter::hasSpawnedBlueFrog() {
	return ((PlayerCreatureImplementation*) impl)->hasSpawnedBlueFrog();
}

void PlayerCreatureAdapter::addToConsentList(const String& name) {
	((PlayerCreatureImplementation*) impl)->addToConsentList(name);
}

bool PlayerCreatureAdapter::hasInConsentList(const String& name) {
	return ((PlayerCreatureImplementation*) impl)->hasInConsentList(name);
}

void PlayerCreatureAdapter::removeFromConsentList(const String& name) {
	((PlayerCreatureImplementation*) impl)->removeFromConsentList(name);
}

String PlayerCreatureAdapter::getConsentName(int i) {
	return ((PlayerCreatureImplementation*) impl)->getConsentName(i);
}

int PlayerCreatureAdapter::getConsentListSize() {
	return ((PlayerCreatureImplementation*) impl)->getConsentListSize();
}

void PlayerCreatureAdapter::addToDuelList(PlayerCreature* targetPlayer) {
	((PlayerCreatureImplementation*) impl)->addToDuelList(targetPlayer);
}

void PlayerCreatureAdapter::removeFromDuelList(PlayerCreature* targetPlayer) {
	((PlayerCreatureImplementation*) impl)->removeFromDuelList(targetPlayer);
}

PlayerCreature* PlayerCreatureAdapter::getDuelListObject(int index) {
	return ((PlayerCreatureImplementation*) impl)->getDuelListObject(index);
}

bool PlayerCreatureAdapter::requestedDuelTo(PlayerCreature* targetPlayer) {
	return ((PlayerCreatureImplementation*) impl)->requestedDuelTo(targetPlayer);
}

bool PlayerCreatureAdapter::isDuelListEmpty() {
	return ((PlayerCreatureImplementation*) impl)->isDuelListEmpty();
}

int PlayerCreatureAdapter::getDuelListSize() {
	return ((PlayerCreatureImplementation*) impl)->getDuelListSize();
}

void PlayerCreatureAdapter::notifySceneReady() {
	((PlayerCreatureImplementation*) impl)->notifySceneReady();
}

void PlayerCreatureAdapter::notifySelfPositionUpdate() {
	((PlayerCreatureImplementation*) impl)->notifySelfPositionUpdate();
}

void PlayerCreatureAdapter::addPersistentMessage(unsigned long long id) {
	((PlayerCreatureImplementation*) impl)->addPersistentMessage(id);
}

void PlayerCreatureAdapter::dropPersistentMessage(unsigned long long id) {
	((PlayerCreatureImplementation*) impl)->dropPersistentMessage(id);
}

PlayerObject* PlayerCreatureAdapter::getPlayerObject() {
	return ((PlayerCreatureImplementation*) impl)->getPlayerObject();
}

bool PlayerCreatureAdapter::isOnline() {
	return ((PlayerCreatureImplementation*) impl)->isOnline();
}

bool PlayerCreatureAdapter::isOffline() {
	return ((PlayerCreatureImplementation*) impl)->isOffline();
}

bool PlayerCreatureAdapter::isLoading() {
	return ((PlayerCreatureImplementation*) impl)->isLoading();
}

bool PlayerCreatureAdapter::isLinkDead() {
	return ((PlayerCreatureImplementation*) impl)->isLinkDead();
}

bool PlayerCreatureAdapter::isLoggingIn() {
	return ((PlayerCreatureImplementation*) impl)->isLoggingIn();
}

bool PlayerCreatureAdapter::isLoggingOut() {
	return ((PlayerCreatureImplementation*) impl)->isLoggingOut();
}

unsigned int PlayerCreatureAdapter::getAccountID() {
	return ((PlayerCreatureImplementation*) impl)->getAccountID();
}

bool PlayerCreatureAdapter::isTeleporting() {
	return ((PlayerCreatureImplementation*) impl)->isTeleporting();
}

ZoneClientSession* PlayerCreatureAdapter::getClient() {
	return ((PlayerCreatureImplementation*) impl)->getClient();
}

byte PlayerCreatureAdapter::getRaceID() {
	return ((PlayerCreatureImplementation*) impl)->getRaceID();
}

unsigned long long PlayerCreatureAdapter::getSavedParentID() {
	return ((PlayerCreatureImplementation*) impl)->getSavedParentID();
}

unsigned long long PlayerCreatureAdapter::getServerMovementTimeDelta() {
	return ((PlayerCreatureImplementation*) impl)->getServerMovementTimeDelta();
}

int PlayerCreatureAdapter::getSavedZoneID() {
	return ((PlayerCreatureImplementation*) impl)->getSavedZoneID();
}

String PlayerCreatureAdapter::getFirstName() {
	return ((PlayerCreatureImplementation*) impl)->getFirstName();
}

String PlayerCreatureAdapter::getLastName() {
	return ((PlayerCreatureImplementation*) impl)->getLastName();
}

void PlayerCreatureAdapter::setSavedParentID(unsigned long long id) {
	((PlayerCreatureImplementation*) impl)->setSavedParentID(id);
}

void PlayerCreatureAdapter::setSavedZoneID(int id) {
	((PlayerCreatureImplementation*) impl)->setSavedZoneID(id);
}

void PlayerCreatureAdapter::setSkillPoints(int points) {
	((PlayerCreatureImplementation*) impl)->setSkillPoints(points);
}

void PlayerCreatureAdapter::setTeleporting(bool val) {
	((PlayerCreatureImplementation*) impl)->setTeleporting(val);
}

void PlayerCreatureAdapter::addSkillPoints(int points) {
	((PlayerCreatureImplementation*) impl)->addSkillPoints(points);
}

void PlayerCreatureAdapter::setClient(ZoneClientSession* cli) {
	((PlayerCreatureImplementation*) impl)->setClient(cli);
}

void PlayerCreatureAdapter::setBiography(const UnicodeString& bio) {
	((PlayerCreatureImplementation*) impl)->setBiography(bio);
}

void PlayerCreatureAdapter::setRaceID(byte id) {
	((PlayerCreatureImplementation*) impl)->setRaceID(id);
}

void PlayerCreatureAdapter::setConversatingCreature(CreatureObject* creature) {
	((PlayerCreatureImplementation*) impl)->setConversatingCreature(creature);
}

void PlayerCreatureAdapter::setClientLastMovementStamp(unsigned int stamp) {
	((PlayerCreatureImplementation*) impl)->setClientLastMovementStamp(stamp);
}

void PlayerCreatureAdapter::updateServerLastMovementStamp() {
	((PlayerCreatureImplementation*) impl)->updateServerLastMovementStamp();
}

void PlayerCreatureAdapter::setOffline() {
	((PlayerCreatureImplementation*) impl)->setOffline();
}

void PlayerCreatureAdapter::setLinkDead() {
	((PlayerCreatureImplementation*) impl)->setLinkDead();
}

void PlayerCreatureAdapter::setOnline() {
	((PlayerCreatureImplementation*) impl)->setOnline();
}

void PlayerCreatureAdapter::setLoggingOut() {
	((PlayerCreatureImplementation*) impl)->setLoggingOut();
}

void PlayerCreatureAdapter::setAccountID(unsigned int id) {
	((PlayerCreatureImplementation*) impl)->setAccountID(id);
}

void PlayerCreatureAdapter::clearDisconnectEvent() {
	((PlayerCreatureImplementation*) impl)->clearDisconnectEvent();
}

void PlayerCreatureAdapter::clearRecoveryEvent() {
	((PlayerCreatureImplementation*) impl)->clearRecoveryEvent();
}

void PlayerCreatureAdapter::addChatRoom(ChatRoom* room) {
	((PlayerCreatureImplementation*) impl)->addChatRoom(room);
}

void PlayerCreatureAdapter::removeChatRoom(ChatRoom* room) {
	((PlayerCreatureImplementation*) impl)->removeChatRoom(room);
}

int PlayerCreatureAdapter::getSkillPoints() {
	return ((PlayerCreatureImplementation*) impl)->getSkillPoints();
}

unsigned int PlayerCreatureAdapter::getNewSuiBoxID(unsigned int type) {
	return ((PlayerCreatureImplementation*) impl)->getNewSuiBoxID(type);
}

bool PlayerCreatureAdapter::hasSuiBox(unsigned int boxID) {
	return ((PlayerCreatureImplementation*) impl)->hasSuiBox(boxID);
}

SuiBox* PlayerCreatureAdapter::getSuiBox(unsigned int boxID) {
	return ((PlayerCreatureImplementation*) impl)->getSuiBox(boxID);
}

void PlayerCreatureAdapter::removeSuiBox(unsigned int boxID, bool closeWindowToClient) {
	((PlayerCreatureImplementation*) impl)->removeSuiBox(boxID, closeWindowToClient);
}

void PlayerCreatureAdapter::removeSuiBoxType(unsigned int windowType) {
	((PlayerCreatureImplementation*) impl)->removeSuiBoxType(windowType);
}

bool PlayerCreatureAdapter::hasSuiBoxWindowType(unsigned int windowType) {
	return ((PlayerCreatureImplementation*) impl)->hasSuiBoxWindowType(windowType);
}

void PlayerCreatureAdapter::closeSuiWindowType(unsigned int windowType) {
	((PlayerCreatureImplementation*) impl)->closeSuiWindowType(windowType);
}

SuiBox* PlayerCreatureAdapter::getSuiBoxFromWindowType(unsigned int windowType) {
	return ((PlayerCreatureImplementation*) impl)->getSuiBoxFromWindowType(windowType);
}

void PlayerCreatureAdapter::addSuiBox(SuiBox* sui) {
	((PlayerCreatureImplementation*) impl)->addSuiBox(sui);
}

int PlayerCreatureAdapter::getLotsRemaining() {
	return ((PlayerCreatureImplementation*) impl)->getLotsRemaining();
}

void PlayerCreatureAdapter::setLotsRemaining(int lots) {
	((PlayerCreatureImplementation*) impl)->setLotsRemaining(lots);
}

int PlayerCreatureAdapter::getFactionStatus() {
	return ((PlayerCreatureImplementation*) impl)->getFactionStatus();
}

UnicodeString PlayerCreatureAdapter::getBiography() {
	return ((PlayerCreatureImplementation*) impl)->getBiography();
}

unsigned int PlayerCreatureAdapter::getClientLastMovementStamp() {
	return ((PlayerCreatureImplementation*) impl)->getClientLastMovementStamp();
}

void PlayerCreatureAdapter::setSurveyTool(SurveyTool* tool) {
	((PlayerCreatureImplementation*) impl)->setSurveyTool(tool);
}

SurveyTool* PlayerCreatureAdapter::getSurveyTool() {
	return ((PlayerCreatureImplementation*) impl)->getSurveyTool();
}

void PlayerCreatureAdapter::setTeachingOrLearning(bool value) {
	((PlayerCreatureImplementation*) impl)->setTeachingOrLearning(value);
}

WaypointObject* PlayerCreatureAdapter::getSurveyWaypoint() {
	return ((PlayerCreatureImplementation*) impl)->getSurveyWaypoint();
}

CreatureObject* PlayerCreatureAdapter::getConversatingCreature() {
	return ((PlayerCreatureImplementation*) impl)->getConversatingCreature();
}

int PlayerCreatureAdapter::getCenteredBonus() {
	return ((PlayerCreatureImplementation*) impl)->getCenteredBonus();
}

void PlayerCreatureAdapter::setCenteredBonus(int bonus) {
	((PlayerCreatureImplementation*) impl)->setCenteredBonus(bonus);
}

bool PlayerCreatureAdapter::hasBadge(unsigned int badge) {
	return ((PlayerCreatureImplementation*) impl)->hasBadge(badge);
}

CraftingTool* PlayerCreatureAdapter::getLastCraftingToolUsed() {
	return ((PlayerCreatureImplementation*) impl)->getLastCraftingToolUsed();
}

void PlayerCreatureAdapter::setLastCraftingToolUsed(CraftingTool* tool) {
	((PlayerCreatureImplementation*) impl)->setLastCraftingToolUsed(tool);
}

bool PlayerCreatureAdapter::isInvisible() {
	return ((PlayerCreatureImplementation*) impl)->isInvisible();
}

void PlayerCreatureAdapter::setInvisible(bool invis) {
	((PlayerCreatureImplementation*) impl)->setInvisible(invis);
}

BuildingObject* PlayerCreatureAdapter::getDeclaredResidence() {
	return ((PlayerCreatureImplementation*) impl)->getDeclaredResidence();
}

void PlayerCreatureAdapter::setDeclaredResidence(BuildingObject* residence) {
	((PlayerCreatureImplementation*) impl)->setDeclaredResidence(residence);
}

void PlayerCreatureAdapter::setCloningFacility(BuildingObject* cloningfac) {
	((PlayerCreatureImplementation*) impl)->setCloningFacility(cloningfac);
}

BuildingObject* PlayerCreatureAdapter::getCloningFacility() {
	return ((PlayerCreatureImplementation*) impl)->getCloningFacility();
}

/*
 *	PlayerCreatureHelper
 */

PlayerCreatureHelper* PlayerCreatureHelper::staticInitializer = PlayerCreatureHelper::instance();

PlayerCreatureHelper::PlayerCreatureHelper() {
	className = "PlayerCreature";

	Core::getObjectBroker()->registerClass(className, this);
}

void PlayerCreatureHelper::finalizeHelper() {
	PlayerCreatureHelper::finalize();
}

DistributedObject* PlayerCreatureHelper::instantiateObject() {
	return new PlayerCreature(DummyConstructorParameter::instance());
}

DistributedObjectServant* PlayerCreatureHelper::instantiateServant() {
	return new PlayerCreatureImplementation(DummyConstructorParameter::instance());
}

DistributedObjectAdapter* PlayerCreatureHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new PlayerCreatureAdapter((PlayerCreatureImplementation*) obj->_getImplementation());

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

