/*
 *	server/zone/objects/tangible/weapons/Weapon.cpp generated by engine3 IDL compiler 0.55
 */

#include "Weapon.h"

#include "WeaponImplementation.h"

#include "../../scene/SceneObject.h"

#include "../../creature/CreatureObject.h"

#include "../../player/Player.h"

#include "../TangibleObject.h"

#include "../powerup/Powerup.h"

/*
 *	WeaponStub
 */

Weapon::Weapon(unsigned long long oid, unsigned int tempCRC, const UnicodeString& n, const String& tempn, bool eqp, int tp, int cat) : TangibleObject(DummyConstructorParameter::instance()) {
	_impl = new WeaponImplementation(oid, tempCRC, n, tempn, eqp, tp, cat);
	_impl->_setStub(this);
}

Weapon::Weapon(CreatureObject* creature, const String& temp, const UnicodeString& n, const String& tempn, bool eqp, int tp, int cat) : TangibleObject(DummyConstructorParameter::instance()) {
	_impl = new WeaponImplementation(creature, temp, n, tempn, eqp, tp, cat);
	_impl->_setStub(this);
}

Weapon::Weapon(DummyConstructorParameter* param) : TangibleObject(param) {
}

Weapon::~Weapon() {
}

void Weapon::sendTo(Player* player, bool doClose) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 6);
		method.addObjectParameter(player);
		method.addBooleanParameter(doClose);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->sendTo(player, doClose);
}

void Weapon::setWeaponStats(int modifier) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 7);
		method.addSignedIntParameter(modifier);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->setWeaponStats(modifier);
}

void Weapon::decay(float decayRate) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 8);
		method.addFloatParameter(decayRate);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->decay(decayRate);
}

void Weapon::removePowerup(Player* player, bool notify) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 9);
		method.addObjectParameter(player);
		method.addBooleanParameter(notify);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->removePowerup(player, notify);
}

bool Weapon::decreasePowerupUses() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 10);

		return method.executeWithBooleanReturn();
	} else
		return ((WeaponImplementation*) _impl)->decreasePowerupUses();
}

bool Weapon::decreaseUsesRemaining() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 11);

		return method.executeWithBooleanReturn();
	} else
		return ((WeaponImplementation*) _impl)->decreaseUsesRemaining();
}

bool Weapon::isJedi() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 12);

		return method.executeWithBooleanReturn();
	} else
		return ((WeaponImplementation*) _impl)->isJedi();
}

bool Weapon::isMelee() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 13);

		return method.executeWithBooleanReturn();
	} else
		return ((WeaponImplementation*) _impl)->isMelee();
}

bool Weapon::isRanged() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 14);

		return method.executeWithBooleanReturn();
	} else
		return ((WeaponImplementation*) _impl)->isRanged();
}

bool Weapon::isCertified() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 15);

		return method.executeWithBooleanReturn();
	} else
		return ((WeaponImplementation*) _impl)->isCertified();
}

bool Weapon::isHeavyWeapon() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 16);

		return method.executeWithBooleanReturn();
	} else
		return ((WeaponImplementation*) _impl)->isHeavyWeapon();
}

int Weapon::getType() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 17);

		return method.executeWithSignedIntReturn();
	} else
		return ((WeaponImplementation*) _impl)->getType();
}

int Weapon::getCategory() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 18);

		return method.executeWithSignedIntReturn();
	} else
		return ((WeaponImplementation*) _impl)->getCategory();
}

int Weapon::getDamageType() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 19);

		return method.executeWithSignedIntReturn();
	} else
		return ((WeaponImplementation*) _impl)->getDamageType();
}

int Weapon::getUsesRemaining() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 20);

		return method.executeWithSignedIntReturn();
	} else
		return ((WeaponImplementation*) _impl)->getUsesRemaining();
}

float Weapon::getBaseMinDamage() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 21);

		return method.executeWithFloatReturn();
	} else
		return ((WeaponImplementation*) _impl)->getBaseMinDamage();
}

float Weapon::getMinDamage() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 22);

		return method.executeWithFloatReturn();
	} else
		return ((WeaponImplementation*) _impl)->getMinDamage();
}

float Weapon::getBaseMaxDamage() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 23);

		return method.executeWithFloatReturn();
	} else
		return ((WeaponImplementation*) _impl)->getBaseMaxDamage();
}

float Weapon::getMaxDamage() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 24);

		return method.executeWithFloatReturn();
	} else
		return ((WeaponImplementation*) _impl)->getMaxDamage();
}

float Weapon::getBaseAttackSpeed() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 25);

		return method.executeWithFloatReturn();
	} else
		return ((WeaponImplementation*) _impl)->getBaseAttackSpeed();
}

float Weapon::getAttackSpeed() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 26);

		return method.executeWithFloatReturn();
	} else
		return ((WeaponImplementation*) _impl)->getAttackSpeed();
}

int Weapon::getHealthAttackCost() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 27);

		return method.executeWithSignedIntReturn();
	} else
		return ((WeaponImplementation*) _impl)->getHealthAttackCost();
}

int Weapon::getActionAttackCost() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 28);

		return method.executeWithSignedIntReturn();
	} else
		return ((WeaponImplementation*) _impl)->getActionAttackCost();
}

int Weapon::getMindAttackCost() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 29);

		return method.executeWithSignedIntReturn();
	} else
		return ((WeaponImplementation*) _impl)->getMindAttackCost();
}

int Weapon::getForceCost() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 30);

		return method.executeWithSignedIntReturn();
	} else
		return ((WeaponImplementation*) _impl)->getForceCost();
}

int Weapon::getPointBlankRange() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 31);

		return method.executeWithSignedIntReturn();
	} else
		return ((WeaponImplementation*) _impl)->getPointBlankRange();
}

int Weapon::getPointBlankAccuracy() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 32);

		return method.executeWithSignedIntReturn();
	} else
		return ((WeaponImplementation*) _impl)->getPointBlankAccuracy();
}

int Weapon::getMaxRange() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 33);

		return method.executeWithSignedIntReturn();
	} else
		return ((WeaponImplementation*) _impl)->getMaxRange();
}

int Weapon::getMaxRangeAccuracy() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 34);

		return method.executeWithSignedIntReturn();
	} else
		return ((WeaponImplementation*) _impl)->getMaxRangeAccuracy();
}

int Weapon::getIdealRange() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 35);

		return method.executeWithSignedIntReturn();
	} else
		return ((WeaponImplementation*) _impl)->getIdealRange();
}

int Weapon::getIdealAccuracy() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 36);

		return method.executeWithSignedIntReturn();
	} else
		return ((WeaponImplementation*) _impl)->getIdealAccuracy();
}

float Weapon::getWoundsRatio() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 37);

		return method.executeWithFloatReturn();
	} else
		return ((WeaponImplementation*) _impl)->getWoundsRatio();
}

int Weapon::getArmorPiercing() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 38);

		return method.executeWithSignedIntReturn();
	} else
		return ((WeaponImplementation*) _impl)->getArmorPiercing();
}

int Weapon::getPowerupUses() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 39);

		return method.executeWithSignedIntReturn();
	} else
		return ((WeaponImplementation*) _impl)->getPowerupUses();
}

bool Weapon::hasPowerup() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 40);

		return method.executeWithBooleanReturn();
	} else
		return ((WeaponImplementation*) _impl)->hasPowerup();
}

String& Weapon::getCert() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 41);

		method.executeWithAsciiReturn(_return_getCert);
		return _return_getCert;
	} else
		return ((WeaponImplementation*) _impl)->getCert();
}

String& Weapon::getXpType() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 42);

		method.executeWithAsciiReturn(_return_getXpType);
		return _return_getXpType;
	} else
		return ((WeaponImplementation*) _impl)->getXpType();
}

float Weapon::getArea() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 43);

		return method.executeWithFloatReturn();
	} else
		return ((WeaponImplementation*) _impl)->getArea();
}

void Weapon::setType(int type) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 44);
		method.addSignedIntParameter(type);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->setType(type);
}

void Weapon::setDamageType(int type) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 45);
		method.addSignedIntParameter(type);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->setDamageType(type);
}

void Weapon::setMinDamage(float minDmg) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 46);
		method.addFloatParameter(minDmg);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->setMinDamage(minDmg);
}

void Weapon::setMaxDamage(float maxDmg) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 47);
		method.addFloatParameter(maxDmg);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->setMaxDamage(maxDmg);
}

void Weapon::setAttackSpeed(float attackSpd) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 48);
		method.addFloatParameter(attackSpd);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->setAttackSpeed(attackSpd);
}

void Weapon::setHealthAttackCost(int healthCost) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 49);
		method.addSignedIntParameter(healthCost);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->setHealthAttackCost(healthCost);
}

void Weapon::setActionAttackCost(int actionCost) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 50);
		method.addSignedIntParameter(actionCost);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->setActionAttackCost(actionCost);
}

void Weapon::setMindAttackCost(int mindCost) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 51);
		method.addSignedIntParameter(mindCost);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->setMindAttackCost(mindCost);
}

void Weapon::setForceCost(int forceCost) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 52);
		method.addSignedIntParameter(forceCost);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->setForceCost(forceCost);
}

void Weapon::setWoundsRatio(float woundsRat) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 53);
		method.addFloatParameter(woundsRat);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->setWoundsRatio(woundsRat);
}

void Weapon::setArmorPiercing(int armorPierce) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 54);
		method.addSignedIntParameter(armorPierce);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->setArmorPiercing(armorPierce);
}

void Weapon::setPointBlankRange(int pointBlankRnge) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 55);
		method.addSignedIntParameter(pointBlankRnge);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->setPointBlankRange(pointBlankRnge);
}

void Weapon::setPointBlankAccuracy(int pointBlankAcc) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 56);
		method.addSignedIntParameter(pointBlankAcc);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->setPointBlankAccuracy(pointBlankAcc);
}

void Weapon::setMaxRange(int maxRnge) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 57);
		method.addSignedIntParameter(maxRnge);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->setMaxRange(maxRnge);
}

void Weapon::setMaxRangeAccuracy(int maxRangeAcc) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 58);
		method.addSignedIntParameter(maxRangeAcc);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->setMaxRangeAccuracy(maxRangeAcc);
}

void Weapon::setIdealRange(int idealRnge) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 59);
		method.addSignedIntParameter(idealRnge);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->setIdealRange(idealRnge);
}

void Weapon::setIdealAccuracy(int idealAcc) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 60);
		method.addSignedIntParameter(idealAcc);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->setIdealAccuracy(idealAcc);
}

void Weapon::setArea(float ar) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 61);
		method.addFloatParameter(ar);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->setArea(ar);
}

void Weapon::powerupMinDamage(float powerupValue) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 62);
		method.addFloatParameter(powerupValue);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->powerupMinDamage(powerupValue);
}

void Weapon::powerupMaxDamage(float powerupValue) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 63);
		method.addFloatParameter(powerupValue);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->powerupMaxDamage(powerupValue);
}

void Weapon::powerupHealthAttackCost(float powerupValue) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 64);
		method.addFloatParameter(powerupValue);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->powerupHealthAttackCost(powerupValue);
}

void Weapon::powerupActionAttackCost(float powerupValue) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 65);
		method.addFloatParameter(powerupValue);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->powerupActionAttackCost(powerupValue);
}

void Weapon::powerupMindAttackCost(float powerupValue) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 66);
		method.addFloatParameter(powerupValue);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->powerupMindAttackCost(powerupValue);
}

void Weapon::powerupWoundsRatio(float powerupValue) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 67);
		method.addFloatParameter(powerupValue);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->powerupWoundsRatio(powerupValue);
}

void Weapon::powerupAttackSpeed(float powerupValue) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 68);
		method.addFloatParameter(powerupValue);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->powerupAttackSpeed(powerupValue);
}

void Weapon::powerupPointBlankAccuracy(float powerupValue) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 69);
		method.addFloatParameter(powerupValue);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->powerupPointBlankAccuracy(powerupValue);
}

void Weapon::powerupIdealRange(float powerupValue) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 70);
		method.addFloatParameter(powerupValue);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->powerupIdealRange(powerupValue);
}

void Weapon::powerupIdealAccuracy(float powerupValue) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 71);
		method.addFloatParameter(powerupValue);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->powerupIdealAccuracy(powerupValue);
}

void Weapon::powerupMaxRangeAccuracy(float powerupValue) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 72);
		method.addFloatParameter(powerupValue);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->powerupMaxRangeAccuracy(powerupValue);
}

int Weapon::getNumDots() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 73);

		return method.executeWithSignedIntReturn();
	} else
		return ((WeaponImplementation*) _impl)->getNumDots();
}

int Weapon::getDotType(int i) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 74);
		method.addSignedIntParameter(i);

		return method.executeWithSignedIntReturn();
	} else
		return ((WeaponImplementation*) _impl)->getDotType(i);
}

int Weapon::getDotAttribute(int i) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 75);
		method.addSignedIntParameter(i);

		return method.executeWithSignedIntReturn();
	} else
		return ((WeaponImplementation*) _impl)->getDotAttribute(i);
}

int Weapon::getDotStrength(int i) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 76);
		method.addSignedIntParameter(i);

		return method.executeWithSignedIntReturn();
	} else
		return ((WeaponImplementation*) _impl)->getDotStrength(i);
}

int Weapon::getDotPotency(int i) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 77);
		method.addSignedIntParameter(i);

		return method.executeWithSignedIntReturn();
	} else
		return ((WeaponImplementation*) _impl)->getDotPotency(i);
}

int Weapon::getDotDuration(int i) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 78);
		method.addSignedIntParameter(i);

		return method.executeWithSignedIntReturn();
	} else
		return ((WeaponImplementation*) _impl)->getDotDuration(i);
}

int Weapon::getDotUses(int i) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 79);
		method.addSignedIntParameter(i);

		return method.executeWithSignedIntReturn();
	} else
		return ((WeaponImplementation*) _impl)->getDotUses(i);
}

bool Weapon::decreaseDotUses(int i) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 80);
		method.addSignedIntParameter(i);

		return method.executeWithBooleanReturn();
	} else
		return ((WeaponImplementation*) _impl)->decreaseDotUses(i);
}

void Weapon::createTestDot(int type) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 81);
		method.addSignedIntParameter(type);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->createTestDot(type);
}

void Weapon::setPowerupUses(int uses) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 82);
		method.addSignedIntParameter(uses);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->setPowerupUses(uses);
}

void Weapon::setUsesRemaining(int charges) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 83);
		method.addSignedIntParameter(charges);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->setUsesRemaining(charges);
}

void Weapon::setCert(String& certification) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 84);
		method.addAsciiParameter(certification);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->setCert(certification);
}

void Weapon::setCertified(bool crt) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 85);
		method.addBooleanParameter(crt);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->setCertified(crt);
}

void Weapon::setXpType() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 86);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->setXpType();
}

void Weapon::onEquip(Player* player) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 87);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->onEquip(player);
}

void Weapon::onUnequip(Player* player) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 88);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->onUnequip(player);
}

void Weapon::onBroken() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 89);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->onBroken();
}

void Weapon::onSlicingFailure(Player* slicer) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 90);
		method.addObjectParameter(slicer);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->onSlicingFailure(slicer);
}

void Weapon::slice(Player* slicer) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 91);
		method.addObjectParameter(slicer);

		method.executeWithVoidReturn();
	} else
		((WeaponImplementation*) _impl)->slice(slicer);
}

/*
 *	WeaponAdapter
 */

WeaponAdapter::WeaponAdapter(WeaponImplementation* obj) : TangibleObjectAdapter(obj) {
}

Packet* WeaponAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	Packet* resp = new MethodReturnMessage(0);

	switch (methid) {
	case 6:
		sendTo((Player*) inv->getObjectParameter(), inv->getBooleanParameter());
		break;
	case 7:
		setWeaponStats(inv->getSignedIntParameter());
		break;
	case 8:
		decay(inv->getFloatParameter());
		break;
	case 9:
		removePowerup((Player*) inv->getObjectParameter(), inv->getBooleanParameter());
		break;
	case 10:
		resp->insertBoolean(decreasePowerupUses());
		break;
	case 11:
		resp->insertBoolean(decreaseUsesRemaining());
		break;
	case 12:
		resp->insertBoolean(isJedi());
		break;
	case 13:
		resp->insertBoolean(isMelee());
		break;
	case 14:
		resp->insertBoolean(isRanged());
		break;
	case 15:
		resp->insertBoolean(isCertified());
		break;
	case 16:
		resp->insertBoolean(isHeavyWeapon());
		break;
	case 17:
		resp->insertSignedInt(getType());
		break;
	case 18:
		resp->insertSignedInt(getCategory());
		break;
	case 19:
		resp->insertSignedInt(getDamageType());
		break;
	case 20:
		resp->insertSignedInt(getUsesRemaining());
		break;
	case 21:
		resp->insertFloat(getBaseMinDamage());
		break;
	case 22:
		resp->insertFloat(getMinDamage());
		break;
	case 23:
		resp->insertFloat(getBaseMaxDamage());
		break;
	case 24:
		resp->insertFloat(getMaxDamage());
		break;
	case 25:
		resp->insertFloat(getBaseAttackSpeed());
		break;
	case 26:
		resp->insertFloat(getAttackSpeed());
		break;
	case 27:
		resp->insertSignedInt(getHealthAttackCost());
		break;
	case 28:
		resp->insertSignedInt(getActionAttackCost());
		break;
	case 29:
		resp->insertSignedInt(getMindAttackCost());
		break;
	case 30:
		resp->insertSignedInt(getForceCost());
		break;
	case 31:
		resp->insertSignedInt(getPointBlankRange());
		break;
	case 32:
		resp->insertSignedInt(getPointBlankAccuracy());
		break;
	case 33:
		resp->insertSignedInt(getMaxRange());
		break;
	case 34:
		resp->insertSignedInt(getMaxRangeAccuracy());
		break;
	case 35:
		resp->insertSignedInt(getIdealRange());
		break;
	case 36:
		resp->insertSignedInt(getIdealAccuracy());
		break;
	case 37:
		resp->insertFloat(getWoundsRatio());
		break;
	case 38:
		resp->insertSignedInt(getArmorPiercing());
		break;
	case 39:
		resp->insertSignedInt(getPowerupUses());
		break;
	case 40:
		resp->insertBoolean(hasPowerup());
		break;
	case 41:
		resp->insertAscii(getCert());
		break;
	case 42:
		resp->insertAscii(getXpType());
		break;
	case 43:
		resp->insertFloat(getArea());
		break;
	case 44:
		setType(inv->getSignedIntParameter());
		break;
	case 45:
		setDamageType(inv->getSignedIntParameter());
		break;
	case 46:
		setMinDamage(inv->getFloatParameter());
		break;
	case 47:
		setMaxDamage(inv->getFloatParameter());
		break;
	case 48:
		setAttackSpeed(inv->getFloatParameter());
		break;
	case 49:
		setHealthAttackCost(inv->getSignedIntParameter());
		break;
	case 50:
		setActionAttackCost(inv->getSignedIntParameter());
		break;
	case 51:
		setMindAttackCost(inv->getSignedIntParameter());
		break;
	case 52:
		setForceCost(inv->getSignedIntParameter());
		break;
	case 53:
		setWoundsRatio(inv->getFloatParameter());
		break;
	case 54:
		setArmorPiercing(inv->getSignedIntParameter());
		break;
	case 55:
		setPointBlankRange(inv->getSignedIntParameter());
		break;
	case 56:
		setPointBlankAccuracy(inv->getSignedIntParameter());
		break;
	case 57:
		setMaxRange(inv->getSignedIntParameter());
		break;
	case 58:
		setMaxRangeAccuracy(inv->getSignedIntParameter());
		break;
	case 59:
		setIdealRange(inv->getSignedIntParameter());
		break;
	case 60:
		setIdealAccuracy(inv->getSignedIntParameter());
		break;
	case 61:
		setArea(inv->getFloatParameter());
		break;
	case 62:
		powerupMinDamage(inv->getFloatParameter());
		break;
	case 63:
		powerupMaxDamage(inv->getFloatParameter());
		break;
	case 64:
		powerupHealthAttackCost(inv->getFloatParameter());
		break;
	case 65:
		powerupActionAttackCost(inv->getFloatParameter());
		break;
	case 66:
		powerupMindAttackCost(inv->getFloatParameter());
		break;
	case 67:
		powerupWoundsRatio(inv->getFloatParameter());
		break;
	case 68:
		powerupAttackSpeed(inv->getFloatParameter());
		break;
	case 69:
		powerupPointBlankAccuracy(inv->getFloatParameter());
		break;
	case 70:
		powerupIdealRange(inv->getFloatParameter());
		break;
	case 71:
		powerupIdealAccuracy(inv->getFloatParameter());
		break;
	case 72:
		powerupMaxRangeAccuracy(inv->getFloatParameter());
		break;
	case 73:
		resp->insertSignedInt(getNumDots());
		break;
	case 74:
		resp->insertSignedInt(getDotType(inv->getSignedIntParameter()));
		break;
	case 75:
		resp->insertSignedInt(getDotAttribute(inv->getSignedIntParameter()));
		break;
	case 76:
		resp->insertSignedInt(getDotStrength(inv->getSignedIntParameter()));
		break;
	case 77:
		resp->insertSignedInt(getDotPotency(inv->getSignedIntParameter()));
		break;
	case 78:
		resp->insertSignedInt(getDotDuration(inv->getSignedIntParameter()));
		break;
	case 79:
		resp->insertSignedInt(getDotUses(inv->getSignedIntParameter()));
		break;
	case 80:
		resp->insertBoolean(decreaseDotUses(inv->getSignedIntParameter()));
		break;
	case 81:
		createTestDot(inv->getSignedIntParameter());
		break;
	case 82:
		setPowerupUses(inv->getSignedIntParameter());
		break;
	case 83:
		setUsesRemaining(inv->getSignedIntParameter());
		break;
	case 84:
		setCert(inv->getAsciiParameter(_param0_setCert__String_));
		break;
	case 85:
		setCertified(inv->getBooleanParameter());
		break;
	case 86:
		setXpType();
		break;
	case 87:
		onEquip((Player*) inv->getObjectParameter());
		break;
	case 88:
		onUnequip((Player*) inv->getObjectParameter());
		break;
	case 89:
		onBroken();
		break;
	case 90:
		onSlicingFailure((Player*) inv->getObjectParameter());
		break;
	case 91:
		slice((Player*) inv->getObjectParameter());
		break;
	default:
		return NULL;
	}

	return resp;
}

void WeaponAdapter::sendTo(Player* player, bool doClose) {
	return ((WeaponImplementation*) impl)->sendTo(player, doClose);
}

void WeaponAdapter::setWeaponStats(int modifier) {
	return ((WeaponImplementation*) impl)->setWeaponStats(modifier);
}

void WeaponAdapter::decay(float decayRate) {
	return ((WeaponImplementation*) impl)->decay(decayRate);
}

void WeaponAdapter::removePowerup(Player* player, bool notify) {
	return ((WeaponImplementation*) impl)->removePowerup(player, notify);
}

bool WeaponAdapter::decreasePowerupUses() {
	return ((WeaponImplementation*) impl)->decreasePowerupUses();
}

bool WeaponAdapter::decreaseUsesRemaining() {
	return ((WeaponImplementation*) impl)->decreaseUsesRemaining();
}

bool WeaponAdapter::isJedi() {
	return ((WeaponImplementation*) impl)->isJedi();
}

bool WeaponAdapter::isMelee() {
	return ((WeaponImplementation*) impl)->isMelee();
}

bool WeaponAdapter::isRanged() {
	return ((WeaponImplementation*) impl)->isRanged();
}

bool WeaponAdapter::isCertified() {
	return ((WeaponImplementation*) impl)->isCertified();
}

bool WeaponAdapter::isHeavyWeapon() {
	return ((WeaponImplementation*) impl)->isHeavyWeapon();
}

int WeaponAdapter::getType() {
	return ((WeaponImplementation*) impl)->getType();
}

int WeaponAdapter::getCategory() {
	return ((WeaponImplementation*) impl)->getCategory();
}

int WeaponAdapter::getDamageType() {
	return ((WeaponImplementation*) impl)->getDamageType();
}

int WeaponAdapter::getUsesRemaining() {
	return ((WeaponImplementation*) impl)->getUsesRemaining();
}

float WeaponAdapter::getBaseMinDamage() {
	return ((WeaponImplementation*) impl)->getBaseMinDamage();
}

float WeaponAdapter::getMinDamage() {
	return ((WeaponImplementation*) impl)->getMinDamage();
}

float WeaponAdapter::getBaseMaxDamage() {
	return ((WeaponImplementation*) impl)->getBaseMaxDamage();
}

float WeaponAdapter::getMaxDamage() {
	return ((WeaponImplementation*) impl)->getMaxDamage();
}

float WeaponAdapter::getBaseAttackSpeed() {
	return ((WeaponImplementation*) impl)->getBaseAttackSpeed();
}

float WeaponAdapter::getAttackSpeed() {
	return ((WeaponImplementation*) impl)->getAttackSpeed();
}

int WeaponAdapter::getHealthAttackCost() {
	return ((WeaponImplementation*) impl)->getHealthAttackCost();
}

int WeaponAdapter::getActionAttackCost() {
	return ((WeaponImplementation*) impl)->getActionAttackCost();
}

int WeaponAdapter::getMindAttackCost() {
	return ((WeaponImplementation*) impl)->getMindAttackCost();
}

int WeaponAdapter::getForceCost() {
	return ((WeaponImplementation*) impl)->getForceCost();
}

int WeaponAdapter::getPointBlankRange() {
	return ((WeaponImplementation*) impl)->getPointBlankRange();
}

int WeaponAdapter::getPointBlankAccuracy() {
	return ((WeaponImplementation*) impl)->getPointBlankAccuracy();
}

int WeaponAdapter::getMaxRange() {
	return ((WeaponImplementation*) impl)->getMaxRange();
}

int WeaponAdapter::getMaxRangeAccuracy() {
	return ((WeaponImplementation*) impl)->getMaxRangeAccuracy();
}

int WeaponAdapter::getIdealRange() {
	return ((WeaponImplementation*) impl)->getIdealRange();
}

int WeaponAdapter::getIdealAccuracy() {
	return ((WeaponImplementation*) impl)->getIdealAccuracy();
}

float WeaponAdapter::getWoundsRatio() {
	return ((WeaponImplementation*) impl)->getWoundsRatio();
}

int WeaponAdapter::getArmorPiercing() {
	return ((WeaponImplementation*) impl)->getArmorPiercing();
}

int WeaponAdapter::getPowerupUses() {
	return ((WeaponImplementation*) impl)->getPowerupUses();
}

bool WeaponAdapter::hasPowerup() {
	return ((WeaponImplementation*) impl)->hasPowerup();
}

String& WeaponAdapter::getCert() {
	return ((WeaponImplementation*) impl)->getCert();
}

String& WeaponAdapter::getXpType() {
	return ((WeaponImplementation*) impl)->getXpType();
}

float WeaponAdapter::getArea() {
	return ((WeaponImplementation*) impl)->getArea();
}

void WeaponAdapter::setType(int type) {
	return ((WeaponImplementation*) impl)->setType(type);
}

void WeaponAdapter::setDamageType(int type) {
	return ((WeaponImplementation*) impl)->setDamageType(type);
}

void WeaponAdapter::setMinDamage(float minDmg) {
	return ((WeaponImplementation*) impl)->setMinDamage(minDmg);
}

void WeaponAdapter::setMaxDamage(float maxDmg) {
	return ((WeaponImplementation*) impl)->setMaxDamage(maxDmg);
}

void WeaponAdapter::setAttackSpeed(float attackSpd) {
	return ((WeaponImplementation*) impl)->setAttackSpeed(attackSpd);
}

void WeaponAdapter::setHealthAttackCost(int healthCost) {
	return ((WeaponImplementation*) impl)->setHealthAttackCost(healthCost);
}

void WeaponAdapter::setActionAttackCost(int actionCost) {
	return ((WeaponImplementation*) impl)->setActionAttackCost(actionCost);
}

void WeaponAdapter::setMindAttackCost(int mindCost) {
	return ((WeaponImplementation*) impl)->setMindAttackCost(mindCost);
}

void WeaponAdapter::setForceCost(int forceCost) {
	return ((WeaponImplementation*) impl)->setForceCost(forceCost);
}

void WeaponAdapter::setWoundsRatio(float woundsRat) {
	return ((WeaponImplementation*) impl)->setWoundsRatio(woundsRat);
}

void WeaponAdapter::setArmorPiercing(int armorPierce) {
	return ((WeaponImplementation*) impl)->setArmorPiercing(armorPierce);
}

void WeaponAdapter::setPointBlankRange(int pointBlankRnge) {
	return ((WeaponImplementation*) impl)->setPointBlankRange(pointBlankRnge);
}

void WeaponAdapter::setPointBlankAccuracy(int pointBlankAcc) {
	return ((WeaponImplementation*) impl)->setPointBlankAccuracy(pointBlankAcc);
}

void WeaponAdapter::setMaxRange(int maxRnge) {
	return ((WeaponImplementation*) impl)->setMaxRange(maxRnge);
}

void WeaponAdapter::setMaxRangeAccuracy(int maxRangeAcc) {
	return ((WeaponImplementation*) impl)->setMaxRangeAccuracy(maxRangeAcc);
}

void WeaponAdapter::setIdealRange(int idealRnge) {
	return ((WeaponImplementation*) impl)->setIdealRange(idealRnge);
}

void WeaponAdapter::setIdealAccuracy(int idealAcc) {
	return ((WeaponImplementation*) impl)->setIdealAccuracy(idealAcc);
}

void WeaponAdapter::setArea(float ar) {
	return ((WeaponImplementation*) impl)->setArea(ar);
}

void WeaponAdapter::powerupMinDamage(float powerupValue) {
	return ((WeaponImplementation*) impl)->powerupMinDamage(powerupValue);
}

void WeaponAdapter::powerupMaxDamage(float powerupValue) {
	return ((WeaponImplementation*) impl)->powerupMaxDamage(powerupValue);
}

void WeaponAdapter::powerupHealthAttackCost(float powerupValue) {
	return ((WeaponImplementation*) impl)->powerupHealthAttackCost(powerupValue);
}

void WeaponAdapter::powerupActionAttackCost(float powerupValue) {
	return ((WeaponImplementation*) impl)->powerupActionAttackCost(powerupValue);
}

void WeaponAdapter::powerupMindAttackCost(float powerupValue) {
	return ((WeaponImplementation*) impl)->powerupMindAttackCost(powerupValue);
}

void WeaponAdapter::powerupWoundsRatio(float powerupValue) {
	return ((WeaponImplementation*) impl)->powerupWoundsRatio(powerupValue);
}

void WeaponAdapter::powerupAttackSpeed(float powerupValue) {
	return ((WeaponImplementation*) impl)->powerupAttackSpeed(powerupValue);
}

void WeaponAdapter::powerupPointBlankAccuracy(float powerupValue) {
	return ((WeaponImplementation*) impl)->powerupPointBlankAccuracy(powerupValue);
}

void WeaponAdapter::powerupIdealRange(float powerupValue) {
	return ((WeaponImplementation*) impl)->powerupIdealRange(powerupValue);
}

void WeaponAdapter::powerupIdealAccuracy(float powerupValue) {
	return ((WeaponImplementation*) impl)->powerupIdealAccuracy(powerupValue);
}

void WeaponAdapter::powerupMaxRangeAccuracy(float powerupValue) {
	return ((WeaponImplementation*) impl)->powerupMaxRangeAccuracy(powerupValue);
}

int WeaponAdapter::getNumDots() {
	return ((WeaponImplementation*) impl)->getNumDots();
}

int WeaponAdapter::getDotType(int i) {
	return ((WeaponImplementation*) impl)->getDotType(i);
}

int WeaponAdapter::getDotAttribute(int i) {
	return ((WeaponImplementation*) impl)->getDotAttribute(i);
}

int WeaponAdapter::getDotStrength(int i) {
	return ((WeaponImplementation*) impl)->getDotStrength(i);
}

int WeaponAdapter::getDotPotency(int i) {
	return ((WeaponImplementation*) impl)->getDotPotency(i);
}

int WeaponAdapter::getDotDuration(int i) {
	return ((WeaponImplementation*) impl)->getDotDuration(i);
}

int WeaponAdapter::getDotUses(int i) {
	return ((WeaponImplementation*) impl)->getDotUses(i);
}

bool WeaponAdapter::decreaseDotUses(int i) {
	return ((WeaponImplementation*) impl)->decreaseDotUses(i);
}

void WeaponAdapter::createTestDot(int type) {
	return ((WeaponImplementation*) impl)->createTestDot(type);
}

void WeaponAdapter::setPowerupUses(int uses) {
	return ((WeaponImplementation*) impl)->setPowerupUses(uses);
}

void WeaponAdapter::setUsesRemaining(int charges) {
	return ((WeaponImplementation*) impl)->setUsesRemaining(charges);
}

void WeaponAdapter::setCert(String& certification) {
	return ((WeaponImplementation*) impl)->setCert(certification);
}

void WeaponAdapter::setCertified(bool crt) {
	return ((WeaponImplementation*) impl)->setCertified(crt);
}

void WeaponAdapter::setXpType() {
	return ((WeaponImplementation*) impl)->setXpType();
}

void WeaponAdapter::onEquip(Player* player) {
	return ((WeaponImplementation*) impl)->onEquip(player);
}

void WeaponAdapter::onUnequip(Player* player) {
	return ((WeaponImplementation*) impl)->onUnequip(player);
}

void WeaponAdapter::onBroken() {
	return ((WeaponImplementation*) impl)->onBroken();
}

void WeaponAdapter::onSlicingFailure(Player* slicer) {
	return ((WeaponImplementation*) impl)->onSlicingFailure(slicer);
}

void WeaponAdapter::slice(Player* slicer) {
	return ((WeaponImplementation*) impl)->slice(slicer);
}

/*
 *	WeaponHelper
 */

WeaponHelper* WeaponHelper::staticInitializer = WeaponHelper::instance();

WeaponHelper::WeaponHelper() {
	className = "Weapon";

	DistributedObjectBroker::instance()->registerClass(className, this);
}

void WeaponHelper::finalizeHelper() {
	WeaponHelper::finalize();
}

DistributedObject* WeaponHelper::instantiateObject() {
	return new Weapon(DummyConstructorParameter::instance());
}

DistributedObjectAdapter* WeaponHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new WeaponAdapter((WeaponImplementation*) obj->_getImplementation());

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	WeaponServant
 */

WeaponServant::WeaponServant(unsigned long long oid, unsigned int tempCRC, const UnicodeString& n, const String& tempn, int tp) : TangibleObjectImplementation(oid, tempCRC, n, tempn, tp) {
	_classHelper = WeaponHelper::instance();
}

WeaponServant::WeaponServant(unsigned long long oid, int tp) : TangibleObjectImplementation(oid, tp) {
	_classHelper = WeaponHelper::instance();
}

WeaponServant::~WeaponServant() {
}

void WeaponServant::_setStub(DistributedObjectStub* stub) {
	_this = (Weapon*) stub;
	TangibleObjectServant::_setStub(stub);
}

DistributedObjectStub* WeaponServant::_getStub() {
	return _this;
}

