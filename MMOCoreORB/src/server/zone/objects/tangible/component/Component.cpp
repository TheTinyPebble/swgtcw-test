/*
 *	server/zone/objects/tangible/component/Component.cpp generated by engine3 IDL compiler 0.60
 */

#include "Component.h"

#include "server/zone/packets/object/ObjectMenuResponse.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/Zone.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/packets/object/ObjectMenuResponse.h"

/*
 *	ComponentStub
 */

enum {RPC_INITIALIZETRANSIENTMEMBERS__ = 6,RPC_ISCOMPONENT__,RPC_GENERATELOOTSTATS__STRING_INT_,RPC_COMPARE__COMPONENT_,RPC_HASKEY__STRING_,RPC_ADDPROPERTY__STRING_FLOAT_INT_STRING_BOOL_,RPC_GETATTRIBUTEVALUE__STRING_,RPC_GETATTRIBUTEPRECISION__STRING_,RPC_GETATTRIBUTETITLE__STRING_,RPC_GETATTRIBUTEHIDDEN__STRING_,RPC_SETPROPERTYTOHIDDEN__STRING_,RPC_ADDPROPERTY__STRING_FLOAT_INT_STRING_,RPC_GETPROPERTYCOUNT__,RPC_GETPROPERTY__INT_,RPC_CHANGEATTRIBUTEVALUE__STRING_FLOAT_};

Component::Component() : TangibleObject(DummyConstructorParameter::instance()) {
	ComponentImplementation* _implementation = new ComponentImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("Component");
}

Component::Component(DummyConstructorParameter* param) : TangibleObject(param) {
	_setClassName("Component");
}

Component::~Component() {
}



void Component::initializeTransientMembers() {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else
		_implementation->initializeTransientMembers();
}

void Component::fillObjectMenuResponse(ObjectMenuResponse* menuResponse, CreatureObject* player) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->fillObjectMenuResponse(menuResponse, player);
}

void Component::fillAttributeList(AttributeListMessage* msg, CreatureObject* object) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->fillAttributeList(msg, object);
}

bool Component::isComponent() {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCOMPONENT__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isComponent();
}

void Component::generateLootStats(const String& lootstring, int level) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GENERATELOOTSTATS__STRING_INT_);
		method.addAsciiParameter(lootstring);
		method.addSignedIntParameter(level);

		method.executeWithVoidReturn();
	} else
		_implementation->generateLootStats(lootstring, level);
}

bool Component::compare(Component* inCmpo) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_COMPARE__COMPONENT_);
		method.addObjectParameter(inCmpo);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->compare(inCmpo);
}

bool Component::hasKey(const String& key) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASKEY__STRING_);
		method.addAsciiParameter(key);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasKey(key);
}

void Component::updateCraftingValues(CraftingValues* values, bool firstUpdate) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->updateCraftingValues(values, firstUpdate);
}

void Component::addProperty(const String& attributeName, const float value, const int precision, const String& craftingTitle, const bool hidden) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDPROPERTY__STRING_FLOAT_INT_STRING_BOOL_);
		method.addAsciiParameter(attributeName);
		method.addFloatParameter(value);
		method.addSignedIntParameter(precision);
		method.addAsciiParameter(craftingTitle);
		method.addBooleanParameter(hidden);

		method.executeWithVoidReturn();
	} else
		_implementation->addProperty(attributeName, value, precision, craftingTitle, hidden);
}

float Component::getAttributeValue(const String& attributeName) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETATTRIBUTEVALUE__STRING_);
		method.addAsciiParameter(attributeName);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getAttributeValue(attributeName);
}

int Component::getAttributePrecision(const String& attributeName) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETATTRIBUTEPRECISION__STRING_);
		method.addAsciiParameter(attributeName);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getAttributePrecision(attributeName);
}

String Component::getAttributeTitle(const String& attributeName) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETATTRIBUTETITLE__STRING_);
		method.addAsciiParameter(attributeName);

		String _return_getAttributeTitle;
		method.executeWithAsciiReturn(_return_getAttributeTitle);
		return _return_getAttributeTitle;
	} else
		return _implementation->getAttributeTitle(attributeName);
}

bool Component::getAttributeHidden(const String& attributeName) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETATTRIBUTEHIDDEN__STRING_);
		method.addAsciiParameter(attributeName);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->getAttributeHidden(attributeName);
}

void Component::setPropertyToHidden(const String& property) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPROPERTYTOHIDDEN__STRING_);
		method.addAsciiParameter(property);

		method.executeWithVoidReturn();
	} else
		_implementation->setPropertyToHidden(property);
}

void Component::addProperty(const String& attribute, const float value, const int precision, const String& title) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDPROPERTY__STRING_FLOAT_INT_STRING_);
		method.addAsciiParameter(attribute);
		method.addFloatParameter(value);
		method.addSignedIntParameter(precision);
		method.addAsciiParameter(title);

		method.executeWithVoidReturn();
	} else
		_implementation->addProperty(attribute, value, precision, title);
}

int Component::getPropertyCount() {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPROPERTYCOUNT__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getPropertyCount();
}

String Component::getProperty(const int j) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPROPERTY__INT_);
		method.addSignedIntParameter(j);

		String _return_getProperty;
		method.executeWithAsciiReturn(_return_getProperty);
		return _return_getProperty;
	} else
		return _implementation->getProperty(j);
}

bool Component::changeAttributeValue(String& property, float value) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHANGEATTRIBUTEVALUE__STRING_FLOAT_);
		method.addAsciiParameter(property);
		method.addFloatParameter(value);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->changeAttributeValue(property, value);
}

DistributedObjectServant* Component::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

void Component::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	ComponentImplementation
 */

ComponentImplementation::ComponentImplementation(DummyConstructorParameter* param) : TangibleObjectImplementation(param) {
	_initializeImplementation();
}


ComponentImplementation::~ComponentImplementation() {
}


void ComponentImplementation::finalize() {
}

void ComponentImplementation::_initializeImplementation() {
	_setClassHelper(ComponentHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void ComponentImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<Component*>(stub);
	TangibleObjectImplementation::_setStub(stub);
}

DistributedObjectStub* ComponentImplementation::_getStub() {
	return _this.get();
}

ComponentImplementation::operator const Component*() {
	return _this.get();
}

void ComponentImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void ComponentImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void ComponentImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void ComponentImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void ComponentImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void ComponentImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void ComponentImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void ComponentImplementation::_serializationHelperMethod() {
	TangibleObjectImplementation::_serializationHelperMethod();

	_setClassName("Component");

}

void ComponentImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		String _name;
		_name.parseFromBinaryStream(stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(ComponentImplementation::readObjectMember(stream, _name)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool ComponentImplementation::readObjectMember(ObjectInputStream* stream, const String& _name) {
	if (TangibleObjectImplementation::readObjectMember(stream, _name))
		return true;

	if (_name == "Component.attributeMap") {
		TypeInfo<VectorMap<String, float> >::parseFromBinaryStream(&attributeMap, stream);
		return true;
	}

	if (_name == "Component.precisionMap") {
		TypeInfo<VectorMap<String, int> >::parseFromBinaryStream(&precisionMap, stream);
		return true;
	}

	if (_name == "Component.titleMap") {
		TypeInfo<VectorMap<String, String> >::parseFromBinaryStream(&titleMap, stream);
		return true;
	}

	if (_name == "Component.hiddenMap") {
		TypeInfo<VectorMap<String, bool> >::parseFromBinaryStream(&hiddenMap, stream);
		return true;
	}

	if (_name == "Component.keyList") {
		TypeInfo<Vector<String> >::parseFromBinaryStream(&keyList, stream);
		return true;
	}


	return false;
}

void ComponentImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = ComponentImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int ComponentImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = TangibleObjectImplementation::writeObjectMembers(stream);

	String _name;
	int _offset;
	uint32 _totalSize;
	_name = "Component.attributeMap";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, float> >::toBinaryStream(&attributeMap, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_name = "Component.precisionMap";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, int> >::toBinaryStream(&precisionMap, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_name = "Component.titleMap";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, String> >::toBinaryStream(&titleMap, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_name = "Component.hiddenMap";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, bool> >::toBinaryStream(&hiddenMap, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_name = "Component.keyList";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<String> >::toBinaryStream(&keyList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);


	return _count + 5;
}

ComponentImplementation::ComponentImplementation() {
	_initializeImplementation();
	// server/zone/objects/tangible/component/Component.idl():  		Logger.setLoggingName("Component");
	Logger::setLoggingName("Component");
}

bool ComponentImplementation::isComponent() {
	// server/zone/objects/tangible/component/Component.idl():  		return true;
	return true;
}

bool ComponentImplementation::hasKey(const String& key) {
	// server/zone/objects/tangible/component/Component.idl():  		return 
	for (	// server/zone/objects/tangible/component/Component.idl():  		for (int i = 0;
	int i = 0;
	i < (&keyList)->size();
 ++i) 	// server/zone/objects/tangible/component/Component.idl():  		return 
	if ((&keyList)->get(i) == key)	// server/zone/objects/tangible/component/Component.idl():  				return true;
	return true;
	// server/zone/objects/tangible/component/Component.idl():  		return false;
	return false;
}

/*
 *	ComponentAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


ComponentAdapter::ComponentAdapter(Component* obj) : TangibleObjectAdapter(obj) {
}

void ComponentAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		{
			initializeTransientMembers();
		}
		break;
	case RPC_ISCOMPONENT__:
		{
			resp->insertBoolean(isComponent());
		}
		break;
	case RPC_GENERATELOOTSTATS__STRING_INT_:
		{
			String lootstring; 
			generateLootStats(inv->getAsciiParameter(lootstring), inv->getSignedIntParameter());
		}
		break;
	case RPC_COMPARE__COMPONENT_:
		{
			resp->insertBoolean(compare(static_cast<Component*>(inv->getObjectParameter())));
		}
		break;
	case RPC_HASKEY__STRING_:
		{
			String key; 
			resp->insertBoolean(hasKey(inv->getAsciiParameter(key)));
		}
		break;
	case RPC_ADDPROPERTY__STRING_FLOAT_INT_STRING_BOOL_:
		{
			String attributeName; String craftingTitle; 
			addProperty(inv->getAsciiParameter(attributeName), inv->getFloatParameter(), inv->getSignedIntParameter(), inv->getAsciiParameter(craftingTitle), inv->getBooleanParameter());
		}
		break;
	case RPC_GETATTRIBUTEVALUE__STRING_:
		{
			String attributeName; 
			resp->insertFloat(getAttributeValue(inv->getAsciiParameter(attributeName)));
		}
		break;
	case RPC_GETATTRIBUTEPRECISION__STRING_:
		{
			String attributeName; 
			resp->insertSignedInt(getAttributePrecision(inv->getAsciiParameter(attributeName)));
		}
		break;
	case RPC_GETATTRIBUTETITLE__STRING_:
		{
			String attributeName; 
			resp->insertAscii(getAttributeTitle(inv->getAsciiParameter(attributeName)));
		}
		break;
	case RPC_GETATTRIBUTEHIDDEN__STRING_:
		{
			String attributeName; 
			resp->insertBoolean(getAttributeHidden(inv->getAsciiParameter(attributeName)));
		}
		break;
	case RPC_SETPROPERTYTOHIDDEN__STRING_:
		{
			String property; 
			setPropertyToHidden(inv->getAsciiParameter(property));
		}
		break;
	case RPC_ADDPROPERTY__STRING_FLOAT_INT_STRING_:
		{
			String attribute; String title; 
			addProperty(inv->getAsciiParameter(attribute), inv->getFloatParameter(), inv->getSignedIntParameter(), inv->getAsciiParameter(title));
		}
		break;
	case RPC_GETPROPERTYCOUNT__:
		{
			resp->insertSignedInt(getPropertyCount());
		}
		break;
	case RPC_GETPROPERTY__INT_:
		{
			resp->insertAscii(getProperty(inv->getSignedIntParameter()));
		}
		break;
	case RPC_CHANGEATTRIBUTEVALUE__STRING_FLOAT_:
		{
			String property; 
			resp->insertBoolean(changeAttributeValue(inv->getAsciiParameter(property), inv->getFloatParameter()));
		}
		break;
	default:
		throw Exception("Method does not exists");
	}
}

void ComponentAdapter::initializeTransientMembers() {
	(static_cast<Component*>(stub))->initializeTransientMembers();
}

bool ComponentAdapter::isComponent() {
	return (static_cast<Component*>(stub))->isComponent();
}

void ComponentAdapter::generateLootStats(const String& lootstring, int level) {
	(static_cast<Component*>(stub))->generateLootStats(lootstring, level);
}

bool ComponentAdapter::compare(Component* inCmpo) {
	return (static_cast<Component*>(stub))->compare(inCmpo);
}

bool ComponentAdapter::hasKey(const String& key) {
	return (static_cast<Component*>(stub))->hasKey(key);
}

void ComponentAdapter::addProperty(const String& attributeName, const float value, const int precision, const String& craftingTitle, const bool hidden) {
	(static_cast<Component*>(stub))->addProperty(attributeName, value, precision, craftingTitle, hidden);
}

float ComponentAdapter::getAttributeValue(const String& attributeName) {
	return (static_cast<Component*>(stub))->getAttributeValue(attributeName);
}

int ComponentAdapter::getAttributePrecision(const String& attributeName) {
	return (static_cast<Component*>(stub))->getAttributePrecision(attributeName);
}

String ComponentAdapter::getAttributeTitle(const String& attributeName) {
	return (static_cast<Component*>(stub))->getAttributeTitle(attributeName);
}

bool ComponentAdapter::getAttributeHidden(const String& attributeName) {
	return (static_cast<Component*>(stub))->getAttributeHidden(attributeName);
}

void ComponentAdapter::setPropertyToHidden(const String& property) {
	(static_cast<Component*>(stub))->setPropertyToHidden(property);
}

void ComponentAdapter::addProperty(const String& attribute, const float value, const int precision, const String& title) {
	(static_cast<Component*>(stub))->addProperty(attribute, value, precision, title);
}

int ComponentAdapter::getPropertyCount() {
	return (static_cast<Component*>(stub))->getPropertyCount();
}

String ComponentAdapter::getProperty(const int j) {
	return (static_cast<Component*>(stub))->getProperty(j);
}

bool ComponentAdapter::changeAttributeValue(String& property, float value) {
	return (static_cast<Component*>(stub))->changeAttributeValue(property, value);
}

/*
 *	ComponentHelper
 */

ComponentHelper* ComponentHelper::staticInitializer = ComponentHelper::instance();

ComponentHelper::ComponentHelper() {
	className = "Component";

	Core::getObjectBroker()->registerClass(className, this);
}

void ComponentHelper::finalizeHelper() {
	ComponentHelper::finalize();
}

DistributedObject* ComponentHelper::instantiateObject() {
	return new Component(DummyConstructorParameter::instance());
}

DistributedObjectServant* ComponentHelper::instantiateServant() {
	return new ComponentImplementation();
}

DistributedObjectAdapter* ComponentHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new ComponentAdapter(static_cast<Component*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

