/*
 *	server/zone/objects/tangible/tools/Tool.cpp generated by engine3 IDL compiler 0.55
 */

#include "Tool.h"

#include "ToolImplementation.h"

#include "../TangibleObject.h"

/*
 *	ToolStub
 */

Tool::Tool(unsigned long long oid, unsigned int tooltype) : TangibleObject(DummyConstructorParameter::instance()) {
	_impl = new ToolImplementation(oid, tooltype);
	_impl->_setStub(this);
}

Tool::Tool(unsigned long long oid, unsigned int tempCRC, const UnicodeString& n, const String& tempn, unsigned int tooltype) : TangibleObject(DummyConstructorParameter::instance()) {
	_impl = new ToolImplementation(oid, tempCRC, n, tempn, tooltype);
	_impl->_setStub(this);
}

Tool::Tool(DummyConstructorParameter* param) : TangibleObject(param) {
}

Tool::~Tool() {
}

void Tool::setToolType(unsigned int value) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 6);
		method.addUnsignedIntParameter(value);

		method.executeWithVoidReturn();
	} else
		((ToolImplementation*) _impl)->setToolType(value);
}

void Tool::setEffectiveness(float value) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 7);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else
		((ToolImplementation*) _impl)->setEffectiveness(value);
}

unsigned int Tool::getToolType() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 8);

		return method.executeWithUnsignedIntReturn();
	} else
		return ((ToolImplementation*) _impl)->getToolType();
}

float Tool::getEffectiveness() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 9);

		return method.executeWithFloatReturn();
	} else
		return ((ToolImplementation*) _impl)->getEffectiveness();
}

bool Tool::isPrecisionLaserKnife() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 10);

		return method.executeWithBooleanReturn();
	} else
		return ((ToolImplementation*) _impl)->isPrecisionLaserKnife();
}

bool Tool::isFlowAnalyzerNode() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 11);

		return method.executeWithBooleanReturn();
	} else
		return ((ToolImplementation*) _impl)->isFlowAnalyzerNode();
}

bool Tool::isMolecularClamp() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 12);

		return method.executeWithBooleanReturn();
	} else
		return ((ToolImplementation*) _impl)->isMolecularClamp();
}

bool Tool::isUpgradeKit() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 13);

		return method.executeWithBooleanReturn();
	} else
		return ((ToolImplementation*) _impl)->isUpgradeKit();
}

/*
 *	ToolAdapter
 */

ToolAdapter::ToolAdapter(ToolImplementation* obj) : TangibleObjectAdapter(obj) {
}

Packet* ToolAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	Packet* resp = new MethodReturnMessage(0);

	switch (methid) {
	case 6:
		setToolType(inv->getUnsignedIntParameter());
		break;
	case 7:
		setEffectiveness(inv->getFloatParameter());
		break;
	case 8:
		resp->insertInt(getToolType());
		break;
	case 9:
		resp->insertFloat(getEffectiveness());
		break;
	case 10:
		resp->insertBoolean(isPrecisionLaserKnife());
		break;
	case 11:
		resp->insertBoolean(isFlowAnalyzerNode());
		break;
	case 12:
		resp->insertBoolean(isMolecularClamp());
		break;
	case 13:
		resp->insertBoolean(isUpgradeKit());
		break;
	default:
		return NULL;
	}

	return resp;
}

void ToolAdapter::setToolType(unsigned int value) {
	return ((ToolImplementation*) impl)->setToolType(value);
}

void ToolAdapter::setEffectiveness(float value) {
	return ((ToolImplementation*) impl)->setEffectiveness(value);
}

unsigned int ToolAdapter::getToolType() {
	return ((ToolImplementation*) impl)->getToolType();
}

float ToolAdapter::getEffectiveness() {
	return ((ToolImplementation*) impl)->getEffectiveness();
}

bool ToolAdapter::isPrecisionLaserKnife() {
	return ((ToolImplementation*) impl)->isPrecisionLaserKnife();
}

bool ToolAdapter::isFlowAnalyzerNode() {
	return ((ToolImplementation*) impl)->isFlowAnalyzerNode();
}

bool ToolAdapter::isMolecularClamp() {
	return ((ToolImplementation*) impl)->isMolecularClamp();
}

bool ToolAdapter::isUpgradeKit() {
	return ((ToolImplementation*) impl)->isUpgradeKit();
}

/*
 *	ToolHelper
 */

ToolHelper* ToolHelper::staticInitializer = ToolHelper::instance();

ToolHelper::ToolHelper() {
	className = "Tool";

	DistributedObjectBroker::instance()->registerClass(className, this);
}

void ToolHelper::finalizeHelper() {
	ToolHelper::finalize();
}

DistributedObject* ToolHelper::instantiateObject() {
	return new Tool(DummyConstructorParameter::instance());
}

DistributedObjectAdapter* ToolHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new ToolAdapter((ToolImplementation*) obj->_getImplementation());

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	ToolServant
 */

ToolServant::ToolServant(unsigned long long oid, int type) : TangibleObjectImplementation(oid, type) {
	_classHelper = ToolHelper::instance();
}

ToolServant::~ToolServant() {
}

void ToolServant::_setStub(DistributedObjectStub* stub) {
	_this = (Tool*) stub;
	TangibleObjectServant::_setStub(stub);
}

DistributedObjectStub* ToolServant::_getStub() {
	return _this;
}

